# Generated by API Builder - https://www.apibuilder.io
# Service version: 0.8.46
# apibuilder 0.14.89 app.apibuilder.io/flow/api/latest/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

# The Flow Commerce REST API provides full access to the global ecommerce
# platform.
module Io
  module Flow
    module V0

      class Client

        module Constants

          BASE_URL = 'https://api.flow.io' unless defined?(Constants::BASE_URL)
          NAMESPACE = 'io.flow.v0' unless defined?(Constants::NAMESPACE)
          USER_AGENT = 'apibuilder 0.14.89 app.apibuilder.io/flow/api/latest/ruby_client' unless defined?(Constants::USER_AGENT)
          VERSION = '0.8.46' unless defined?(Constants::VERSION)
          VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

        end

        attr_reader :url

        def initialize(url, opts={})
          @url = HttpClient::Preconditions.assert_class('url', url, String)
          @base_url = URI(url)
          @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
          @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
          @http_handler = opts.delete(:http_handler) || HttpClient::DefaultHttpHandler.new

          HttpClient::Preconditions.assert_empty_opts(opts)
          HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
        end

        # Creates an instance of the client using the base url specified in the API spec.
        def Client.at_base_url(opts={})
          Client.new(Constants::BASE_URL, opts)
        end

        def request(path=nil)
          HttpClient::Preconditions.assert_class_or_nil('path', path, String)
          request = HttpClient::Request.new(@http_handler, @base_url, path.to_s).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

          @default_headers.each do |key, value|
            request = request.with_header(key, value)
          end

          if @authorization
            request = request.with_auth(@authorization)
          end

          request
        end

        def address_configurations
          @address_configurations ||= ::Io::Flow::V0::Clients::AddressConfigurations.new(self)
        end

        def allocations
          @allocations ||= ::Io::Flow::V0::Clients::Allocations.new(self)
        end

        def attributes
          @attributes ||= ::Io::Flow::V0::Clients::Attributes.new(self)
        end

        def catalogs
          @catalogs ||= ::Io::Flow::V0::Clients::Catalogs.new(self)
        end

        def checkout_attributes
          @checkout_attributes ||= ::Io::Flow::V0::Clients::CheckoutAttributes.new(self)
        end

        def checkout_item_contents
          @checkout_item_contents ||= ::Io::Flow::V0::Clients::CheckoutItemContents.new(self)
        end

        def credit_payments
          @credit_payments ||= ::Io::Flow::V0::Clients::CreditPayments.new(self)
        end

        def experiences
          @experiences ||= ::Io::Flow::V0::Clients::Experiences.new(self)
        end

        def experience_checkout_settings
          @experience_checkout_settings ||= ::Io::Flow::V0::Clients::ExperienceCheckoutSettings.new(self)
        end

        def experience_defaults
          @experience_defaults ||= ::Io::Flow::V0::Clients::ExperienceDefaults.new(self)
        end

        def experience_logistics_settings
          @experience_logistics_settings ||= ::Io::Flow::V0::Clients::ExperienceLogisticsSettings.new(self)
        end

        def items
          @items ||= ::Io::Flow::V0::Clients::Items.new(self)
        end

        def item_form_overlays
          @item_form_overlays ||= ::Io::Flow::V0::Clients::ItemFormOverlays.new(self)
        end

        def orders
          @orders ||= ::Io::Flow::V0::Clients::Orders.new(self)
        end

        def order_builders
          @order_builders ||= ::Io::Flow::V0::Clients::OrderBuilders.new(self)
        end

        def order_estimates
          @order_estimates ||= ::Io::Flow::V0::Clients::OrderEstimates.new(self)
        end

        def order_identifiers
          @order_identifiers ||= ::Io::Flow::V0::Clients::OrderIdentifiers.new(self)
        end

        def order_number_generators
          @order_number_generators ||= ::Io::Flow::V0::Clients::OrderNumberGenerators.new(self)
        end

        def order_promotions
          @order_promotions ||= ::Io::Flow::V0::Clients::OrderPromotions.new(self)
        end

        def order_summaries
          @order_summaries ||= ::Io::Flow::V0::Clients::OrderSummaries.new(self)
        end

        def organizations
          @organizations ||= ::Io::Flow::V0::Clients::Organizations.new(self)
        end

        def payment_method_rules
          @payment_method_rules ||= ::Io::Flow::V0::Clients::PaymentMethodRules.new(self)
        end

        def price_books
          @price_books ||= ::Io::Flow::V0::Clients::PriceBooks.new(self)
        end

        def price_book_items
          @price_book_items ||= ::Io::Flow::V0::Clients::PriceBookItems.new(self)
        end

        def subcatalogs
          @subcatalogs ||= ::Io::Flow::V0::Clients::Subcatalogs.new(self)
        end

        def subcatalog_items
          @subcatalog_items ||= ::Io::Flow::V0::Clients::SubcatalogItems.new(self)
        end

        def subcatalog_queries
          @subcatalog_queries ||= ::Io::Flow::V0::Clients::SubcatalogQueries.new(self)
        end

        def targetings
          @targetings ||= ::Io::Flow::V0::Clients::Targetings.new(self)
        end

        def targeting_items
          @targeting_items ||= ::Io::Flow::V0::Clients::TargetingItems.new(self)
        end

        def organization_currency_settings
          @organization_currency_settings ||= ::Io::Flow::V0::Clients::OrganizationCurrencySettings.new(self)
        end

        def rates
          @rates ||= ::Io::Flow::V0::Clients::Rates.new(self)
        end

        def harmonized_categories
          @harmonized_categories ||= ::Io::Flow::V0::Clients::HarmonizedCategories.new(self)
        end

        def harmonized_landed_costs
          @harmonized_landed_costs ||= ::Io::Flow::V0::Clients::HarmonizedLandedCosts.new(self)
        end

        def hs10
          @hs10 ||= ::Io::Flow::V0::Clients::Hs10.new(self)
        end

        def tax_registrations
          @tax_registrations ||= ::Io::Flow::V0::Clients::TaxRegistrations.new(self)
        end

        def authorizations
          @authorizations ||= ::Io::Flow::V0::Clients::Authorizations.new(self)
        end

        def captures
          @captures ||= ::Io::Flow::V0::Clients::Captures.new(self)
        end

        def cards
          @cards ||= ::Io::Flow::V0::Clients::Cards.new(self)
        end

        def card_payment_sources
          @card_payment_sources ||= ::Io::Flow::V0::Clients::CardPaymentSources.new(self)
        end

        def gateway_authentication_data
          @gateway_authentication_data ||= ::Io::Flow::V0::Clients::GatewayAuthenticationData.new(self)
        end

        def payments
          @payments ||= ::Io::Flow::V0::Clients::Payments.new(self)
        end

        def public_keys
          @public_keys ||= ::Io::Flow::V0::Clients::PublicKeys.new(self)
        end

        def refunds
          @refunds ||= ::Io::Flow::V0::Clients::Refunds.new(self)
        end

        def reversals
          @reversals ||= ::Io::Flow::V0::Clients::Reversals.new(self)
        end

        def virtual_cards
          @virtual_cards ||= ::Io::Flow::V0::Clients::VirtualCards.new(self)
        end

        def virtual_card_captures
          @virtual_card_captures ||= ::Io::Flow::V0::Clients::VirtualCardCaptures.new(self)
        end

        def virtual_card_refunds
          @virtual_card_refunds ||= ::Io::Flow::V0::Clients::VirtualCardRefunds.new(self)
        end

        def centers
          @centers ||= ::Io::Flow::V0::Clients::Centers.new(self)
        end

        def delivery_windows
          @delivery_windows ||= ::Io::Flow::V0::Clients::DeliveryWindows.new(self)
        end

        def dimension_estimates
          @dimension_estimates ||= ::Io::Flow::V0::Clients::DimensionEstimates.new(self)
        end

        def inventory_rules
          @inventory_rules ||= ::Io::Flow::V0::Clients::InventoryRules.new(self)
        end

        def inventory_snapshots
          @inventory_snapshots ||= ::Io::Flow::V0::Clients::InventorySnapshots.new(self)
        end

        def inventory_updates
          @inventory_updates ||= ::Io::Flow::V0::Clients::InventoryUpdates.new(self)
        end

        def manifests
          @manifests ||= ::Io::Flow::V0::Clients::Manifests.new(self)
        end

        def quotes
          @quotes ||= ::Io::Flow::V0::Clients::Quotes.new(self)
        end

        def ratecards
          @ratecards ||= ::Io::Flow::V0::Clients::Ratecards.new(self)
        end

        def ratecard_estimates
          @ratecard_estimates ||= ::Io::Flow::V0::Clients::RatecardEstimates.new(self)
        end

        def ratecard_lanes
          @ratecard_lanes ||= ::Io::Flow::V0::Clients::RatecardLanes.new(self)
        end

        def ratecard_rates
          @ratecard_rates ||= ::Io::Flow::V0::Clients::RatecardRates.new(self)
        end

        def returns
          @returns ||= ::Io::Flow::V0::Clients::Returns.new(self)
        end

        def serials
          @serials ||= ::Io::Flow::V0::Clients::Serials.new(self)
        end

        def shipping_configurations
          @shipping_configurations ||= ::Io::Flow::V0::Clients::ShippingConfigurations.new(self)
        end

        def shipping_configuration_copies
          @shipping_configuration_copies ||= ::Io::Flow::V0::Clients::ShippingConfigurationCopies.new(self)
        end

        def shipping_labels
          @shipping_labels ||= ::Io::Flow::V0::Clients::ShippingLabels.new(self)
        end

        def shipping_notifications
          @shipping_notifications ||= ::Io::Flow::V0::Clients::ShippingNotifications.new(self)
        end

        def surcharge_settings
          @surcharge_settings ||= ::Io::Flow::V0::Clients::SurchargeSettings.new(self)
        end

        def tiers
          @tiers ||= ::Io::Flow::V0::Clients::Tiers.new(self)
        end

        def trackings
          @trackings ||= ::Io::Flow::V0::Clients::Trackings.new(self)
        end

        def tracking_events
          @tracking_events ||= ::Io::Flow::V0::Clients::TrackingEvents.new(self)
        end

        def tracking_labels
          @tracking_labels ||= ::Io::Flow::V0::Clients::TrackingLabels.new(self)
        end

        def webhooks
          @webhooks ||= ::Io::Flow::V0::Clients::Webhooks.new(self)
        end

        def webhook_deliveries
          @webhook_deliveries ||= ::Io::Flow::V0::Clients::WebhookDeliveries.new(self)
        end

        def webhook_settings
          @webhook_settings ||= ::Io::Flow::V0::Clients::WebhookSettings.new(self)
        end

        def addresses
          @addresses ||= ::Io::Flow::V0::Clients::Addresses.new(self)
        end

        def country_defaults
          @country_defaults ||= ::Io::Flow::V0::Clients::CountryDefaults.new(self)
        end

        def timezones
          @timezones ||= ::Io::Flow::V0::Clients::Timezones.new(self)
        end

        def carriers
          @carriers ||= ::Io::Flow::V0::Clients::Carriers.new(self)
        end

        def carrier_services
          @carrier_services ||= ::Io::Flow::V0::Clients::CarrierServices.new(self)
        end

        def countries
          @countries ||= ::Io::Flow::V0::Clients::Countries.new(self)
        end

        def currencies
          @currencies ||= ::Io::Flow::V0::Clients::Currencies.new(self)
        end

        def languages
          @languages ||= ::Io::Flow::V0::Clients::Languages.new(self)
        end

        def locales
          @locales ||= ::Io::Flow::V0::Clients::Locales.new(self)
        end

        def payment_methods
          @payment_methods ||= ::Io::Flow::V0::Clients::PaymentMethods.new(self)
        end

        def provinces
          @provinces ||= ::Io::Flow::V0::Clients::Provinces.new(self)
        end

        def regions
          @regions ||= ::Io::Flow::V0::Clients::Regions.new(self)
        end

        def b2b_credit_memos
          @b2b_credit_memos ||= ::Io::Flow::V0::Clients::B2bCreditMemos.new(self)
        end

        def b2b_invoices
          @b2b_invoices ||= ::Io::Flow::V0::Clients::B2bInvoices.new(self)
        end

        def catalog_price_book_item_documents
          @catalog_price_book_item_documents ||= ::Io::Flow::V0::Clients::CatalogPriceBookItemDocuments.new(self)
        end

        def checkout_tokens
          @checkout_tokens ||= ::Io::Flow::V0::Clients::CheckoutTokens.new(self)
        end

        def consumer_invoices
          @consumer_invoices ||= ::Io::Flow::V0::Clients::ConsumerInvoices.new(self)
        end

        def consumer_invoice_documents
          @consumer_invoice_documents ||= ::Io::Flow::V0::Clients::ConsumerInvoiceDocuments.new(self)
        end

        def credit_memos
          @credit_memos ||= ::Io::Flow::V0::Clients::CreditMemos.new(self)
        end

        def customers
          @customers ||= ::Io::Flow::V0::Clients::Customers.new(self)
        end

        def customer_address_book
          @customer_address_book ||= ::Io::Flow::V0::Clients::CustomerAddressBook.new(self)
        end

        def customer_address_book_contacts
          @customer_address_book_contacts ||= ::Io::Flow::V0::Clients::CustomerAddressBookContacts.new(self)
        end

        def customer_bundles
          @customer_bundles ||= ::Io::Flow::V0::Clients::CustomerBundles.new(self)
        end

        def customer_tokens
          @customer_tokens ||= ::Io::Flow::V0::Clients::CustomerTokens.new(self)
        end

        def documents
          @documents ||= ::Io::Flow::V0::Clients::Documents.new(self)
        end

        def ecommerce_platforms
          @ecommerce_platforms ||= ::Io::Flow::V0::Clients::EcommercePlatforms.new(self)
        end

        def email_verifications
          @email_verifications ||= ::Io::Flow::V0::Clients::EmailVerifications.new(self)
        end

        def exclusion_rules
          @exclusion_rules ||= ::Io::Flow::V0::Clients::ExclusionRules.new(self)
        end

        def exports
          @exports ||= ::Io::Flow::V0::Clients::Exports.new(self)
        end

        def flow_roles
          @flow_roles ||= ::Io::Flow::V0::Clients::FlowRoles.new(self)
        end

        def fraud_email_rules
          @fraud_email_rules ||= ::Io::Flow::V0::Clients::FraudEmailRules.new(self)
        end

        def ftp_files
          @ftp_files ||= ::Io::Flow::V0::Clients::FtpFiles.new(self)
        end

        def ftp_folders
          @ftp_folders ||= ::Io::Flow::V0::Clients::FtpFolders.new(self)
        end

        def ftp_organization_settings
          @ftp_organization_settings ||= ::Io::Flow::V0::Clients::FtpOrganizationSettings.new(self)
        end

        def fulfillments
          @fulfillments ||= ::Io::Flow::V0::Clients::Fulfillments.new(self)
        end

        def healthchecks
          @healthchecks ||= ::Io::Flow::V0::Clients::Healthchecks.new(self)
        end

        def imports
          @imports ||= ::Io::Flow::V0::Clients::Imports.new(self)
        end

        def import_templates
          @import_templates ||= ::Io::Flow::V0::Clients::ImportTemplates.new(self)
        end

        def invitations
          @invitations ||= ::Io::Flow::V0::Clients::Invitations.new(self)
        end

        def item_query_suggestions
          @item_query_suggestions ||= ::Io::Flow::V0::Clients::ItemQuerySuggestions.new(self)
        end

        def links
          @links ||= ::Io::Flow::V0::Clients::Links.new(self)
        end

        def memberships
          @memberships ||= ::Io::Flow::V0::Clients::Memberships.new(self)
        end

        def merchant_gift_card_balances
          @merchant_gift_card_balances ||= ::Io::Flow::V0::Clients::MerchantGiftCardBalances.new(self)
        end

        def merchant_gift_card_redemptions
          @merchant_gift_card_redemptions ||= ::Io::Flow::V0::Clients::MerchantGiftCardRedemptions.new(self)
        end

        def merchant_gift_card_reversals
          @merchant_gift_card_reversals ||= ::Io::Flow::V0::Clients::MerchantGiftCardReversals.new(self)
        end

        def organization_authorizations
          @organization_authorizations ||= ::Io::Flow::V0::Clients::OrganizationAuthorizations.new(self)
        end

        def organization_default_configurations
          @organization_default_configurations ||= ::Io::Flow::V0::Clients::OrganizationDefaultConfigurations.new(self)
        end

        def organization_tokens
          @organization_tokens ||= ::Io::Flow::V0::Clients::OrganizationTokens.new(self)
        end

        def partner_tokens
          @partner_tokens ||= ::Io::Flow::V0::Clients::PartnerTokens.new(self)
        end

        def password_reset_forms
          @password_reset_forms ||= ::Io::Flow::V0::Clients::PasswordResetForms.new(self)
        end

        def permission_checks
          @permission_checks ||= ::Io::Flow::V0::Clients::PermissionChecks.new(self)
        end

        def scheduled_exports
          @scheduled_exports ||= ::Io::Flow::V0::Clients::ScheduledExports.new(self)
        end

        def sessions
          @sessions ||= ::Io::Flow::V0::Clients::Sessions.new(self)
        end

        def session_authorizations
          @session_authorizations ||= ::Io::Flow::V0::Clients::SessionAuthorizations.new(self)
        end

        def shopify_carts
          @shopify_carts ||= ::Io::Flow::V0::Clients::ShopifyCarts.new(self)
        end

        def shopify_cart_conversions
          @shopify_cart_conversions ||= ::Io::Flow::V0::Clients::ShopifyCartConversions.new(self)
        end

        def shopify_localization_settings
          @shopify_localization_settings ||= ::Io::Flow::V0::Clients::ShopifyLocalizationSettings.new(self)
        end

        def shopify_location_flow_center_mappings
          @shopify_location_flow_center_mappings ||= ::Io::Flow::V0::Clients::ShopifyLocationFlowCenterMappings.new(self)
        end

        def shopify_private_apps
          @shopify_private_apps ||= ::Io::Flow::V0::Clients::ShopifyPrivateApps.new(self)
        end

        def shopify_sync_statuses
          @shopify_sync_statuses ||= ::Io::Flow::V0::Clients::ShopifySyncStatuses.new(self)
        end

        def suggestions
          @suggestions ||= ::Io::Flow::V0::Clients::Suggestions.new(self)
        end

        def tax_settings
          @tax_settings ||= ::Io::Flow::V0::Clients::TaxSettings.new(self)
        end

        def tokens
          @tokens ||= ::Io::Flow::V0::Clients::Tokens.new(self)
        end

        def token_validations
          @token_validations ||= ::Io::Flow::V0::Clients::TokenValidations.new(self)
        end

        def uploads
          @uploads ||= ::Io::Flow::V0::Clients::Uploads.new(self)
        end

        def users
          @users ||= ::Io::Flow::V0::Clients::Users.new(self)
        end
      end

      module Clients

        class AddressConfigurations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search checkout address configurations.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, Array).map { |v| HttpClient::Preconditions.assert_class('country', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/address/configurations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AddressConfiguration.new(x) }
          end

        end

        class Allocations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Order-level price details allocated using a strategy among individual order
          # item units.
          def get(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/allocations/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::AllocationV2.new(r)
          end

        end

        class Attributes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search attributes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Attribute.new(x) }
          end

          # Add attribute
          def post(organization, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = attribute_form; x.is_a?(::Io::Flow::V0::Models::AttributeForm) ? x : ::Io::Flow::V0::Models::AttributeForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_json(attribute_form.to_json).post
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AttributeVersion.new(x) }
          end

          # Returns information about a specific attribute.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Create or update an attribute with the specified key.
          def put_by_key(organization, key, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = attribute_form; x.is_a?(::Io::Flow::V0::Models::AttributeForm) ? x : ::Io::Flow::V0::Models::AttributeForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").with_json(attribute_form.to_json).put
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Delete an attribute with the specified key.
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").delete
            nil
          end

        end

        class Catalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns information about a specific catalog.
          def get_catalog(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog").get
            ::Io::Flow::V0::Models::Catalog.new(r)
          end

          # Search global restrictions. Always paginated.
          def get_catalog_and_restrictions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns a specific globally restricted item.
          def get_catalog_and_restrictions_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Upsert a global restriction
          def put_catalog_and_restrictions_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions/#{CGI.escape(number)}").put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the global restriction for this catalog item number
          def delete_catalog_and_restrictions_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions/#{CGI.escape(number)}").delete
            nil
          end

          # Get statistics for this organization's catalog.
          def get_catalog_and_statistics(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/statistics").get
            ::Io::Flow::V0::Models::CatalogStatistics.new(r)
          end

        end

        class CheckoutAttributes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :experience_key => (x = opts.delete(:experience_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience_key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/checkout/attributes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CheckoutAttribute.new(x) }
          end

          def post(organization, checkout_attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = checkout_attribute_form; x.is_a?(::Io::Flow::V0::Models::CheckoutAttributeForm) ? x : ::Io::Flow::V0::Models::CheckoutAttributeForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/checkout/attributes").with_json(checkout_attribute_form.to_json).post
            ::Io::Flow::V0::Models::CheckoutAttribute.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/checkout/attributes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::CheckoutAttribute.new(r)
          end

          def put_by_id(organization, id, checkout_attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = checkout_attribute_form; x.is_a?(::Io::Flow::V0::Models::CheckoutAttributeForm) ? x : ::Io::Flow::V0::Models::CheckoutAttributeForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/checkout/attributes/#{CGI.escape(id)}").with_json(checkout_attribute_form.to_json).put
            ::Io::Flow::V0::Models::CheckoutAttribute.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/checkout/attributes/#{CGI.escape(id)}").delete
            nil
          end

        end

        class CheckoutItemContents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a localized view of 1 or more items in the context of checkout,
          # returning data specifically related to rendering a view of an item in a cart
          # or checkout page.
          def get_checkout(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/item/content/checkout").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CheckoutItemContent.new(x) }
          end

        end

        class CreditPayments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/credit/payments").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CreditPayment.new(x) }
          end

          def post(organization, credit_payment_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = credit_payment_form; x.is_a?(::Io::Flow::V0::Models::CreditPaymentForm) ? x : ::Io::Flow::V0::Models::CreditPaymentForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/credit/payments").with_query(query).with_json(credit_payment_form.to_json).post
            ::Io::Flow::V0::Models::CreditPayment.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/credit/payments/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CreditPaymentVersion.new(x) }
          end

          def get_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/credit/payments/#{CGI.escape(key)}").with_query(query).get
            ::Io::Flow::V0::Models::CreditPayment.new(r)
          end

          def put_by_key(organization, key, credit_payment_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = credit_payment_form; x.is_a?(::Io::Flow::V0::Models::CreditPaymentForm) ? x : ::Io::Flow::V0::Models::CreditPaymentForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/credit/payments/#{CGI.escape(key)}").with_query(query).with_json(credit_payment_form.to_json).put
            ::Io::Flow::V0::Models::CreditPayment.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/credit/payments/#{CGI.escape(key)}").delete
            nil
          end

        end

        class Experiences

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search experiences. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :region => (x = opts.delete(:region); x.nil? ? nil : HttpClient::Preconditions.assert_class('region', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :subcatalog => (x = opts.delete(:subcatalog); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :status => (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExperienceStatus) ? x : ::Io::Flow::V0::Models::ExperienceStatus.apply(x)).value),
              :shipping_configuration_key => (x = opts.delete(:shipping_configuration_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipping_configuration_key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Experience.new(x) }
          end

          # Add experience
          def post(organization, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = experience_form; x.is_a?(::Io::Flow::V0::Models::ExperienceForm) ? x : ::Io::Flow::V0::Models::ExperienceForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_json(experience_form.to_json).post
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Formats the requested amount using the formatting settings for the
          # experience.
          def get_conversions_by_base_and_amount(organization, base, amount, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('base', base, String)
            HttpClient::Preconditions.assert_class('amount', amount, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/conversions/#{CGI.escape(base)}/#{CGI.escape(amount)}").with_query(query).get
            ::Io::Flow::V0::Models::PriceWithBase.new(r)
          end

          # Returns localized information about 1 or more items. The items will be
          # localized based on the experience selected by the query parameters in the
          # order of experience, then country, then ip address.
          def get_items(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :status => (x = opts.delete(:status); x.nil? ? nil : HttpClient::Preconditions.assert_class('status', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x)).value }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about this item localized based on the query parameters
          def get_items_by_number(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items/#{CGI.escape(number)}").with_query(query).get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Builds a query to search experiences
          def post_query_and_builders(organization, query_builder_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = query_builder_form; x.is_a?(::Io::Flow::V0::Models::QueryBuilderForm) ? x : ::Io::Flow::V0::Models::QueryBuilderForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/query/builders").with_json(query_builder_form.to_json).post
            ::Io::Flow::V0::Models::QueryBuilder.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExperienceVersion.new(x) }
          end

          def get_currency_and_formats_by_experience_key(organization, experience_key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/currency/formats").get
            ::Io::Flow::V0::Models::ExperienceCurrencyFormat.new(r)
          end

          def put_currency_and_formats_by_experience_key(organization, experience_key, experience_currency_format_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            (x = experience_currency_format_form; x.is_a?(::Io::Flow::V0::Models::ExperienceCurrencyFormatForm) ? x : ::Io::Flow::V0::Models::ExperienceCurrencyFormatForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/currency/formats").with_json(experience_currency_format_form.to_json).put
            ::Io::Flow::V0::Models::ExperienceCurrencyFormat.new(r)
          end

          # Returns localized information about 0 or more items given a query for the
          # specified experience.
          def get_local_and_items_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/local/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LocalItem.new(x) }
          end

          def get_logistics_and_summary_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/logistics/summary").with_query(query).get
            ::Io::Flow::V0::Models::ExperienceLogisticsSummary.new(r)
          end

          def get_margins_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemMargin.new(x) }
          end

          def post_margins_by_experience_key(organization, experience_key, item_margin_post_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            (x = item_margin_post_form; x.is_a?(::Io::Flow::V0::Models::ItemMarginPostForm) ? x : ::Io::Flow::V0::Models::ItemMarginPostForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins").with_json(item_margin_post_form.to_json).post
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def get_margins_and_versions_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemMarginVersion.new(x) }
          end

          def get_margins_by_experience_key_and_key(organization, experience_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def put_margins_by_experience_key_and_key(organization, experience_key, key, item_margin_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = item_margin_put_form; x.is_a?(::Io::Flow::V0::Models::ItemMarginPutForm) ? x : ::Io::Flow::V0::Models::ItemMarginPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/#{CGI.escape(key)}").with_json(item_margin_put_form.to_json).put
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def delete_margins_by_experience_key_and_key(organization, experience_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/#{CGI.escape(key)}").delete
            nil
          end

          def get_payment_method_types_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/payment-method-types").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PaymentMethodType.new(x) }
          end

          def get_payment_and_method_and_rules_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :payment_method_type => (x = opts.delete(:payment_method_type); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment_method_type', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentMethodType) ? x : ::Io::Flow::V0::Models::PaymentMethodType.apply(x)).value }),
              :tags => (x = opts.delete(:tags); x.nil? ? nil : HttpClient::Preconditions.assert_class('tags', x, Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) }),
              :amount => (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "display_position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/payment/method/rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PaymentMethodRule.new(x) }
          end

          # Change the ordering or payment tags for an experience. Every post must
          # include one entry for each payment method offered by Flow.
          def put_payment_and_method_and_rules_by_experience_key(organization, experience_key, experience_payment_method_rule_forms)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('experience_payment_method_rule_forms', experience_payment_method_rule_forms, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperiencePaymentMethodRuleForm) ? x : ::Io::Flow::V0::Models::ExperiencePaymentMethodRuleForm.new(x)) }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/payment/method/rules").with_json(experience_payment_method_rule_forms.map { |o| o.to_hash }.to_json).put
            r.map { |x| ::Io::Flow::V0::Models::PaymentMethodRule.new(x) }
          end

          def get_price_and_books_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :price_book_key => (x = opts.delete(:price_book_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('price_book_key', x, Array).map { |v| HttpClient::Preconditions.assert_class('price_book_key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/price/books").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExperiencePriceBookMapping.new(x) }
          end

          def post_price_and_books_by_experience_key(organization, experience_key, experience_price_book_mapping_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            (x = experience_price_book_mapping_form; x.is_a?(::Io::Flow::V0::Models::ExperiencePriceBookMappingForm) ? x : ::Io::Flow::V0::Models::ExperiencePriceBookMappingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/price/books").with_json(experience_price_book_mapping_form.to_json).post
            ::Io::Flow::V0::Models::ExperiencePriceBookMapping.new(r)
          end

          def put_price_and_books_by_experience_key(organization, experience_key, experience_price_book_mapping_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            (x = experience_price_book_mapping_put_form; x.is_a?(::Io::Flow::V0::Models::ExperiencePriceBookMappingPutForm) ? x : ::Io::Flow::V0::Models::ExperiencePriceBookMappingPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/price/books").with_json(experience_price_book_mapping_put_form.to_json).put
            r.map { |x| ::Io::Flow::V0::Models::ExperiencePriceBookMapping.new(x) }
          end

          def get_price_and_books_by_experience_key_and_key(organization, experience_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/price/books/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ExperiencePriceBookMapping.new(r)
          end

          def delete_price_and_books_by_experience_key_and_key(organization, experience_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/price/books/#{CGI.escape(key)}").delete
            nil
          end

          # Returns information about a specific experience.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Update experience with the specified key, creating if it does not exist.
          def put_by_key(organization, key, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = experience_form; x.is_a?(::Io::Flow::V0::Models::ExperienceForm) ? x : ::Io::Flow::V0::Models::ExperienceForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").with_json(experience_form.to_json).put
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Delete the experience with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").delete
            nil
          end

          # Clones the experience with the specified key, using data from
          # experience_clone_form.
          def post_clone_by_key(organization, key, experience_clone_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = experience_clone_form; x.is_a?(::Io::Flow::V0::Models::ExperienceCloneForm) ? x : ::Io::Flow::V0::Models::ExperienceCloneForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/clone").with_json(experience_clone_form.to_json).post
            ::Io::Flow::V0::Models::ExperienceClone.new(r)
          end

          # Returns the experience_clone associated with the id.
          def get_clone_by_key_and_id(organization, key, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/clone/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ExperienceClone.new(r)
          end

          # Returns detailed information on the pricing of this item within this
          # experience
          def get_items_and_price_by_key_and_number(organization, key, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :price_amount => (x = opts.delete(:price_amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('price_amount', x, Numeric)),
              :price_currency => (x = opts.delete(:price_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('price_currency', x, String)),
              :ship_from_country => (x = opts.delete(:ship_from_country); x.nil? ? nil : HttpClient::Preconditions.assert_class('ship_from_country', x, String)),
              :ship_from_province => (x = opts.delete(:ship_from_province); x.nil? ? nil : HttpClient::Preconditions.assert_class('ship_from_province', x, String)),
              :ship_to_country => (x = opts.delete(:ship_to_country); x.nil? ? nil : HttpClient::Preconditions.assert_class('ship_to_country', x, String)),
              :ship_to_province => (x = opts.delete(:ship_to_province); x.nil? ? nil : HttpClient::Preconditions.assert_class('ship_to_province', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/items/#{CGI.escape(number)}/price").with_query(query).get
            ::Io::Flow::V0::Models::PriceCheck.new(r)
          end

          # Get the pricing settings for this experience
          def get_pricing_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/pricing").get
            ::Io::Flow::V0::Models::Pricing.new(r)
          end

          # Update the pricing settings for this experience
          def put_pricing_by_key(organization, key, pricing)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = pricing; x.is_a?(::Io::Flow::V0::Models::Pricing) ? x : ::Io::Flow::V0::Models::Pricing.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/pricing").with_json(pricing.to_json).put
            ::Io::Flow::V0::Models::Pricing.new(r)
          end

          # Get available promotions for the experience
          def get_promotions_and_available_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/promotions/available").get
            r.map { |x| ::Io::Flow::V0::Models::Promotion.from_json(x) }
          end

          # Updates the status of a given experience.
          def put_status_by_key(organization, key, experience_status_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = experience_status_form; x.is_a?(::Io::Flow::V0::Models::ExperienceStatusForm) ? x : ::Io::Flow::V0::Models::ExperienceStatusForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/status").with_json(experience_status_form.to_json).put
            ::Io::Flow::V0::Models::Experience.new(r)
          end

        end

        class ExperienceCheckoutSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, experience_key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/settings/checkout").get
            ::Io::Flow::V0::Models::ExperienceCheckoutSettings.new(r)
          end

          def put(organization, experience_key, experience_checkout_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            (x = experience_checkout_settings_form; x.is_a?(::Io::Flow::V0::Models::ExperienceCheckoutSettingsForm) ? x : ::Io::Flow::V0::Models::ExperienceCheckoutSettingsForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/settings/checkout").with_json(experience_checkout_settings_form.to_json).put
            ::Io::Flow::V0::Models::ExperienceCheckoutSettings.new(r)
          end

        end

        class ExperienceDefaults

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns recommended default settings when creating a new experience
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :region_id => (x = opts.delete(:region_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('region_id', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experience/defaults").with_query(query).get
            ::Io::Flow::V0::Models::ExperienceDefaults.new(r)
          end

        end

        class ExperienceLogisticsSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, experience_key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/settings/logistics").get
            ::Io::Flow::V0::Models::ExperienceLogisticsSettings.new(r)
          end

          def put(organization, experience_key, experience_logistics_settings_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            (x = experience_logistics_settings_put_form; x.is_a?(::Io::Flow::V0::Models::ExperienceLogisticsSettingsPutForm) ? x : ::Io::Flow::V0::Models::ExperienceLogisticsSettingsPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/settings/logistics").with_json(experience_logistics_settings_put_form.to_json).put
            ::Io::Flow::V0::Models::ExperienceLogisticsSettings.new(r)
          end

        end

        class Items

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search items. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Add catalog item(s)
          def post(organization, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = item_form; x.is_a?(::Io::Flow::V0::Models::ItemForm) ? x : ::Io::Flow::V0::Models::ItemForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_json(item_form.to_json).post
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemVersion.new(x) }
          end

          # Returns information about a specific item.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update item with the specified number, creating if it does not exist.
          def put_by_number(organization, number, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = item_form; x.is_a?(::Io::Flow::V0::Models::ItemForm) ? x : ::Io::Flow::V0::Models::ItemForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").with_json(item_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the item with this number
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").delete
            nil
          end

          # Update item with the specified attributes.
          def patch_attributes_by_number(organization, number, item_attributes_patch_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = item_attributes_patch_form; x.is_a?(::Io::Flow::V0::Models::ItemAttributesPatchForm) ? x : ::Io::Flow::V0::Models::ItemAttributesPatchForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}/attributes").with_json(item_attributes_patch_form.to_json).patch
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update item with the specified number, creating if it does not exist.
          def put_price_by_number(organization, number, item_price_update_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = item_price_update_put_form; x.is_a?(::Io::Flow::V0::Models::ItemPriceUpdatePutForm) ? x : ::Io::Flow::V0::Models::ItemPriceUpdatePutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}/price").with_json(item_price_update_put_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

        end

        class ItemFormOverlays

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/item/overlays").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemFormOverlay.new(x) }
          end

          # Adds an overlay data to merge into a catalog item
          def post(organization, item_form_overlay_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = item_form_overlay_form; x.is_a?(::Io::Flow::V0::Models::ItemFormOverlayForm) ? x : ::Io::Flow::V0::Models::ItemFormOverlayForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/item/overlays").with_json(item_form_overlay_form.to_json).post
            ::Io::Flow::V0::Models::ItemFormOverlay.new(r)
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/item/overlays/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ItemFormOverlay.new(r)
          end

          # Update item overlay with the specified key, creating if it does not exist.
          def put_by_key(organization, key, item_form_overlay_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = item_form_overlay_form; x.is_a?(::Io::Flow::V0::Models::ItemFormOverlayForm) ? x : ::Io::Flow::V0::Models::ItemFormOverlayForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/item/overlays/#{CGI.escape(key)}").with_json(item_form_overlay_form.to_json).put
            ::Io::Flow::V0::Models::ItemFormOverlay.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/item/overlays/#{CGI.escape(key)}").delete
            nil
          end

        end

        class Orders

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search orders. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :identifier => (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, String)),
              :status => (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderStatus) ? x : ::Io::Flow::V0::Models::OrderStatus.apply(x)).value),
              :customer_number => (x = opts.delete(:customer_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('customer_number', x, String)),
              :submitted_at_on_or_after => (x = opts.delete(:submitted_at_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_at_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime)),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Order.new(x) }
          end

          # Create an order, using the localized information from the experience
          # selected by the query parameters. Note the order must be submitted before
          # its expiration
          def post(organization, order_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_form; x.is_a?(::Io::Flow::V0::Models::OrderForm) ? x : ::Io::Flow::V0::Models::OrderForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders").with_query(query).with_json(order_form.to_json).post
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Returns information about a specific order using an identifier number
          def get_identifier_by_identifier(organization, identifier, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/identifier/#{CGI.escape(identifier)}").with_query(query).get
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Provides visibility into recent changes of each order, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :journal_timestamp_on_or_after => (x = opts.delete(:journal_timestamp_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('journal_timestamp_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderVersion.new(x) }
          end

          # Returns information about a specific order.
          def get_by_number(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").with_query(query).get
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Upserts an order. using the localized information from the experience
          # selected by the query parameters. Note the order must be submitted before
          # its expiration
          def put_by_number(organization, number, order_put_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_put_form; x.is_a?(::Io::Flow::V0::Models::OrderPutForm) ? x : ::Io::Flow::V0::Models::OrderPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").with_query(query).with_json(order_put_form.to_json).put
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Delete an order. Note that production orders that have already been
          # submitted cannot be deleted (you will see a 422 response in these cases).
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").delete
            nil
          end

          # Order allocations provide a granular view of an order that is targeted for
          # accounting / financial views of an order
          def get_allocations_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/allocations").get
            ::Io::Flow::V0::Models::AllocationV2.new(r)
          end

          # Creates an authorization, automatically associating to this order.
          def post_authorizations_by_number(organization, number, authorization_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = authorization_form; x.is_a?(::Io::Flow::V0::Models::AuthorizationForm) ? x : ::Io::Flow::V0::Models::AuthorizationForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/authorizations").with_query(query).with_json(authorization_form.to_json).post
            ::Io::Flow::V0::Models::Authorization.from_json(r)
          end

          # Updates an order's destination address
          def put_destination_by_number(organization, number, order_destination_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = order_destination_put_form; x.is_a?(::Io::Flow::V0::Models::OrderDestinationPutForm) ? x : ::Io::Flow::V0::Models::OrderDestinationPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/destination").with_json(order_destination_put_form.to_json).put
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Creates an installment plan for this order, automatically associating to
          # this order.
          def post_installment_and_plan_and_authorizations_by_number(organization, number, installment_plan_payment_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = installment_plan_payment_form; x.is_a?(::Io::Flow::V0::Models::InstallmentPlanPaymentForm) ? x : ::Io::Flow::V0::Models::InstallmentPlanPaymentForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/installment/plan/authorizations").with_json(installment_plan_payment_form.to_json).post
            ::Io::Flow::V0::Models::Order.new(r)
          end

          def put_inventory_and_reservations_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/inventory/reservations").put
            ::Io::Flow::V0::Models::Reservation.new(r)
          end

          # Creates a free shipping promotion for this order, automatically applying it
          # to the order if the order meets the defined promotion trigger.
          def put_promotions_and_free_shipping_by_number_and_key(organization, number, key, free_shipping_order_promotion_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = free_shipping_order_promotion_form; x.is_a?(::Io::Flow::V0::Models::FreeShippingOrderPromotionForm) ? x : ::Io::Flow::V0::Models::FreeShippingOrderPromotionForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/promotions/#{CGI.escape(key)}/free_shipping").with_query(query).with_json(free_shipping_order_promotion_form.to_json).put
            ::Io::Flow::V0::Models::FreeShippingOrderPromotion.new(r)
          end

          def post_service_and_changes_by_number(organization, number, order_service_change_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = order_service_change_form; x.is_a?(::Io::Flow::V0::Models::OrderServiceChangeForm) ? x : ::Io::Flow::V0::Models::OrderServiceChangeForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/service/changes").with_json(order_service_change_form.to_json).post
            ::Io::Flow::V0::Models::OrderServiceChange.new(r)
          end

          # Submits an order. You will get a validation error if the order has already
          # expired (and a new quote could not be automatically recreated for a lower or
          # same price). This method is idempotent - submitting an order a second time
          # has no effect.
          def put_submissions_by_number(organization, number, order_submission_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_submission_form; x.is_a?(::Io::Flow::V0::Models::OrderSubmissionForm) ? x : ::Io::Flow::V0::Models::OrderSubmissionForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/submissions").with_query(query).with_json(order_submission_form.to_json).put
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Validates a tax registration number, proxying to underlying services and
          # recording the result on the order.
          def put_tax_and_registration_by_number(organization, number, tax_registration_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = tax_registration_form; x.is_a?(::Io::Flow::V0::Models::TaxRegistrationForm) ? x : ::Io::Flow::V0::Models::TaxRegistrationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/tax/registration").with_json(tax_registration_form.to_json).put
            ::Io::Flow::V0::Models::TaxRegistration.new(r)
          end

          def delete_tax_and_registration_by_number_and_key(organization, number, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/tax/registration/#{CGI.escape(key)}").delete
            nil
          end

          # Retrieve the current fraud status for an order.
          def get_status_and_fraud_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/status/fraud").get
            ::Io::Flow::V0::Models::OrderFraudStatus.new(r)
          end

          # Generate a commercial invoice for the order without providing a label.
          def post_labels_and_documents_and_invoice_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/labels/documents/invoice").post
            ::Io::Flow::V0::Models::ShippingLabelDocument.new(r)
          end

        end

        class OrderBuilders

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(organization, order_put_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_put_form; x.is_a?(::Io::Flow::V0::Models::OrderPutForm) ? x : ::Io::Flow::V0::Models::OrderPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders").with_query(query).with_json(order_put_form.to_json).post
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          def put_carts_by_number(organization, number, order_put_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_put_form; x.is_a?(::Io::Flow::V0::Models::OrderPutForm) ? x : ::Io::Flow::V0::Models::OrderPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/carts/#{CGI.escape(number)}").with_query(query).with_json(order_put_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          # Returns information about a specific order and any errors associated with
          # the order.
          def get_by_number(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}").with_query(query).get
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          def put_by_number(organization, number, order_put_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_put_form; x.is_a?(::Io::Flow::V0::Models::OrderPutForm) ? x : ::Io::Flow::V0::Models::OrderPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}").with_query(query).with_json(order_put_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          def put_attributes_by_number(organization, number, order_builder_attributes_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_builder_attributes_form; x.is_a?(::Io::Flow::V0::Models::OrderBuilderAttributesForm) ? x : ::Io::Flow::V0::Models::OrderBuilderAttributesForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}/attributes").with_query(query).with_json(order_builder_attributes_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          def put_country_by_number(organization, number, order_builder_destination_country_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_builder_destination_country_form; x.is_a?(::Io::Flow::V0::Models::OrderBuilderDestinationCountryForm) ? x : ::Io::Flow::V0::Models::OrderBuilderDestinationCountryForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}/country").with_query(query).with_json(order_builder_destination_country_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          def put_destination_by_number(organization, number, order_builder_destination_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_builder_destination_form; x.is_a?(::Io::Flow::V0::Models::OrderBuilderDestinationForm) ? x : ::Io::Flow::V0::Models::OrderBuilderDestinationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}/destination").with_query(query).with_json(order_builder_destination_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          def put_duty_by_number(organization, number, order_builder_delivered_duty_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_builder_delivered_duty_form; x.is_a?(::Io::Flow::V0::Models::OrderBuilderDeliveredDutyForm) ? x : ::Io::Flow::V0::Models::OrderBuilderDeliveredDutyForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}/duty").with_query(query).with_json(order_builder_delivered_duty_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          # Update the customer invoice address
          def put_invoice_and_address_by_number(organization, number, order_builder_customer_invoice_address_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_builder_customer_invoice_address_form; x.is_a?(::Io::Flow::V0::Models::OrderBuilderCustomerInvoiceAddressForm) ? x : ::Io::Flow::V0::Models::OrderBuilderCustomerInvoiceAddressForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}/invoice/address").with_query(query).with_json(order_builder_customer_invoice_address_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

          # Validates a tax registration number, proxying to underlying services and
          # recording the result on the order.
          def put_tax_and_registration_by_number(organization, number, tax_registration_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = tax_registration_form; x.is_a?(::Io::Flow::V0::Models::TaxRegistrationForm) ? x : ::Io::Flow::V0::Models::TaxRegistrationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order/builders/#{CGI.escape(number)}/tax/registration").with_query(query).with_json(tax_registration_form.to_json).put
            ::Io::Flow::V0::Models::OrderBuilder.new(r)
          end

        end

        class OrderEstimates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Create an order estimate, using the localized information from the
          # experience selected by the query parameters. This is similar to the POST
          # orders endpoint, except this just returns an estimate and cannot be
          # submitted.
          def post(organization, order_estimate_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_estimate_form; x.is_a?(::Io::Flow::V0::Models::OrderEstimateForm) ? x : ::Io::Flow::V0::Models::OrderEstimateForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order-estimates").with_query(query).with_json(order_estimate_form.to_json).post
            ::Io::Flow::V0::Models::OrderEstimate.new(r)
          end

          def get_by_number(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/order-estimates/#{CGI.escape(number)}").with_query(query).get
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          def put_by_number(organization, number, order_estimate_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :romanize => (x = opts.delete(:romanize); x.nil? ? nil : HttpClient::Preconditions.assert_class('romanize', x, Array).map { |v| HttpClient::Preconditions.assert_class('romanize', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = order_estimate_form; x.is_a?(::Io::Flow::V0::Models::OrderEstimateForm) ? x : ::Io::Flow::V0::Models::OrderEstimateForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order-estimates/#{CGI.escape(number)}").with_query(query).with_json(order_estimate_form.to_json).put
            ::Io::Flow::V0::Models::OrderEstimate.new(r)
          end

        end

        class OrderIdentifiers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :identifier => (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, Array).map { |v| HttpClient::Preconditions.assert_class('identifier', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderIdentifier.new(x) }
          end

          def post(organization, order_identifier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = order_identifier_form; x.is_a?(::Io::Flow::V0::Models::OrderIdentifierForm) ? x : ::Io::Flow::V0::Models::OrderIdentifierForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers").with_json(order_identifier_form.to_json).post
            ::Io::Flow::V0::Models::OrderIdentifier.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderIdentifierVersion.new(x) }
          end

          def get_by_identifier(organization, identifier)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/#{CGI.escape(identifier)}").get
            ::Io::Flow::V0::Models::OrderIdentifier.new(r)
          end

          def put_by_identifier(organization, identifier, order_identifier_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            (x = order_identifier_put_form; x.is_a?(::Io::Flow::V0::Models::OrderIdentifierPutForm) ? x : ::Io::Flow::V0::Models::OrderIdentifierPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/#{CGI.escape(identifier)}").with_json(order_identifier_put_form.to_json).put
            ::Io::Flow::V0::Models::OrderIdentifier.new(r)
          end

          def delete_by_identifier(organization, identifier)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/#{CGI.escape(identifier)}").delete
            nil
          end

        end

        class OrderNumberGenerators

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/order/number/generators").get
            ::Io::Flow::V0::Models::OrderNumberGenerator.from_json(r)
          end

          def put(organization, order_number_generator)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = order_number_generator; x.is_a?(::Io::Flow::V0::Models::OrderNumberGenerator) ? x : ::Io::Flow::V0::Models::OrderNumberGenerator.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/order/number/generators").with_json(order_number_generator.to_json).put
            ::Io::Flow::V0::Models::OrderNumberGenerator.from_json(r)
          end

          def delete(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/order/number/generators").delete
            nil
          end

        end

        class OrderPromotions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Deletes the order promotion with the specified key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/order/promotions/#{CGI.escape(key)}").delete
            nil
          end

        end

        class OrderSummaries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/order/summaries/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::OrderSummary.new(r)
          end

        end

        class Organizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # The countries resources provides a unique list of all of the countries for
          # which an experience exists. We generate this list of countries by iterating
          # through all of the experience regions, and collecting all of the countries.
          def get_countries_by_organization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :status => HttpClient::Preconditions.assert_class('status', (x = opts.delete(:status); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperienceStatus) ? x : ::Io::Flow::V0::Models::ExperienceStatus.apply(x)).value }
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/countries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

          # List of all destination countries available for this organization, including
          # countries within a world experience.
          def get_countries_and_destinations_by_organization(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/countries/destinations").get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

          # Search organizations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :environment => (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)).value),
              :parent => (x = opts.delete(:parent); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Organization.new(x) }
          end

          # Create a new organization.
          def post(organization_form)
            (x = organization_form; x.is_a?(::Io::Flow::V0::Models::OrganizationForm) ? x : ::Io::Flow::V0::Models::OrganizationForm.new(x))
            r = @client.request("/organizations").with_json(organization_form.to_json).post
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, Array).map { |v| HttpClient::Preconditions.assert_class('organization', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationVersion.new(x) }
          end

          # Returns information about a specific organization.
          def get_by_organization_id(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}").get
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Update or create an organization with the specified id.
          def put_by_organization_id(organization_id, organization_put_form)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            (x = organization_put_form; x.is_a?(::Io::Flow::V0::Models::OrganizationPutForm) ? x : ::Io::Flow::V0::Models::OrganizationPutForm.new(x))
            r = @client.request("/organizations/#{CGI.escape(organization_id)}").with_json(organization_put_form.to_json).put
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Delete the organization with this id
          def delete_by_organization_id(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}").delete
            nil
          end

          # Returns currencies for a specific organization.
          def get_settings_and_currencies_by_organization_id(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}/settings/currencies").get
            r.map { |x| ::Io::Flow::V0::Models::Currency.new(x) }
          end

          # Returns the region settings associated to a specific organization.
          def get_settings_and_regions_by_organization_id(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}/settings/regions").get
            r.map { |x| ::Io::Flow::V0::Models::RegionSetting.new(x) }
          end

          # Returns the list of enabled countries based on the region settings for a
          # specific organization
          def get_settings_and_regions_and_countries_and_available_by_organization_id(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}/settings/regions/countries/available").get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

          # Updates or creates a region setting for a specific organization
          def put_settings_and_regions_by_organization_id_and_region(organization_id, region, region_setting_form)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            HttpClient::Preconditions.assert_class('region', region, String)
            (x = region_setting_form; x.is_a?(::Io::Flow::V0::Models::RegionSettingForm) ? x : ::Io::Flow::V0::Models::RegionSettingForm.new(x))
            r = @client.request("/organizations/#{CGI.escape(organization_id)}/settings/regions/#{CGI.escape(region)}").with_json(region_setting_form.to_json).put
            ::Io::Flow::V0::Models::RegionSetting.new(r)
          end

          # Removes the setting for this region for a specific organization
          def delete_settings_and_regions_by_organization_id_and_region(organization_id, region)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            HttpClient::Preconditions.assert_class('region', region, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}/settings/regions/#{CGI.escape(region)}").delete
            nil
          end

        end

        class PaymentMethodRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_payment_method_rules(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, Array).map { |v| HttpClient::Preconditions.assert_class('country', v, String) }),
              :amount => (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "display_position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/payment-method-rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PaymentMethodRule.new(x) }
          end

          def get_payment_and_method_and_rules(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, Array).map { |v| HttpClient::Preconditions.assert_class('country', v, String) }),
              :amount => (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "display_position" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/payment/method/rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PaymentMethodRule.new(x) }
          end

        end

        class PriceBooks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/price/books").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PriceBook.new(x) }
          end

          # Create a price book.
          def post(organization, price_book_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = price_book_form; x.is_a?(::Io::Flow::V0::Models::PriceBookForm) ? x : ::Io::Flow::V0::Models::PriceBookForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/price/books").with_json(price_book_form.to_json).post
            ::Io::Flow::V0::Models::PriceBook.new(r)
          end

          # Returns information about a specific price book.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::PriceBook.new(r)
          end

          # Create or update a price book.
          def put_by_key(organization, key, price_book_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = price_book_form; x.is_a?(::Io::Flow::V0::Models::PriceBookForm) ? x : ::Io::Flow::V0::Models::PriceBookForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(key)}").with_json(price_book_form.to_json).put
            ::Io::Flow::V0::Models::PriceBook.new(r)
          end

          # Deletes the specified price book
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(key)}").delete
            nil
          end

        end

        class PriceBookItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, price_book_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('price_book_key', price_book_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(price_book_key)}/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PriceBookItem.new(x) }
          end

          # Create a price book item.
          def post(organization, price_book_key, price_book_item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('price_book_key', price_book_key, String)
            (x = price_book_item_form; x.is_a?(::Io::Flow::V0::Models::PriceBookItemForm) ? x : ::Io::Flow::V0::Models::PriceBookItemForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(price_book_key)}/items").with_json(price_book_item_form.to_json).post
            ::Io::Flow::V0::Models::PriceBookItem.new(r)
          end

          # Returns information about a specific price book item.
          def get_by_key(organization, price_book_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('price_book_key', price_book_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(price_book_key)}/items/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::PriceBookItem.new(r)
          end

          # Create or update a price book item.
          def put_by_key(organization, price_book_key, key, price_book_item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('price_book_key', price_book_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = price_book_item_form; x.is_a?(::Io::Flow::V0::Models::PriceBookItemForm) ? x : ::Io::Flow::V0::Models::PriceBookItemForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(price_book_key)}/items/#{CGI.escape(key)}").with_json(price_book_item_form.to_json).put
            ::Io::Flow::V0::Models::PriceBookItem.new(r)
          end

          # Deletes the specified price book item
          def delete_by_key(organization, price_book_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('price_book_key', price_book_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/price/books/#{CGI.escape(price_book_key)}/items/#{CGI.escape(key)}").delete
            nil
          end

        end

        class Subcatalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalogs. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Subcatalog.new(x) }
          end

          # Add subcatalog
          def post(organization, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = subcatalog_form; x.is_a?(::Io::Flow::V0::Models::SubcatalogForm) ? x : ::Io::Flow::V0::Models::SubcatalogForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_json(subcatalog_form.to_json).post
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

          # Returns information about a specific subcatalog.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Update subcatalog with the specified id, creating if it does not exist.
          def put_by_id(organization, id, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = subcatalog_form; x.is_a?(::Io::Flow::V0::Models::SubcatalogForm) ? x : ::Io::Flow::V0::Models::SubcatalogForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").with_json(subcatalog_form.to_json).put
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Delete the subcatalog with this id
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").delete
            nil
          end

          # Returns information about a specific subcatalog's settings.
          def get_settings_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").get
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Update subcatalog settings for the specified subcatalog.
          def put_settings_by_id(organization, id, subcatalog_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = subcatalog_settings_form; x.is_a?(::Io::Flow::V0::Models::SubcatalogSettingsForm) ? x : ::Io::Flow::V0::Models::SubcatalogSettingsForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").with_json(subcatalog_settings_form.to_json).put
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Search exclusions. Always paginated.
          def get_exclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific exclusion by catalog item number.
          def get_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add exclusion
          def put_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an exclusion with this catalog item number
          def delete_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Search inclusions. Always paginated.
          def get_inclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific inclusion by catalog item number.
          def get_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add inclusion
          def put_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an inclusion with this catalog item number
          def delete_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Search queries. Always paginated.
          def get_queries_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :type => (x = opts.delete(:type); x.nil? ? nil : HttpClient::Preconditions.assert_class('type', x, Array).map { |v| HttpClient::Preconditions.assert_class('type', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogQuery.new(x) }
          end

          # Add query
          def post_queries_by_subcatalog_id(organization, subcatalog_id, subcatalog_query_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            (x = subcatalog_query_form; x.is_a?(::Io::Flow::V0::Models::SubcatalogQueryForm) ? x : ::Io::Flow::V0::Models::SubcatalogQueryForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_json(subcatalog_query_form.to_json).post
            ::Io::Flow::V0::Models::SubcatalogQuery.new(r)
          end

          # Returns information about a specific query.
          def get_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::SubcatalogQuery.new(r)
          end

          # Delete a query with this id
          def delete_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").delete
            nil
          end

          # Get statistics for the specified subcatalog
          def get_statistics_by_subcatalog_id(organization, subcatalog_id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/statistics").get
            ::Io::Flow::V0::Models::SubcatalogStatistics.new(r)
          end

        end

        class SubcatalogItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalog items. Always paginated.
          def get(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :status => (x = opts.delete(:status); x.nil? ? nil : HttpClient::Preconditions.assert_class('status', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x)).value }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogItem.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogItemVersion.new(x) }
          end

          # Returns information about specific subcatalog items.
          def get_by_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::SubcatalogItem.new(r)
          end

        end

        class SubcatalogQueries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_validations(organization, values)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('strings', strings, Array).map { |v| HttpClient::Preconditions.assert_class('strings', v, String) }
            r = @client.request("/#{CGI.escape(organization)}/query/validations").with_json(strings.to_json).post
            ::Io::Flow::V0::Models::SubcatalogQueryValidation.new(r)
          end

        end

        class Targetings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Targeting.new(x) }
          end

          def post(organization, targeting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = targeting_form; x.is_a?(::Io::Flow::V0::Models::TargetingForm) ? x : ::Io::Flow::V0::Models::TargetingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings").with_json(targeting_form.to_json).post
            ::Io::Flow::V0::Models::Targeting.new(r)
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Targeting.new(r)
          end

          def put_by_key(organization, key, targeting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = targeting_form; x.is_a?(::Io::Flow::V0::Models::TargetingForm) ? x : ::Io::Flow::V0::Models::TargetingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings/#{CGI.escape(key)}").with_json(targeting_form.to_json).put
            ::Io::Flow::V0::Models::Targeting.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings/#{CGI.escape(key)}").delete
            nil
          end

        end

        class TargetingItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/targeting-items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TargetingItem.new(x) }
          end

        end

        class OrganizationCurrencySettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organization currency settings. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, String)),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/settings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(x) }
          end

          # Create organization currency settings.
          def post(organization, organization_currency_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = organization_currency_setting_form; x.is_a?(::Io::Flow::V0::Models::OrganizationCurrencySettingForm) ? x : ::Io::Flow::V0::Models::OrganizationCurrencySettingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/currency/settings").with_json(organization_currency_setting_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationCurrencySettingVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          # Update an existing organization currency setting by id.
          def put_by_id(organization, id, organization_currency_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = organization_currency_setting_form; x.is_a?(::Io::Flow::V0::Models::OrganizationCurrencySettingForm) ? x : ::Io::Flow::V0::Models::OrganizationCurrencySettingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/#{CGI.escape(id)}").with_json(organization_currency_setting_form.to_json).put
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          # Delete the organization currency setting with this id.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/#{CGI.escape(id)}").delete
            nil
          end

        end

        class Rates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organization currency conversion rates. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, Array).map { |v| HttpClient::Preconditions.assert_class('base', v, String) }),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :type => (x = (x = opts.delete(:type); x.nil? ? "organization" : x); x.is_a?(::Io::Flow::V0::Models::RateType) ? x : ::Io::Flow::V0::Models::RateType.apply(x)).value,
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/rates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Rate.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, String)),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :type => (x = (x = opts.delete(:type); x.nil? ? "organization" : x); x.is_a?(::Io::Flow::V0::Models::RateType) ? x : ::Io::Flow::V0::Models::RateType.apply(x)).value,
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/rates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RateVersion.new(x) }
          end

        end

        class HarmonizedCategories

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :parent_id => (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/categories").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedCategory.new(x) }
          end

        end

        class HarmonizedLandedCosts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Single operation that provides harmonization landed costs (i.e. duties and
          # taxes) for 1 or more items. This method is designed to enable a single call
          # from applications that need it (like checkout) to get all data for a
          # collection of items
          def post(organization, harmonized_landed_cost_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = harmonized_landed_cost_form; x.is_a?(::Io::Flow::V0::Models::HarmonizedLandedCostForm) ? x : ::Io::Flow::V0::Models::HarmonizedLandedCostForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/harmonization/landed-costs").with_json(harmonized_landed_cost_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedLandedCost.new(r)
          end

        end

        class Hs10

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs10_id => (x = opts.delete(:hs10_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs10_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs10_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10Version.new(x) }
          end

        end

        class TaxRegistrations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(organization, tax_registration_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = tax_registration_form; x.is_a?(::Io::Flow::V0::Models::TaxRegistrationForm) ? x : ::Io::Flow::V0::Models::TaxRegistrationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/tax/registrations").with_json(tax_registration_form.to_json).post
            ::Io::Flow::V0::Models::TaxRegistration.new(r)
          end

          def put_by_key(organization, key, tax_registration_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = tax_registration_form; x.is_a?(::Io::Flow::V0::Models::TaxRegistrationForm) ? x : ::Io::Flow::V0::Models::TaxRegistrationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/tax/registrations/#{CGI.escape(key)}").with_json(tax_registration_form.to_json).put
            ::Io::Flow::V0::Models::TaxRegistration.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/tax/registrations/#{CGI.escape(key)}").delete
            nil
          end

        end

        class Authorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Authorization.from_json(x) }
          end

          # Create a new authorization.
          def post(organization, authorization_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = authorization_form; x.is_a?(::Io::Flow::V0::Models::AuthorizationForm) ? x : ::Io::Flow::V0::Models::AuthorizationForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_query(query).with_json(authorization_form.to_json).post
            ::Io::Flow::V0::Models::Authorization.from_json(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('authorization_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AuthorizationVersion.new(x) }
          end

          # Returns information about a specific authorization.
          def get_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(key)}").with_query(query).get
            ::Io::Flow::V0::Models::Authorization.from_json(r)
          end

          # Attempts to create an authorization identified by the provided key. Multiple
          # requests using the same key are idempotent.
          def put_by_key(organization, key, authorization_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = authorization_form; x.is_a?(::Io::Flow::V0::Models::AuthorizationForm) ? x : ::Io::Flow::V0::Models::AuthorizationForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(key)}").with_query(query).with_json(authorization_form.to_json).put
            ::Io::Flow::V0::Models::Authorization.from_json(r)
          end

          # Deprecated. This end point no longer deletes an authorization and is
          # implemented by creating a reversal for the remaining balance on the auth.
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(key)}").delete
            nil
          end

        end

        class Captures

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :identifier => (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, String)),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_key => (x = opts.delete(:authorization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Capture.new(x) }
          end

          # Create a new capture.
          def post(organization, capture_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = capture_form; x.is_a?(::Io::Flow::V0::Models::CaptureForm) ? x : ::Io::Flow::V0::Models::CaptureForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/captures").with_json(capture_form.to_json).post
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('capture_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CaptureVersion.new(x) }
          end

          # Returns information about a specific capture.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          def get_identifiers_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :identifier => (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(key)}/identifiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CaptureIdentifier.new(x) }
          end

          # Create a new identifier for this capture
          def put_identifiers_by_key_and_identifier(organization, key, identifier, identifier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            (x = identifier_form; x.is_a?(::Io::Flow::V0::Models::IdentifierForm) ? x : ::Io::Flow::V0::Models::IdentifierForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(key)}/identifiers/#{CGI.escape(identifier)}").with_json(identifier_form.to_json).put
            ::Io::Flow::V0::Models::CaptureIdentifier.new(r)
          end

          def delete_identifiers_by_key_and_identifier(organization, key, identifier)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(key)}/identifiers/#{CGI.escape(identifier)}").delete
            nil
          end

        end

        class Cards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, Array).map { |v| HttpClient::Preconditions.assert_class('token', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Card.new(x) }
          end

          # Create a new card. Note that when using JSONP to submit a card, you do not
          # need to authenticate.
          def post(organization, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = card_form; x.is_a?(::Io::Flow::V0::Models::CardForm) ? x : ::Io::Flow::V0::Models::CardForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/cards").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Creates a card from a one time nonce. Each nonce can be used at most once
          # and you will receive a validation error if the nonce has already been
          # exchanged.
          def post_nonces(organization, card_nonce_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = card_nonce_form; x.is_a?(::Io::Flow::V0::Models::CardNonceForm) ? x : ::Io::Flow::V0::Models::CardNonceForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/cards/nonces").with_json(card_nonce_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :card_id => (x = opts.delete(:card_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('card_id', v, String) }),
              :card_token => (x = opts.delete(:card_token); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_token', x, Array).map { |v| HttpClient::Preconditions.assert_class('card_token', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CardVersion.new(x) }
          end

          # Returns information about a specific card.
          def get_by_token(organization, token)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('token', token, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(token)}").get
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Deletes the specified card
          def delete_by_token(organization, token)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('token', token, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(token)}").delete
            nil
          end

        end

        class CardPaymentSources

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :customer_number => (x = opts.delete(:customer_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('customer_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('customer_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/sources/payments/cards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CardPaymentSource.new(x) }
          end

          # Create a new card payment source.
          def post(organization, card_payment_source_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = card_payment_source_form; x.is_a?(::Io::Flow::V0::Models::CardPaymentSourceForm) ? x : ::Io::Flow::V0::Models::CardPaymentSourceForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/sources/payments/cards").with_json(card_payment_source_form.to_json).post
            ::Io::Flow::V0::Models::CardPaymentSource.new(r)
          end

          # Returns information about a specific card payment source.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/sources/payments/cards/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::CardPaymentSource.new(r)
          end

          # Update a card payment source.
          def put_by_id(organization, id, card_payment_source_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = card_payment_source_form; x.is_a?(::Io::Flow::V0::Models::CardPaymentSourceForm) ? x : ::Io::Flow::V0::Models::CardPaymentSourceForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/sources/payments/cards/#{CGI.escape(id)}").with_json(card_payment_source_form.to_json).put
            ::Io::Flow::V0::Models::CardPaymentSource.new(r)
          end

          # Deletes the specified card payment source
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/sources/payments/cards/#{CGI.escape(id)}").delete
            nil
          end

        end

        class GatewayAuthenticationData

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Specify authentication data for payment processor
          def post(organization, gateway_authentication_data_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = gateway_authentication_data_form; x.is_a?(::Io::Flow::V0::Models::GatewayAuthenticationDataForm) ? x : ::Io::Flow::V0::Models::GatewayAuthenticationDataForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/gateways/authentication").with_json(gateway_authentication_data_form.to_json).post
            ::Io::Flow::V0::Models::GatewayAuthenticationData.from_json(r)
          end

        end

        class Payments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :payment_method => (x = opts.delete(:payment_method); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment_method', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/payments").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Payment.from_json(x) }
          end

          # Create a new payment. Note that when using JSONP to submit a payment, you do
          # not need to authenticate.
          def post(organization, payment_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = payment_form; x.is_a?(::Io::Flow::V0::Models::PaymentForm) ? x : ::Io::Flow::V0::Models::PaymentForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/payments").with_json(payment_form.to_json).post
            ::Io::Flow::V0::Models::Payment.from_json(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :payment_id => (x = opts.delete(:payment_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('payment_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/payments/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PaymentVersion.new(x) }
          end

          # Returns information about a specific payment.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/payments/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Payment.from_json(r)
          end

          # Deletes the specified payment
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/payments/#{CGI.escape(id)}").delete
            nil
          end

        end

        class PublicKeys

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns your public keys
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/encryption/keys").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PublicKey.new(x) }
          end

          # Return the latest public key for an organization
          def get_latest(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/encryption/keys/latest").get
            ::Io::Flow::V0::Models::PublicKey.new(r)
          end

        end

        class Refunds

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :identifier => (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, String)),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_key => (x = opts.delete(:authorization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_key', x, String)),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, String)),
              :capture_key => (x = opts.delete(:capture_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Refund.new(x) }
          end

          # Create a new refund.
          def post(organization, refund_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = refund_form; x.is_a?(::Io::Flow::V0::Models::RefundForm) ? x : ::Io::Flow::V0::Models::RefundForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_json(refund_form.to_json).post
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Returns a refund order summary for the specified order.
          def get_summary_by_order_number(organization, order_number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('order_number', order_number, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/summary/#{CGI.escape(order_number)}").get
            ::Io::Flow::V0::Models::RefundOrderSummary.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :refund_id => (x = opts.delete(:refund_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('refund_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RefundVersion.new(x) }
          end

          # Returns information about a specific refund.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          def get_identifiers_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :identifier => (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(key)}/identifiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RefundIdentifier.new(x) }
          end

          # Create a new identifier for this refund
          def put_identifiers_by_key_and_identifier(organization, key, identifier, identifier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            (x = identifier_form; x.is_a?(::Io::Flow::V0::Models::IdentifierForm) ? x : ::Io::Flow::V0::Models::IdentifierForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(key)}/identifiers/#{CGI.escape(identifier)}").with_json(identifier_form.to_json).put
            ::Io::Flow::V0::Models::RefundIdentifier.new(r)
          end

          def delete_identifiers_by_key_and_identifier(organization, key, identifier)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('identifier', identifier, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(key)}/identifiers/#{CGI.escape(identifier)}").delete
            nil
          end

        end

        class Reversals

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_key => (x = opts.delete(:authorization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/reversals").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Reversal.new(x) }
          end

          def post(organization, reversal_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = reversal_form; x.is_a?(::Io::Flow::V0::Models::ReversalForm) ? x : ::Io::Flow::V0::Models::ReversalForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/reversals").with_json(reversal_form.to_json).post
            ::Io::Flow::V0::Models::Reversal.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :reversal_id => (x = opts.delete(:reversal_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('reversal_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('reversal_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/reversals/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ReversalVersion.new(x) }
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/reversals/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Reversal.new(r)
          end

          # Try inserting or updating a new reversal. Useful for retrying pending
          # reversals
          def put_by_key(organization, key, reversal_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = reversal_put_form; x.is_a?(::Io::Flow::V0::Models::ReversalPutForm) ? x : ::Io::Flow::V0::Models::ReversalPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/reversals/#{CGI.escape(key)}").with_json(reversal_put_form.to_json).put
            ::Io::Flow::V0::Models::Reversal.new(r)
          end

        end

        class VirtualCards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Retrieve all the virtual credit cards that have been created matching
          # selected criteria.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/virtual/cards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::VirtualCard.new(x) }
          end

          # Retrieves a virtual credit card using your unique key used when creating the
          # card. Note that the card number and cvv will not be returned by this request
          # to maintain PCI compliance. If you have lost these details you will need to
          # create a new card.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/virtual/cards/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::VirtualCard.new(r)
          end

          # Creates a new virtual credit card. The card number and cvv will only be
          # returned once when creating the card to maintain PCI compliance. This end
          # point is idempotent and subsequent calls with same key will return details
          # for the previously created card.
          def put_authorizations_by_key_and_authorization_key(organization, key, authorization_key, virtual_card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('authorization_key', authorization_key, String)
            (x = virtual_card_form; x.is_a?(::Io::Flow::V0::Models::VirtualCardForm) ? x : ::Io::Flow::V0::Models::VirtualCardForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/virtual/cards/#{CGI.escape(key)}/authorizations/#{CGI.escape(authorization_key)}").with_json(virtual_card_form.to_json).put
            ::Io::Flow::V0::Models::VirtualCard.new(r)
          end

        end

        class VirtualCardCaptures

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Retrieve all the virtual credit card captures that have been received for
          # all issued cards matching selected criteria.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/virtual/card/captures").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::VirtualCardCapture.new(x) }
          end

          # Retrieve payment captures for a specific virtual credit card that has been
          # previously issued.
          def get_by_virtual_card_id(organization, virtual_card_id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('virtual_card_id', virtual_card_id, String)
            r = @client.request("/#{CGI.escape(organization)}/virtual/card/captures/#{CGI.escape(virtual_card_id)}").get
            r.map { |x| ::Io::Flow::V0::Models::VirtualCardCapture.new(x) }
          end

        end

        class VirtualCardRefunds

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Retrieve all the virtual credit card refunds that have been received for all
          # issued cards matching selected criteria.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/virtual/card/refunds").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::VirtualCardRefund.new(x) }
          end

          # Retrieve payment refunds for a specific virtual credit card that has been
          # previously issued.
          def get_by_virtual_card_id(organization, virtual_card_id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('virtual_card_id', virtual_card_id, String)
            r = @client.request("/#{CGI.escape(organization)}/virtual/card/refunds/#{CGI.escape(virtual_card_id)}").get
            r.map { |x| ::Io::Flow::V0::Models::VirtualCardRefund.new(x) }
          end

        end

        class Centers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Center.new(x) }
          end

          def post(organization, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = center_form; x.is_a?(::Io::Flow::V0::Models::CenterForm) ? x : ::Io::Flow::V0::Models::CenterForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/centers").with_json(center_form.to_json).post
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def post_query(organization, center_query)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = center_query; x.is_a?(::Io::Flow::V0::Models::CenterQuery) ? x : ::Io::Flow::V0::Models::CenterQuery.new(x))
            r = @client.request("/#{CGI.escape(organization)}/centers/query").with_json(center_query.to_json).post
            r.map { |x| ::Io::Flow::V0::Models::Center.new(x) }
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CenterVersion.new(x) }
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def put_by_key(organization, key, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = center_form; x.is_a?(::Io::Flow::V0::Models::CenterForm) ? x : ::Io::Flow::V0::Models::CenterForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(key)}").with_json(center_form.to_json).put
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(key)}").delete
            nil
          end

        end

        class DeliveryWindows

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Endpoint to request a delivery window. Requires some knowledge of origin
          # (based on organization, center, or specified address string) and destination
          # (based on ip, lat/long, or address string). Other attributes allow us to
          # narrow down delivery windows even more such as service level to be used and
          # timestamp of expected shipment date.
          def get_summary(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :strategy => (x = (x = opts.delete(:strategy); x.nil? ? "range" : x); x.is_a?(::Io::Flow::V0::Models::Strategy) ? x : ::Io::Flow::V0::Models::Strategy.apply(x)).value,
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String)),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/delivery-windows/summary").with_query(query).get
            ::Io::Flow::V0::Models::DeliveryWindow.new(r)
          end

        end

        class DimensionEstimates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/dimension-estimates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::DimensionEstimate.new(x) }
          end

          def post(organization, dimension_estimate_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = dimension_estimate_form; x.is_a?(::Io::Flow::V0::Models::DimensionEstimateForm) ? x : ::Io::Flow::V0::Models::DimensionEstimateForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/dimension-estimates").with_json(dimension_estimate_form.to_json).post
            ::Io::Flow::V0::Models::DimensionEstimate.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/dimension-estimates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::DimensionEstimateVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/dimension-estimates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::DimensionEstimate.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/dimension-estimates/#{CGI.escape(id)}").delete
            nil
          end

        end

        class InventoryRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRule.new(x) }
          end

          def post(organization, inventory_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = inventory_rule_form; x.is_a?(::Io::Flow::V0::Models::InventoryRuleForm) ? x : ::Io::Flow::V0::Models::InventoryRuleForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_json(inventory_rule_form.to_json).post
            ::Io::Flow::V0::Models::InventoryRule.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRuleVersion.new(x) }
          end

        end

        class InventorySnapshots

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshot.new(x) }
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_snapshot => (x = opts.delete(:inventory_snapshot); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_snapshot', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_snapshot', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshotVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventorySnapshot.new(r)
          end

        end

        class InventoryUpdates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdate.new(x) }
          end

          def post(organization, inventory_update_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = inventory_update_form; x.is_a?(::Io::Flow::V0::Models::InventoryUpdateForm) ? x : ::Io::Flow::V0::Models::InventoryUpdateForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_json(inventory_update_form.to_json).post
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_update => (x = opts.delete(:inventory_update); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_update', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_update', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdateVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

        end

        class Manifests

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier_tracking_number => (x = opts.delete(:carrier_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_tracking_number', v, String) }),
              :flow_tracking_number => (x = opts.delete(:flow_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('flow_tracking_number', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/manifests").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Manifest.new(x) }
          end

          # Creates a new manifest/carrier BOL with specific tracking numbers
          def post(organization, manifest_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = manifest_form; x.is_a?(::Io::Flow::V0::Models::ManifestForm) ? x : ::Io::Flow::V0::Models::ManifestForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/manifests").with_json(manifest_form.to_json).post
            ::Io::Flow::V0::Models::Manifest.new(r)
          end

          # Generates a new manifest with all outstanding labels and redirects to a
          # downloadable PDF of carrier-generated manifest or bill of lading (BOL). If
          # no outstanding labels, this will generate a 422 error.
          def get_services_and_outstanding_by_service(organization, service)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('service', service, String)
            r = @client.request("/#{CGI.escape(organization)}/manifests/services/#{CGI.escape(service)}/outstanding").get
            r
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/manifests/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Manifest.new(r)
          end

        end

        class Quotes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search quotes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Quote.new(x) }
          end

          def post(organization, quote_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = quote_form; x.is_a?(::Io::Flow::V0::Models::QuoteForm) ? x : ::Io::Flow::V0::Models::QuoteForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_json(quote_form.to_json).post
            ::Io::Flow::V0::Models::Quote.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/quotes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Quote.new(r)
          end

        end

        class Ratecards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Ratecard.new(x) }
          end

          def post(organization, ratecard_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = ratecard_form; x.is_a?(::Io::Flow::V0::Models::RatecardForm) ? x : ::Io::Flow::V0::Models::RatecardForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ratecards").with_json(ratecard_form.to_json).post
            ::Io::Flow::V0::Models::Ratecard.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Ratecard.new(r)
          end

          def put_publish_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(id)}/publish").put
            ::Io::Flow::V0::Models::Ratecard.new(r)
          end

        end

        class RatecardEstimates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Endpoint to get shipment cost estimates based on applicable rate cards. An
          # origin and destination address must be provided. Final amounts are based on
          # either gravitational weight or dimensional weight. When estimating based off
          # gravitational weight, the weight field must be set. When estimating based
          # off dimensional weight, then length/width/depth must be set. For either one,
          # the appropriate unit of measurement must be given.
          def post(organization, ratecard_estimate_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = ratecard_estimate_form; x.is_a?(::Io::Flow::V0::Models::RatecardEstimateForm) ? x : ::Io::Flow::V0::Models::RatecardEstimateForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/ratecard_estimates").with_json(ratecard_estimate_form.to_json).post
            r.map { |x| ::Io::Flow::V0::Models::RatecardEstimate.from_json(x) }
          end

          # Endpoint to get a summary of the shipment estimates based on applicable rate
          # cards. An origin and destination country must be provided.
          def post_summaries(organization, ratecard_estimate_summary_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = ratecard_estimate_summary_form; x.is_a?(::Io::Flow::V0::Models::RatecardEstimateSummaryForm) ? x : ::Io::Flow::V0::Models::RatecardEstimateSummaryForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ratecard_estimates/summaries").with_json(ratecard_estimate_summary_form.to_json).post
            r.map { |x| ::Io::Flow::V0::Models::RatecardEstimate.from_json(x) }
          end

        end

        class RatecardLanes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :delivered_duty => (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)).value),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :ratecard_id => (x = opts.delete(:ratecard_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('ratecard_id', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecard-lanes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardLane.new(x) }
          end

          def post(organization, ratecard_lane_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = ratecard_lane_form; x.is_a?(::Io::Flow::V0::Models::RatecardLaneForm) ? x : ::Io::Flow::V0::Models::RatecardLaneForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ratecard-lanes").with_json(ratecard_lane_form.to_json).post
            ::Io::Flow::V0::Models::RatecardLane.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecard-lanes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::RatecardLane.new(r)
          end

          def put_by_id(organization, id, ratecard_lane_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = ratecard_lane_form; x.is_a?(::Io::Flow::V0::Models::RatecardLaneForm) ? x : ::Io::Flow::V0::Models::RatecardLaneForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ratecard-lanes/#{CGI.escape(id)}").with_json(ratecard_lane_form.to_json).put
            ::Io::Flow::V0::Models::RatecardLane.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecard-lanes/#{CGI.escape(id)}").delete
            nil
          end

        end

        class RatecardRates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, ratecard_id, lane_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :weight => (x = opts.delete(:weight); x.nil? ? nil : HttpClient::Preconditions.assert_class('weight', x, Array).map { |v| HttpClient::Preconditions.assert_class('weight', v, Numeric) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardRate.new(x) }
          end

          def post(organization, ratecard_id, lane_id, ratecard_rate_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            (x = ratecard_rate_form; x.is_a?(::Io::Flow::V0::Models::RatecardRateForm) ? x : ::Io::Flow::V0::Models::RatecardRateForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates").with_json(ratecard_rate_form.to_json).post
            ::Io::Flow::V0::Models::RatecardRate.new(r)
          end

          def get_versions(organization, ratecard_id, lane_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardRateVersion.new(x) }
          end

          def get_by_id(organization, ratecard_id, lane_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::RatecardRate.new(r)
          end

          def put_by_id(organization, ratecard_id, lane_id, id, ratecard_lane_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = ratecard_lane_form; x.is_a?(::Io::Flow::V0::Models::RatecardLaneForm) ? x : ::Io::Flow::V0::Models::RatecardLaneForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates/#{CGI.escape(id)}").with_json(ratecard_lane_form.to_json).put
            ::Io::Flow::V0::Models::RatecardRate.new(r)
          end

        end

        class Returns

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :flow_tracking_number => (x = opts.delete(:flow_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('flow_tracking_number', v, String) }),
              :carrier_tracking_number => (x = opts.delete(:carrier_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_tracking_number', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/returns").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Return.new(x) }
          end

          def post(organization, return_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = return_form; x.is_a?(::Io::Flow::V0::Models::ReturnForm) ? x : ::Io::Flow::V0::Models::ReturnForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/returns").with_json(return_form.to_json).post
            ::Io::Flow::V0::Models::Return.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/returns/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ReturnVersion.new(x) }
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/returns/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Return.new(r)
          end

          def put_by_key(organization, key, return_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = return_form; x.is_a?(::Io::Flow::V0::Models::ReturnForm) ? x : ::Io::Flow::V0::Models::ReturnForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/returns/#{CGI.escape(key)}").with_json(return_form.to_json).put
            ::Io::Flow::V0::Models::Return.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/returns/#{CGI.escape(key)}").delete
            nil
          end

        end

        class Serials

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :status => (x = opts.delete(:status); x.nil? ? nil : HttpClient::Preconditions.assert_class('status', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SerialStatus) ? x : ::Io::Flow::V0::Models::SerialStatus.apply(x)).value }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory/serials").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Serial.new(x) }
          end

          def post(organization, serial_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = serial_form; x.is_a?(::Io::Flow::V0::Models::SerialForm) ? x : ::Io::Flow::V0::Models::SerialForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/inventory/serials").with_json(serial_form.to_json).post
            ::Io::Flow::V0::Models::Serial.new(r)
          end

          def get_prices_by_aggregate(organization, aggregate, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = aggregate; x.is_a?(::Io::Flow::V0::Models::Aggregate) ? x : ::Io::Flow::V0::Models::Aggregate.apply(x))
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :item_number => HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory/serials/prices/#{aggregate.value}").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Serial.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory/serials/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SerialVersion.new(x) }
          end

          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory/serials/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Serial.new(r)
          end

          def put_by_number(organization, number, serial_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = serial_form; x.is_a?(::Io::Flow::V0::Models::SerialForm) ? x : ::Io::Flow::V0::Models::SerialForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/inventory/serials/#{CGI.escape(number)}").with_json(serial_form.to_json).put
            ::Io::Flow::V0::Models::Serial.new(r)
          end

          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory/serials/#{CGI.escape(number)}").delete
            nil
          end

        end

        class ShippingConfigurations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingConfiguration.new(x) }
          end

          def post(organization, shipping_configuration_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = shipping_configuration_form; x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationForm) ? x : ::Io::Flow::V0::Models::ShippingConfigurationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration").with_json(shipping_configuration_form.to_json).post
            ::Io::Flow::V0::Models::ShippingConfiguration.new(r)
          end

          def get_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}").with_query(query).get
            ::Io::Flow::V0::Models::ShippingConfiguration.new(r)
          end

          def put_by_key(organization, key, shipping_configuration_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = shipping_configuration_form; x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationForm) ? x : ::Io::Flow::V0::Models::ShippingConfigurationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}").with_query(query).with_json(shipping_configuration_form.to_json).put
            ::Io::Flow::V0::Models::ShippingConfiguration.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}").delete
            nil
          end

          def get_lanes_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :region => (x = opts.delete(:region); x.nil? ? nil : HttpClient::Preconditions.assert_class('region', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}/lanes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingLane.new(x) }
          end

          def post_lanes_by_key(organization, key, shipping_lane_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = shipping_lane_form; x.is_a?(::Io::Flow::V0::Models::ShippingLaneForm) ? x : ::Io::Flow::V0::Models::ShippingLaneForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}/lanes").with_query(query).with_json(shipping_lane_form.to_json).post
            ::Io::Flow::V0::Models::ShippingLane.new(r)
          end

          def get_lanes_by_key_and_id(organization, key, id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}/lanes/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::ShippingLane.new(r)
          end

          def put_lanes_by_key_and_id(organization, key, id, shipping_lane_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = shipping_lane_form; x.is_a?(::Io::Flow::V0::Models::ShippingLaneForm) ? x : ::Io::Flow::V0::Models::ShippingLaneForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}/lanes/#{CGI.escape(id)}").with_query(query).with_json(shipping_lane_form.to_json).put
            ::Io::Flow::V0::Models::ShippingLane.new(r)
          end

          def delete_lanes_by_key_and_id(organization, key, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}/lanes/#{CGI.escape(id)}").delete
            nil
          end

          # Endpoint to retrieve the default tier of a shipping lane
          def get_lanes_and_defaults_and_tiers_by_key_and_id(organization, key, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}/lanes/#{CGI.escape(id)}/defaults/tiers").get
            ::Io::Flow::V0::Models::ShippingLaneDefaultTier.new(r)
          end

          # Endpoint to set or udpate the default tier of a shipping lane
          def put_lanes_and_defaults_and_tiers_by_key_and_id(organization, key, id, shipping_lane_default_tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = shipping_lane_default_tier_form; x.is_a?(::Io::Flow::V0::Models::ShippingLaneDefaultTierForm) ? x : ::Io::Flow::V0::Models::ShippingLaneDefaultTierForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/#{CGI.escape(key)}/lanes/#{CGI.escape(id)}/defaults/tiers").with_json(shipping_lane_default_tier_form.to_json).put
            ::Io::Flow::V0::Models::ShippingLaneDefaultTier.new(r)
          end

        end

        class ShippingConfigurationCopies

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_key(organization, key, shipping_configuration_copy_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = shipping_configuration_copy_form; x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationCopyForm) ? x : ::Io::Flow::V0::Models::ShippingConfigurationCopyForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping/configuration/copies/#{CGI.escape(key)}").with_json(shipping_configuration_copy_form.to_json).post
            ::Io::Flow::V0::Models::ShippingConfigurationCopy.new(r)
          end

        end

        class ShippingLabels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier_tracking_number => (x = opts.delete(:carrier_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_tracking_number', v, String) }),
              :flow_tracking_number => (x = opts.delete(:flow_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('flow_tracking_number', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :show_commercial_invoice => (x = opts.delete(:show_commercial_invoice); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('show_commercial_invoice', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingLabel.new(x) }
          end

          def post(organization, shipping_label_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :show_commercial_invoice => (x = opts.delete(:show_commercial_invoice); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('show_commercial_invoice', x))
            }.delete_if { |k, v| v.nil? }
            (x = shipping_label_form; x.is_a?(::Io::Flow::V0::Models::ShippingLabelForm) ? x : ::Io::Flow::V0::Models::ShippingLabelForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels").with_query(query).with_json(shipping_label_form.to_json).post
            ::Io::Flow::V0::Models::ShippingLabel.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :label => (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, Array).map { |v| HttpClient::Preconditions.assert_class('label', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingLabelVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ShippingLabel.new(r)
          end

        end

        class ShippingNotifications

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :carrier_tracking_number => (x = opts.delete(:carrier_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_tracking_number', v, String) }),
              :flow_tracking_number => (x = opts.delete(:flow_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('flow_tracking_number', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingNotification.new(x) }
          end

          def post(organization, shipping_notification_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = shipping_notification_form; x.is_a?(::Io::Flow::V0::Models::ShippingNotificationForm) ? x : ::Io::Flow::V0::Models::ShippingNotificationForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications").with_json(shipping_notification_form.to_json).post
            ::Io::Flow::V0::Models::ShippingNotification.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingNotificationVersion.new(x) }
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ShippingNotification.new(r)
          end

          def put_by_key(organization, key, detailed_shipping_notification_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = detailed_shipping_notification_form; x.is_a?(::Io::Flow::V0::Models::DetailedShippingNotificationForm) ? x : ::Io::Flow::V0::Models::DetailedShippingNotificationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/#{CGI.escape(key)}").with_json(detailed_shipping_notification_form.to_json).put
            ::Io::Flow::V0::Models::ShippingNotification.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/#{CGI.escape(key)}").delete
            nil
          end

        end

        class SurchargeSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_displays(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/surcharge/settings/displays").get
            r.map { |x| ::Io::Flow::V0::Models::SurchargeSettingDisplay.new(x) }
          end

        end

        class Tiers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :direction => (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LaneDirection) ? x : ::Io::Flow::V0::Models::LaneDirection.apply(x)).value),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tier.new(x) }
          end

          def post(organization, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = tier_form; x.is_a?(::Io::Flow::V0::Models::TierForm) ? x : ::Io::Flow::V0::Models::TierForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_json(tier_form.to_json).post
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def put_by_id(organization, id, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = tier_form; x.is_a?(::Io::Flow::V0::Models::TierForm) ? x : ::Io::Flow::V0::Models::TierForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").with_json(tier_form.to_json).put
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").delete
            nil
          end

        end

        class Trackings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Public endpoint to get all relevant information about a tracking, label(s)
          # under it, and event(s) under those label(s)
          def get_trackings_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/trackings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_trackings_by_organization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tracking.new(x) }
          end

          def post_trackings_by_organization(organization, tracking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = tracking_form; x.is_a?(::Io::Flow::V0::Models::TrackingForm) ? x : ::Io::Flow::V0::Models::TrackingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_json(tracking_form.to_json).post
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_trackings_and_versions_by_organization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingVersion.new(x) }
          end

        end

        class TrackingEvents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :tracking_label_id => (x = opts.delete(:tracking_label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-events").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingEvent.new(x) }
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_event_id => (x = opts.delete(:tracking_event_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_event_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_event_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-events/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingEventVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tracking-events/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TrackingEvent.new(r)
          end

        end

        class TrackingLabels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingLabel.new(x) }
          end

          def post(organization, tracking_label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = tracking_label_form; x.is_a?(::Io::Flow::V0::Models::TrackingLabelForm) ? x : ::Io::Flow::V0::Models::TrackingLabelForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels").with_json(tracking_label_form.to_json).post
            ::Io::Flow::V0::Models::TrackingLabel.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_label_id => (x = opts.delete(:tracking_label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingLabelVersion.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TrackingLabel.new(r)
          end

        end

        class Webhooks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns webhooks for an organization
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/webhooks").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Webhook.new(x) }
          end

          # Create a new webhook
          def post(organization, webhook_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = webhook_form; x.is_a?(::Io::Flow::V0::Models::WebhookForm) ? x : ::Io::Flow::V0::Models::WebhookForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/webhooks").with_json(webhook_form.to_json).post
            ::Io::Flow::V0::Models::Webhook.new(r)
          end

          # Returns information about a specific webhook
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/webhooks/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Webhook.new(r)
          end

          # Update an existing webhook
          def put_by_id(organization, id, webhook_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = webhook_form; x.is_a?(::Io::Flow::V0::Models::WebhookForm) ? x : ::Io::Flow::V0::Models::WebhookForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/webhooks/#{CGI.escape(id)}").with_json(webhook_form.to_json).put
            ::Io::Flow::V0::Models::Webhook.new(r)
          end

          # Delete a webhook with the specified id
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/webhooks/#{CGI.escape(id)}").delete
            nil
          end

        end

        class WebhookDeliveries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns deliveries for an organization's webhook
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :webhook_id => (x = opts.delete(:webhook_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('webhook_id', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/webhook/deliveries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::WebhookDelivery.new(x) }
          end

          # Returns information about a specific webhook delivery
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/webhook/deliveries/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::WebhookDelivery.new(r)
          end

          # Redeliver a webhook request. This created a new webhook request to requeue
          # delivery
          def post_requests_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/webhook/deliveries/#{CGI.escape(id)}/requests").post
            ::Io::Flow::V0::Models::WebhookRequest.new(r)
          end

        end

        class WebhookSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns the webhook settings for an organization
          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/webhook/settings").get
            ::Io::Flow::V0::Models::WebhookSettings.new(r)
          end

          # Updates the webhook settings for an organization
          def put(organization, webhook_settings)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = webhook_settings; x.is_a?(::Io::Flow::V0::Models::WebhookSettings) ? x : ::Io::Flow::V0::Models::WebhookSettings.new(x))
            r = @client.request("/#{CGI.escape(organization)}/webhook/settings").with_json(webhook_settings.to_json).put
            ::Io::Flow::V0::Models::WebhookSettings.new(r)
          end

        end

        class Addresses

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Geolocates the request based on the provided parameters, returning a list of
          # potential matching addresses.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/addresses").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Address.new(x) }
          end

          def post_verifications(address)
            (x = address; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            r = @client.request("/addresses/verifications").with_json(address.to_json).post
            ::Io::Flow::V0::Models::AddressVerification.new(r)
          end

        end

        class CountryDefaults

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/geolocation/defaults").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CountryDefaults.new(x) }
          end

          def get_by_country(country)
            HttpClient::Preconditions.assert_class('country', country, String)
            r = @client.request("/geolocation/defaults/#{CGI.escape(country)}").get
            ::Io::Flow::V0::Models::CountryDefaults.new(r)
          end

        end

        class Timezones

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Provides timezone based on address or geolocated IP.
          def get_geolocation_and_timezones(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/geolocation/timezones").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Timezone.new(x) }
          end

          # Returns a list of timezones.
          def get_reference_and_timezones(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/timezones").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Timezone.new(x) }
          end

        end

        class Carriers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of carriers supported by Flow.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/carriers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Carrier.new(x) }
          end

        end

        class CarrierServices

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of carrier services supported by Flow.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/carrier/services").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierService.new(x) }
          end

        end

        class Countries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of countries.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/countries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

        end

        class Currencies

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of currencies.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/currencies").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Currency.new(x) }
          end

        end

        class Languages

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of languages.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/languages").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Language.new(x) }
          end

        end

        class Locales

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of locales.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/locales").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Locale.new(x) }
          end

          # Returns the locale with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/locales/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Locale.new(r)
          end

        end

        class PaymentMethods

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of payment methods supported by Flow.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/payment/methods").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PaymentMethod.new(x) }
          end

        end

        class Provinces

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of provinces.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :countries => (x = opts.delete(:countries); x.nil? ? nil : HttpClient::Preconditions.assert_class('countries', x, Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/provinces").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Province.new(x) }
          end

          # Returns the province with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/provinces/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Province.new(r)
          end

        end

        class Regions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of regions.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/regions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Region.new(x) }
          end

          # Returns the region with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/regions/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Region.new(r)
          end

        end

        class B2bCreditMemos

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/b2b/credit/memos").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::B2bCreditMemo.new(x) }
          end

        end

        class B2bInvoices

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/b2b/invoices").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::B2bInvoice.new(x) }
          end

          # Creates an export of the b2b invoices
          def post_exports(organization, invoice_export_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = invoice_export_form; x.is_a?(::Io::Flow::V0::Models::InvoiceExportForm) ? x : ::Io::Flow::V0::Models::InvoiceExportForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/b2b/invoices/exports").with_json(invoice_export_form.to_json).post
            ::Io::Flow::V0::Models::InvoiceExport.new(r)
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/b2b/invoices/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::B2bInvoice.new(r)
          end

        end

        class CatalogPriceBookItemDocuments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns price book item documents based on the search criteria
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :price_book_key => (x = opts.delete(:price_book_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('price_book_key', x, Array).map { |v| HttpClient::Preconditions.assert_class('price_book_key', v, String) }),
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/price/books/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CatalogPriceBookItemDocument.new(x) }
          end

        end

        class CheckoutTokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_checkout_and_tokens_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/checkout/tokens/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::CheckoutToken.new(r)
          end

          def delete_checkout_and_tokens_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/checkout/tokens/#{CGI.escape(id)}").delete
            nil
          end

          def post_checkout_and_tokens_by_organization(organization, checkout_token_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = checkout_token_form; x.is_a?(::Io::Flow::V0::Models::CheckoutTokenForm) ? x : ::Io::Flow::V0::Models::CheckoutTokenForm.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/checkout/tokens").with_json(checkout_token_form.to_json).post
            ::Io::Flow::V0::Models::CheckoutToken.new(r)
          end

        end

        class ConsumerInvoices

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ConsumerInvoice.new(x) }
          end

          # Creates an export of the consumer/invoices
          def post_exports(organization, invoice_export_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = invoice_export_form; x.is_a?(::Io::Flow::V0::Models::InvoiceExportForm) ? x : ::Io::Flow::V0::Models::InvoiceExportForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/exports").with_json(invoice_export_form.to_json).post
            ::Io::Flow::V0::Models::InvoiceExport.new(r)
          end

          def put_order_by_number(organization, number, consumer_invoice_form_by_order)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = consumer_invoice_form_by_order; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceFormByOrder) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceFormByOrder.new(x))
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/order/#{CGI.escape(number)}").with_json(consumer_invoice_form_by_order.to_json).put
            r.map { |x| ::Io::Flow::V0::Models::ConsumerInvoice.new(x) }
          end

          # Creates a credit memo against this invoice
          def post_credit_and_memos_by_invoice_key(organization, invoice_key, credit_memo_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('invoice_key', invoice_key, String)
            (x = credit_memo_form; x.is_a?(::Io::Flow::V0::Models::CreditMemoForm) ? x : ::Io::Flow::V0::Models::CreditMemoForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/#{CGI.escape(invoice_key)}/credit/memos").with_json(credit_memo_form.to_json).post
            ::Io::Flow::V0::Models::CreditMemo.new(r)
          end

          # Upserts a credit memo against this invoice
          def put_credit_and_memos_by_invoice_key_and_key(organization, invoice_key, key, credit_memo_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('invoice_key', invoice_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = credit_memo_form; x.is_a?(::Io::Flow::V0::Models::CreditMemoForm) ? x : ::Io::Flow::V0::Models::CreditMemoForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/#{CGI.escape(invoice_key)}/credit/memos/#{CGI.escape(key)}").with_json(credit_memo_form.to_json).put
            ::Io::Flow::V0::Models::CreditMemo.new(r)
          end

          def delete_credit_and_memos_by_invoice_key_and_key(organization, invoice_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('invoice_key', invoice_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/#{CGI.escape(invoice_key)}/credit/memos/#{CGI.escape(key)}").delete
            nil
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ConsumerInvoice.new(r)
          end

          def put_by_key(organization, key, consumer_invoice_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            (x = consumer_invoice_form; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceForm) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/#{CGI.escape(key)}").with_json(consumer_invoice_form.to_json).put
            ::Io::Flow::V0::Models::ConsumerInvoice.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/consumer/invoices/#{CGI.escape(key)}").delete
            nil
          end

        end

        class ConsumerInvoiceDocuments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_tokens_and_type_by_token_and_type(token, type, incoming={})
            HttpClient::Preconditions.assert_class('token', token, String)
            (x = type; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceDocumentType) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceDocumentType.apply(x))
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/consumer/invoice/document/tokens/#{CGI.escape(token)}/type/#{type.value}").with_query(query).get
            ::Io::Flow::V0::Models::ConsumerInvoiceDocument.new(r)
          end

        end

        class CreditMemos

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/credit/memos").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CreditMemo.new(x) }
          end

        end

        class Customers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search customers. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, Array).map { |v| HttpClient::Preconditions.assert_class('email', v, String) }),
              :phone => (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, Array).map { |v| HttpClient::Preconditions.assert_class('phone', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/customers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Customer.new(x) }
          end

          # Create a customer.
          def post(organization, customer_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = customer_form; x.is_a?(::Io::Flow::V0::Models::CustomerForm) ? x : ::Io::Flow::V0::Models::CustomerForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/customers").with_json(customer_form.to_json).post
            ::Io::Flow::V0::Models::Customer.new(r)
          end

          # Returns information about a specific customer.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Customer.new(r)
          end

          # Update or create a customer with the specified number.
          def put_by_number(organization, number, customer_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = customer_put_form; x.is_a?(::Io::Flow::V0::Models::CustomerPutForm) ? x : ::Io::Flow::V0::Models::CustomerPutForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}").with_json(customer_put_form.to_json).put
            ::Io::Flow::V0::Models::Customer.new(r)
          end

          # Delete the customer with this number.
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}").delete
            nil
          end

        end

        class CustomerAddressBook

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Retrieve customer addrress book.
          def get(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}/addresses/book").get
            ::Io::Flow::V0::Models::CustomerAddressBook.new(r)
          end

        end

        class CustomerAddressBookContacts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search contacts. Always paginated.
          def get(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, Array).map { |v| HttpClient::Preconditions.assert_class('email', v, String) }),
              :phone => (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, Array).map { |v| HttpClient::Preconditions.assert_class('phone', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}/addresses/book/contacts").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CustomerAddressBookContact.new(x) }
          end

          # Create a contact.
          def post(organization, number, customer_address_book_contact_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = customer_address_book_contact_form; x.is_a?(::Io::Flow::V0::Models::CustomerAddressBookContactForm) ? x : ::Io::Flow::V0::Models::CustomerAddressBookContactForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}/addresses/book/contacts").with_json(customer_address_book_contact_form.to_json).post
            ::Io::Flow::V0::Models::CustomerAddressBookContact.new(r)
          end

          # Returns information about a specific contact.
          def get_by_id(organization, number, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}/addresses/book/contacts/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::CustomerAddressBookContact.new(r)
          end

          # Update or create a contact with the specified id.
          def put_by_id(organization, number, id, customer_address_book_contact_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = customer_address_book_contact_form; x.is_a?(::Io::Flow::V0::Models::CustomerAddressBookContactForm) ? x : ::Io::Flow::V0::Models::CustomerAddressBookContactForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}/addresses/book/contacts/#{CGI.escape(id)}").with_json(customer_address_book_contact_form.to_json).put
            ::Io::Flow::V0::Models::CustomerAddressBookContact.new(r)
          end

          # Delete the contact with this id.
          def delete_by_id(organization, number, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}/addresses/book/contacts/#{CGI.escape(id)}").delete
            nil
          end

        end

        class CustomerBundles

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns information about a specific customer.
          def get_bundle_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/customers/#{CGI.escape(number)}/bundle").get
            ::Io::Flow::V0::Models::CustomerBundle.new(r)
          end

        end

        class CustomerTokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search tokens.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :customer_number => (x = opts.delete(:customer_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('customer_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/customer/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CustomerToken.new(x) }
          end

          # If there exists at least one token for this customer number, returns the
          # latest. Otherwise creates a new token and returns that
          def post_latest_by_customer_number(organization, customer_number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('customer_number', customer_number, String)
            r = @client.request("/#{CGI.escape(organization)}/customer/tokens/latest/#{CGI.escape(customer_number)}").post
            ::Io::Flow::V0::Models::CustomerToken.new(r)
          end

          # Delete the token for this id.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/customer/tokens/#{CGI.escape(id)}").delete
            nil
          end

          # Returns a token if it exists.
          def get_by_token(organization, token)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('token', token, String)
            r = @client.request("/#{CGI.escape(organization)}/customer/tokens/#{CGI.escape(token)}").get
            ::Io::Flow::V0::Models::CustomerToken.new(r)
          end

        end

        class Documents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns items based on search criteria
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CatalogItemDocument.new(x) }
          end

          # Returns harmonization information based on search criteria
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizationDocument.new(x) }
          end

        end

        class EcommercePlatforms

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}/ecommerce/platform").get
            ::Io::Flow::V0::Models::EcommercePlatform.new(r)
          end

        end

        class EmailVerifications

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_token(token)
            HttpClient::Preconditions.assert_class('token', token, String)
            r = @client.request("/users/emails/verifications/#{CGI.escape(token)}").post
            ::Io::Flow::V0::Models::EmailVerification.new(r)
          end

        end

        class ExclusionRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of exclusions rules.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/exclusion/rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExclusionRule.new(x) }
          end

          def post(organization, exclusion_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = exclusion_rule_form; x.is_a?(::Io::Flow::V0::Models::ExclusionRuleForm) ? x : ::Io::Flow::V0::Models::ExclusionRuleForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/exclusion/rules").with_json(exclusion_rule_form.to_json).post
            ::Io::Flow::V0::Models::ExclusionRule.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :exclusion_rule_id => (x = opts.delete(:exclusion_rule_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('exclusion_rule_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('exclusion_rule_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/exclusion/rules/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExclusionRuleVersion.new(x) }
          end

          # Updates the specified exclusion rule.
          def put_by_id(organization, id, exclusion_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = exclusion_rule_form; x.is_a?(::Io::Flow::V0::Models::ExclusionRuleForm) ? x : ::Io::Flow::V0::Models::ExclusionRuleForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/exclusion/rules/#{CGI.escape(id)}").with_json(exclusion_rule_form.to_json).put
            ::Io::Flow::V0::Models::ExclusionRule.new(r)
          end

          # Marks the exclusion rule deleted. Once updated, the rule itself will be
          # deleted.
          def put_deletion_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/exclusion/rules/#{CGI.escape(id)}/deletion").put
            ::Io::Flow::V0::Models::ExclusionRule.new(r)
          end

        end

        class Exports

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search exports. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :created_by_user_id => (x = opts.delete(:created_by_user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_by_user_id', x, String)),
              :discriminator => (x = opts.delete(:discriminator); x.nil? ? nil : HttpClient::Preconditions.assert_class('discriminator', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/exports").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Export.new(x) }
          end

          # Create an export.
          def post(organization, export_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = export_form; x.is_a?(::Io::Flow::V0::Models::ExportForm) ? x : ::Io::Flow::V0::Models::ExportForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/exports").with_json(export_form.to_json).post
            ::Io::Flow::V0::Models::Export.new(r)
          end

          # Provides visibility into recent changes of each export, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :export_id => (x = opts.delete(:export_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('export_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('export_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/exports/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExportVersion.new(x) }
          end

          # Get a single export.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/exports/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Export.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/exports/#{CGI.escape(id)}").delete
            nil
          end

        end

        class FlowRoles

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # List roles in use by this organization.
          def get_organization_and_roles_by_organization(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/permission/organization/#{CGI.escape(organization)}/roles").get
            r.map { |x| ::Io::Flow::V0::Models::FlowRole.from_json(x) }
          end

        end

        class FraudEmailRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Retrieve fraud review email rules. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :decision => (x = opts.delete(:decision); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::FraudEmailRuleDecision) ? x : ::Io::Flow::V0::Models::FraudEmailRuleDecision.apply(x)).value),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "decision" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/fraud/email/rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::FraudEmailRule.new(x) }
          end

          # Add an email decision rule.
          def post(organization, fraud_email_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = fraud_email_rule_form; x.is_a?(::Io::Flow::V0::Models::FraudEmailRuleForm) ? x : ::Io::Flow::V0::Models::FraudEmailRuleForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/fraud/email/rules").with_json(fraud_email_rule_form.to_json).post
            ::Io::Flow::V0::Models::FraudEmailRule.new(r)
          end

          # Remove an email decision rule.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/fraud/email/rules/#{CGI.escape(id)}").delete
            nil
          end

        end

        class FtpFiles

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ftp/files").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::FtpFile.new(x) }
          end

          def post(organization, ftp_file_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = ftp_file_form; x.is_a?(::Io::Flow::V0::Models::FtpFileForm) ? x : ::Io::Flow::V0::Models::FtpFileForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ftp/files").with_json(ftp_file_form.to_json).post
            ::Io::Flow::V0::Models::FtpFile.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ftp/files/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::FtpFile.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ftp/files/#{CGI.escape(id)}").delete
            nil
          end

        end

        class FtpFolders

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :path => (x = opts.delete(:path); x.nil? ? nil : HttpClient::Preconditions.assert_class('path', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ftp/folders").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::FtpFolder.new(x) }
          end

          def post(organization, ftp_folder_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = ftp_folder_form; x.is_a?(::Io::Flow::V0::Models::FtpFolderForm) ? x : ::Io::Flow::V0::Models::FtpFolderForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ftp/folders").with_json(ftp_folder_form.to_json).post
            ::Io::Flow::V0::Models::FtpFolder.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ftp/folders/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::FtpFolder.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ftp/folders/#{CGI.escape(id)}").delete
            nil
          end

        end

        class FtpOrganizationSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/ftp/settings").get
            ::Io::Flow::V0::Models::FtpOrganizationSettings.new(r)
          end

          def put(organization, ftp_organization_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = ftp_organization_settings_form; x.is_a?(::Io::Flow::V0::Models::FtpOrganizationSettingsForm) ? x : ::Io::Flow::V0::Models::FtpOrganizationSettingsForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/ftp/settings").with_json(ftp_organization_settings_form.to_json).put
            ::Io::Flow::V0::Models::FtpOrganizationSettings.new(r)
          end

          def delete(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/ftp/settings").delete
            nil
          end

        end

        class Fulfillments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/fulfillments").get
            r.map { |x| ::Io::Flow::V0::Models::Fulfillment.new(x) }
          end

          def put_cancellations(organization, number, fulfillment_cancellation_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = fulfillment_cancellation_form; x.is_a?(::Io::Flow::V0::Models::FulfillmentCancellationForm) ? x : ::Io::Flow::V0::Models::FulfillmentCancellationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/fulfillments/cancellations").with_json(fulfillment_cancellation_form.to_json).put
            ::Io::Flow::V0::Models::Fulfillment.new(r)
          end

          def put_complete_and_cancellations(organization, number, fulfillment_complete_cancellation_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            (x = fulfillment_complete_cancellation_form; x.is_a?(::Io::Flow::V0::Models::FulfillmentCompleteCancellationForm) ? x : ::Io::Flow::V0::Models::FulfillmentCompleteCancellationForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/fulfillments/complete/cancellations").with_json(fulfillment_complete_cancellation_form.to_json).put
            ::Io::Flow::V0::Models::Fulfillment.new(r)
          end

        end

        class Healthchecks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_healthcheck
            r = @client.request("/_internal_/healthcheck").get
            ::Io::Flow::V0::Models::Healthcheck.new(r)
          end

        end

        class Imports

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search imports. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :created_by_user_id => (x = opts.delete(:created_by_user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_by_user_id', x, String)),
              :type => (x = opts.delete(:type); x.nil? ? nil : HttpClient::Preconditions.assert_class('type', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/imports").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Import.new(x) }
          end

          # Create an import.
          def post(organization, import_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = import_form; x.is_a?(::Io::Flow::V0::Models::ImportForm) ? x : ::Io::Flow::V0::Models::ImportForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/imports").with_json(import_form.to_json).post
            ::Io::Flow::V0::Models::Import.new(r)
          end

          # Provides visibility into recent changes of each import, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :import_id => (x = opts.delete(:import_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('import_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('import_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/imports/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ImportVersion.new(x) }
          end

          # Get a single import.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/imports/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Import.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/imports/#{CGI.escape(id)}").delete
            nil
          end

        end

        class ImportTemplates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/import/templates").get
            r.map { |x| ::Io::Flow::V0::Models::ImportTemplate.new(x) }
          end

          def post(organization, import_template_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = import_template_form; x.is_a?(::Io::Flow::V0::Models::ImportTemplateForm) ? x : ::Io::Flow::V0::Models::ImportTemplateForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/import/templates").with_json(import_template_form.to_json).post
            ::Io::Flow::V0::Models::ImportTemplateExample.new(r)
          end

        end

        class Invitations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search invitations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Invitation.new(x) }
          end

          # Create a new invitation.
          def post(invitation_form)
            (x = invitation_form; x.is_a?(::Io::Flow::V0::Models::InvitationForm) ? x : ::Io::Flow::V0::Models::InvitationForm.new(x))
            r = @client.request("/invitations").with_json(invitation_form.to_json).post
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Lookup an invitation by its token.
          def get_tokens_by_token(token, incoming={})
            HttpClient::Preconditions.assert_class('token', token, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Accepts the invitation w/ the specified token and the authenticated user.
          # Creating a membership record for this user within this organization.
          # Invitations are one time use only - you will get a validation error if the
          # invitation has previously been accepted or if the user's email addresses do
          # not match the email on the invite.
          def put_tokens_by_token(token)
            HttpClient::Preconditions.assert_class('token', token, String)
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :invitation => (x = opts.delete(:invitation); x.nil? ? nil : HttpClient::Preconditions.assert_class('invitation', x, Array).map { |v| HttpClient::Preconditions.assert_class('invitation', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InvitationVersion.new(x) }
          end

          # Returns information about a specific invitation.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/invitations/#{CGI.escape(id)}").delete
            nil
          end

        end

        class ItemQuerySuggestions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns search suggestions for catalog items
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/item/query/suggestions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemQuerySuggestion.new(x) }
          end

        end

        class Links

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(carrier, organization, order_number)
            HttpClient::Preconditions.assert_class('carrier', carrier, String)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('order_number', order_number, String)
            r = @client.request("/carrier/#{CGI.escape(carrier)}/data/#{CGI.escape(organization)}/#{CGI.escape(order_number)}").get
            r
          end

        end

        class Memberships

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search memberships. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, Array).map { |v| HttpClient::Preconditions.assert_class('role', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Membership.new(x) }
          end

          # Create a new membership.
          def post(membership_form)
            (x = membership_form; x.is_a?(::Io::Flow::V0::Models::MembershipForm) ? x : ::Io::Flow::V0::Models::MembershipForm.new(x))
            r = @client.request("/memberships").with_json(membership_form.to_json).post
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :membership => (x = opts.delete(:membership); x.nil? ? nil : HttpClient::Preconditions.assert_class('membership', x, Array).map { |v| HttpClient::Preconditions.assert_class('membership', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::MembershipVersion.new(x) }
          end

          # Returns information about a specific membership.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Change the role for a specific membership record. If the user already has
          # the specified role within the organization, does nothing.
          def put_by_id(id, membership_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = membership_put_form; x.is_a?(::Io::Flow::V0::Models::MembershipPutForm) ? x : ::Io::Flow::V0::Models::MembershipPutForm.new(x))
            r = @client.request("/memberships/#{CGI.escape(id)}").with_json(membership_put_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/memberships/#{CGI.escape(id)}").delete
            nil
          end

        end

        class MerchantGiftCardBalances

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Check the remaining balance on a gift card
          def post(merchant_gift_card_balance_form)
            (x = merchant_gift_card_balance_form; x.is_a?(::Io::Flow::V0::Models::MerchantGiftCardBalanceForm) ? x : ::Io::Flow::V0::Models::MerchantGiftCardBalanceForm.new(x))
            r = @client.request("/balance").with_json(merchant_gift_card_balance_form.to_json).post
            ::Io::Flow::V0::Models::MerchantGiftCardBalance.new(r)
          end

        end

        class MerchantGiftCardRedemptions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Redeems a gift card
          def post(merchant_gift_card_redemption_form)
            (x = merchant_gift_card_redemption_form; x.is_a?(::Io::Flow::V0::Models::MerchantGiftCardRedemptionForm) ? x : ::Io::Flow::V0::Models::MerchantGiftCardRedemptionForm.new(x))
            r = @client.request("/redeem").with_json(merchant_gift_card_redemption_form.to_json).post
            ::Io::Flow::V0::Models::MerchantGiftCardBalance.new(r)
          end

        end

        class MerchantGiftCardReversals

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Check the remaining balance on a gift card
          def post(merchant_gift_card_reversal_form)
            (x = merchant_gift_card_reversal_form; x.is_a?(::Io::Flow::V0::Models::MerchantGiftCardReversalForm) ? x : ::Io::Flow::V0::Models::MerchantGiftCardReversalForm.new(x))
            r = @client.request("/reverse").with_json(merchant_gift_card_reversal_form.to_json).post
            ::Io::Flow::V0::Models::MerchantGiftCardBalance.new(r)
          end

        end

        class OrganizationAuthorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # For the authorized user, if the specified organization exists, and the user
          # is an active member of this organization, returns the authorization data
          # used throughout APIs at Flow, including the user's role in that organization
          # and the organization environment. Otherwise, returns 401 - this indicates
          # either the org does not exist or the user does not have access to the org.
          def post(organization_authorization_form)
            (x = organization_authorization_form; x.is_a?(::Io::Flow::V0::Models::OrganizationAuthorizationForm) ? x : ::Io::Flow::V0::Models::OrganizationAuthorizationForm.new(x))
            r = @client.request("/organization-authorizations").with_json(organization_authorization_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationAuthorization.new(r)
          end

          # For the authorized user and specific organization, if the user is an active
          # member of this organization, returns the authorization data used throughout
          # APIs at Flow, including the user's role in that organization and the
          # organization environment.
          def get_by_organization(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/organization-authorizations/#{CGI.escape(organization)}").get
            ::Io::Flow::V0::Models::OrganizationAuthorization.new(r)
          end

        end

        class OrganizationDefaultConfigurations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/#{CGI.escape(organization_id)}/default/configurations").get
            ::Io::Flow::V0::Models::OrganizationDefaultConfigurations.new(r)
          end

          # Update the default checkout configuration id for this organization
          def put_checkout(organization_id, organization_default_configurations_form)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            (x = organization_default_configurations_form; x.is_a?(::Io::Flow::V0::Models::OrganizationDefaultConfigurationsForm) ? x : ::Io::Flow::V0::Models::OrganizationDefaultConfigurationsForm.new(x))
            r = @client.request("/#{CGI.escape(organization_id)}/default/configurations/checkout").with_json(organization_default_configurations_form.to_json).put
            ::Io::Flow::V0::Models::OrganizationDefaultConfigurations.new(r)
          end

        end

        class OrganizationTokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens for the specified organization
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :mine => (x = opts.delete(:mine); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('mine', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationToken.new(x) }
          end

          # Create a new organization
          def post(organization, organization_token_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = organization_token_form; x.is_a?(::Io::Flow::V0::Models::OrganizationTokenForm) ? x : ::Io::Flow::V0::Models::OrganizationTokenForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/tokens").with_json(organization_token_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationToken.new(r)
          end

        end

        class PartnerTokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens for the specified partner
          def get(partner, incoming={})
            HttpClient::Preconditions.assert_class('partner', partner, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :mine => (x = opts.delete(:mine); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('mine', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/partners/#{CGI.escape(partner)}/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PartnerToken.new(x) }
          end

          # Create a new partner
          def post(partner, partner_token_form)
            HttpClient::Preconditions.assert_class('partner', partner, String)
            (x = partner_token_form; x.is_a?(::Io::Flow::V0::Models::PartnerTokenForm) ? x : ::Io::Flow::V0::Models::PartnerTokenForm.new(x))
            r = @client.request("/partners/#{CGI.escape(partner)}/tokens").with_json(partner_token_form.to_json).post
            ::Io::Flow::V0::Models::PartnerToken.new(r)
          end

        end

        class PasswordResetForms

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(password_reset_form, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = password_reset_form; x.is_a?(::Io::Flow::V0::Models::PasswordResetForm) ? x : ::Io::Flow::V0::Models::PasswordResetForm.new(x))
            r = @client.request("/users/passwords").with_query(query).with_json(password_reset_form.to_json).post
            ::Io::Flow::V0::Models::ExpandableUser.from_json(r)
          end

          def post_resets(password_reset_request_form)
            (x = password_reset_request_form; x.is_a?(::Io::Flow::V0::Models::PasswordResetRequestForm) ? x : ::Io::Flow::V0::Models::PasswordResetRequestForm.new(x))
            r = @client.request("/users/passwords/resets").with_json(password_reset_request_form.to_json).post
            nil
          end

        end

        class PermissionChecks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns permissions for the specified organization for the current request.
          # Used by integrators to test headers.
          def get_permission_and_checks_and_all_by_organization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :permitted_method => (x = opts.delete(:permitted_method); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PermittedHttpMethod) ? x : ::Io::Flow::V0::Models::PermittedHttpMethod.apply(x)).value),
              :path => (x = opts.delete(:path); x.nil? ? nil : HttpClient::Preconditions.assert_class('path', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/permission/checks/all").with_query(query).get
            ::Io::Flow::V0::Models::PermissionCheck.new(r)
          end

        end

        class ScheduledExports

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search scheduled exports. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users/scheduled/exports").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ScheduledExport.new(x) }
          end

          # Create a scheduled export.
          def post(scheduled_export_form)
            (x = scheduled_export_form; x.is_a?(::Io::Flow::V0::Models::ScheduledExportForm) ? x : ::Io::Flow::V0::Models::ScheduledExportForm.new(x))
            r = @client.request("/users/scheduled/exports").with_json(scheduled_export_form.to_json).post
            ::Io::Flow::V0::Models::ScheduledExport.new(r)
          end

          # Get a single scheduled export.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/scheduled/exports/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ScheduledExport.new(r)
          end

          # Update a scheduled export.
          def put_by_id(id, scheduled_export_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = scheduled_export_form; x.is_a?(::Io::Flow::V0::Models::ScheduledExportForm) ? x : ::Io::Flow::V0::Models::ScheduledExportForm.new(x))
            r = @client.request("/users/scheduled/exports/#{CGI.escape(id)}").with_json(scheduled_export_form.to_json).put
            ::Io::Flow::V0::Models::ScheduledExport.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/scheduled/exports/#{CGI.escape(id)}").delete
            nil
          end

        end

        class Sessions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_shopify_and_organizations_by_organization(organization, session_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = session_form; x.is_a?(::Io::Flow::V0::Models::SessionForm) ? x : ::Io::Flow::V0::Models::SessionForm.new(x))
            r = @client.request("/sessions/shopify/organizations/#{CGI.escape(organization)}").with_json(session_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationSession.new(r)
          end

          def get_shopify_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/shopify/#{CGI.escape(session)}").get
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def put_shopify_by_session(session, session_put_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            (x = session_put_form; x.is_a?(::Io::Flow::V0::Models::SessionPutForm) ? x : ::Io::Flow::V0::Models::SessionPutForm.new(x))
            r = @client.request("/sessions/shopify/#{CGI.escape(session)}").with_json(session_put_form.to_json).put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def delete_shopify_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/shopify/#{CGI.escape(session)}").delete
            nil
          end

          # Clears the session geo parameters
          def put_shopify_and_clear_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/shopify/#{CGI.escape(session)}/clear").put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def put_shopify_and_organizations_by_session_and_organization(session, organization, session_put_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = session_put_form; x.is_a?(::Io::Flow::V0::Models::SessionPutForm) ? x : ::Io::Flow::V0::Models::SessionPutForm.new(x))
            r = @client.request("/sessions/shopify/#{CGI.escape(session)}/organizations/#{CGI.escape(organization)}").with_json(session_put_form.to_json).put
            ::Io::Flow::V0::Models::OrganizationSession.new(r)
          end

          # Resets the session based on the provided geo parameters.
          def put_shopify_and_reset_by_session(session, session_put_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            (x = session_put_form; x.is_a?(::Io::Flow::V0::Models::SessionPutForm) ? x : ::Io::Flow::V0::Models::SessionPutForm.new(x))
            r = @client.request("/sessions/shopify/#{CGI.escape(session)}/reset").with_json(session_put_form.to_json).put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def post_organizations_by_organization(organization, session_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = session_form; x.is_a?(::Io::Flow::V0::Models::SessionForm) ? x : ::Io::Flow::V0::Models::SessionForm.new(x))
            r = @client.request("/sessions/organizations/#{CGI.escape(organization)}").with_json(session_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationSession.new(r)
          end

          def get_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/#{CGI.escape(session)}").get
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def put_by_session(session, session_put_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            (x = session_put_form; x.is_a?(::Io::Flow::V0::Models::SessionPutForm) ? x : ::Io::Flow::V0::Models::SessionPutForm.new(x))
            r = @client.request("/sessions/#{CGI.escape(session)}").with_json(session_put_form.to_json).put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def delete_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/#{CGI.escape(session)}").delete
            nil
          end

          # Clears the session geo parameters
          def put_clear_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/#{CGI.escape(session)}/clear").put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def put_organizations_by_session_and_organization(session, organization, session_put_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = session_put_form; x.is_a?(::Io::Flow::V0::Models::SessionPutForm) ? x : ::Io::Flow::V0::Models::SessionPutForm.new(x))
            r = @client.request("/sessions/#{CGI.escape(session)}/organizations/#{CGI.escape(organization)}").with_json(session_put_form.to_json).put
            ::Io::Flow::V0::Models::OrganizationSession.new(r)
          end

          # Resets the session based on the provided geo parameters.
          def put_reset_by_session(session, session_put_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            (x = session_put_form; x.is_a?(::Io::Flow::V0::Models::SessionPutForm) ? x : ::Io::Flow::V0::Models::SessionPutForm.new(x))
            r = @client.request("/sessions/#{CGI.escape(session)}/reset").with_json(session_put_form.to_json).put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

        end

        class SessionAuthorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(session_authorization_form)
            (x = session_authorization_form; x.is_a?(::Io::Flow::V0::Models::SessionAuthorizationForm) ? x : ::Io::Flow::V0::Models::SessionAuthorizationForm.new(x))
            r = @client.request("/authorizations/sessions").with_json(session_authorization_form.to_json).post
            ::Io::Flow::V0::Models::SessionAuthorization.from_json(r)
          end

        end

        class ShopifyCarts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Retrieve representation of a Shopify cart for the given order number.
          def get_order_by_number(number)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/shopify/carts/order/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::ShopifyCart.new(r)
          end

          # Retrieve representation of a Shopify cart given the unique cart id.
          def get_by_id_html(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/shopify/carts/#{CGI.escape(id)}").get
            r
          end

          # Retrieve representation of a Shopify cart given the unique cart id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/shopify/carts/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ShopifyCart.new(r)
          end

          # Add an item to a Shopify cart given the unique cart id.
          def post_add_by_id(id, shopify_cart_add_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = shopify_cart_add_form; x.is_a?(::Io::Flow::V0::Models::ShopifyCartAddForm) ? x : ::Io::Flow::V0::Models::ShopifyCartAddForm.from_json(x))
            r = @client.request("/shopify/carts/#{CGI.escape(id)}/add").with_json(shopify_cart_add_form.to_json).post
            ::Io::Flow::V0::Models::ShopifyCart.new(r)
          end

          # Update the attribute information for the cart.
          def put_attributes_by_id(id, shopify_order_attributes_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = shopify_order_attributes_form; x.is_a?(::Io::Flow::V0::Models::ShopifyOrderAttributesForm) ? x : ::Io::Flow::V0::Models::ShopifyOrderAttributesForm.new(x))
            r = @client.request("/shopify/carts/#{CGI.escape(id)}/attributes").with_json(shopify_order_attributes_form.to_json).put
            ::Io::Flow::V0::Models::ShopifyCart.new(r)
          end

          # Change/Update an item in a Shopify cart given the unique cart id.
          def post_change_by_id(id, shopify_cart_change_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = shopify_cart_change_form; x.is_a?(::Io::Flow::V0::Models::ShopifyCartChangeForm) ? x : ::Io::Flow::V0::Models::ShopifyCartChangeForm.new(x))
            r = @client.request("/shopify/carts/#{CGI.escape(id)}/change").with_json(shopify_cart_change_form.to_json).post
            ::Io::Flow::V0::Models::ShopifyCart.new(r)
          end

          # Remove all cart items given the unique cart id .
          def post_clear_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/shopify/carts/#{CGI.escape(id)}/clear").post
            ::Io::Flow::V0::Models::ShopifyCart.new(r)
          end

          # Update the geo information for the cart.
          def put_geo_by_id(id, geo_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = geo_form; x.is_a?(::Io::Flow::V0::Models::GeoForm) ? x : ::Io::Flow::V0::Models::GeoForm.new(x))
            r = @client.request("/shopify/carts/#{CGI.escape(id)}/geo").with_json(geo_form.to_json).put
            ::Io::Flow::V0::Models::ShopifyCart.new(r)
          end

          # Create an order from a Flow cart.
          def post_orders_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/shopify/carts/#{CGI.escape(id)}/orders").with_query(query).post
            ::Io::Flow::V0::Models::Order.new(r)
          end

        end

        class ShopifyCartConversions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Creates a shopify cart conversion from a shopify cart
          def post_conversions(organization, experience_key, io_flow_shopify_external_v0_models_shopify_cart, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            (x = io_flow_shopify_external_v0_models_shopify_cart; x.is_a?(::Io::Flow::Shopify::External::V0::Models::ShopifyCart) ? x : ::Io::Flow::Shopify::External::V0::Models::ShopifyCart.new(x))
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/shopify/cart/conversions").with_query(query).with_json(io_flow_shopify_external_v0_models_shopify_cart.to_json).post
            ::Io::Flow::V0::Models::ShopifyCartConversion.new(r)
          end

        end

        class ShopifyLocalizationSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shopify/localization/settings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShopifyLocalizationSetting.new(x) }
          end

          # Add a localization setting.
          def post(organization, shopify_localization_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = shopify_localization_setting_form; x.is_a?(::Io::Flow::V0::Models::ShopifyLocalizationSettingForm) ? x : ::Io::Flow::V0::Models::ShopifyLocalizationSettingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shopify/localization/settings").with_json(shopify_localization_setting_form.to_json).post
            ::Io::Flow::V0::Models::ShopifyLocalizationSetting.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shopify/localization/settings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ShopifyLocalizationSetting.new(r)
          end

          # Update a localization setting.
          def put_by_id(organization, id, shopify_localization_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = shopify_localization_setting_form; x.is_a?(::Io::Flow::V0::Models::ShopifyLocalizationSettingForm) ? x : ::Io::Flow::V0::Models::ShopifyLocalizationSettingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shopify/localization/settings/#{CGI.escape(id)}").with_json(shopify_localization_setting_form.to_json).put
            ::Io::Flow::V0::Models::ShopifyLocalizationSetting.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shopify/localization/settings/#{CGI.escape(id)}").delete
            nil
          end

        end

        class ShopifyLocationFlowCenterMappings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shopify/locations/mappings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShopifyLocationFlowCenterMapping.new(x) }
          end

          # Add a Shopify location/Flow Center mapping.
          def post(organization, shopify_location_flow_center_mapping_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = shopify_location_flow_center_mapping_form; x.is_a?(::Io::Flow::V0::Models::ShopifyLocationFlowCenterMappingForm) ? x : ::Io::Flow::V0::Models::ShopifyLocationFlowCenterMappingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shopify/locations/mappings").with_json(shopify_location_flow_center_mapping_form.to_json).post
            ::Io::Flow::V0::Models::ShopifyLocationFlowCenterMapping.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shopify/locations/mappings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ShopifyLocationFlowCenterMapping.new(r)
          end

          # Update a Shopify location/Flow Center mapping.
          def put_by_id(organization, id, shopify_location_flow_center_mapping_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = shopify_location_flow_center_mapping_form; x.is_a?(::Io::Flow::V0::Models::ShopifyLocationFlowCenterMappingForm) ? x : ::Io::Flow::V0::Models::ShopifyLocationFlowCenterMappingForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shopify/locations/mappings/#{CGI.escape(id)}").with_json(shopify_location_flow_center_mapping_form.to_json).put
            ::Io::Flow::V0::Models::ShopifyLocationFlowCenterMapping.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shopify/locations/mappings/#{CGI.escape(id)}").delete
            nil
          end

        end

        class ShopifyPrivateApps

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shopify/private/apps").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShopifyPrivateApp.new(x) }
          end

          def put(organization, shopify_private_app_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = shopify_private_app_form; x.is_a?(::Io::Flow::V0::Models::ShopifyPrivateAppForm) ? x : ::Io::Flow::V0::Models::ShopifyPrivateAppForm.new(x))
            r = @client.request("/#{CGI.escape(organization)}/shopify/private/apps").with_json(shopify_private_app_form.to_json).put
            ::Io::Flow::V0::Models::ShopifyPrivateApp.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shopify/private/apps/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ShopifyPrivateApp.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shopify/private/apps/#{CGI.escape(id)}").delete
            nil
          end

        end

        class ShopifySyncStatuses

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :interval_seconds => HttpClient::Preconditions.assert_class('interval_seconds', (x = opts.delete(:interval_seconds); x.nil? ? 60 : x), Integer),
              :sync_check => (x = (x = opts.delete(:sync_check); x.nil? ? "localized_variants" : x); x.is_a?(::Io::Flow::V0::Models::ShopifySyncCheck) ? x : ::Io::Flow::V0::Models::ShopifySyncCheck.apply(x)).value
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shopify/sync/status").with_query(query).get
            ::Io::Flow::V0::Models::ShopifySyncStatus.new(r)
          end

        end

        class Suggestions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns search suggestions for catalog items
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-count" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

        end

        class TaxSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns the tax settings for the organization.
          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/tax/settings").get
            ::Io::Flow::V0::Models::TaxSetting.from_json(r)
          end

          def put(organization, tax_setting)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            (x = tax_setting; x.is_a?(::Io::Flow::V0::Models::TaxSetting) ? x : ::Io::Flow::V0::Models::TaxSetting.from_json(x))
            r = @client.request("/#{CGI.escape(organization)}/tax/settings").with_json(tax_setting.to_json).put
            ::Io::Flow::V0::Models::TaxSetting.from_json(r)
          end

          def delete(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/tax/settings").delete
            nil
          end

        end

        class Tokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens that you are authorized to view. Note that the cleartext
          # token value is never sent. To view the API token itself, see the resource
          # path /tokens/:id/cleartext
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :partner => (x = opts.delete(:partner); x.nil? ? nil : HttpClient::Preconditions.assert_class('partner', x, String)),
              :mine => (x = opts.delete(:mine); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('mine', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Token.from_json(x) }
          end

          # Preferred method to validate a token, obtaining specific information if the
          # token is valid (or a 404 if the token does not exist). We use an HTTP POST
          # with a form body to ensure that the token itself is not logged in the
          # request logs.
          def post_authentications(token_authentication_form)
            (x = token_authentication_form; x.is_a?(::Io::Flow::V0::Models::TokenAuthenticationForm) ? x : ::Io::Flow::V0::Models::TokenAuthenticationForm.new(x))
            r = @client.request("/tokens/authentications").with_json(token_authentication_form.to_json).post
            ::Io::Flow::V0::Models::TokenReference.from_json(r)
          end

          # Get metadata for the token with this ID
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Token.from_json(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").delete
            nil
          end

          # Retrieves the token with the actual string token in cleartext
          def get_cleartext_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}/cleartext").get
            ::Io::Flow::V0::Models::Cleartext.new(r)
          end

        end

        class TokenValidations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(token_validation_form)
            (x = token_validation_form; x.is_a?(::Io::Flow::V0::Models::TokenValidationForm) ? x : ::Io::Flow::V0::Models::TokenValidationForm.new(x))
            r = @client.request("/token-validations").with_json(token_validation_form.to_json).post
            ::Io::Flow::V0::Models::TokenValidation.new(r)
          end

        end

        class Uploads

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_name(organization, name)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('name', name, String)
            r = @client.request("/#{CGI.escape(organization)}/uploads/#{CGI.escape(name)}").post
            ::Io::Flow::V0::Models::Upload.new(r)
          end

        end

        class Users

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search users. Must specify an id or email.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :status => (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UserStatus) ? x : ::Io::Flow::V0::Models::UserStatus.apply(x)).value),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::User.new(x) }
          end

          # Create a new user. Note that new users will be created with a status of
          # pending and will not be able to authenticate until approved by a member of
          # the Flow team.
          def post(user_form)
            (x = user_form; x.is_a?(::Io::Flow::V0::Models::UserForm) ? x : ::Io::Flow::V0::Models::UserForm.new(x))
            r = @client.request("/users").with_json(user_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Authenticates a user by email / password. Note only users that have a status
          # of active will be authorized.
          def post_authenticate(authentication_form)
            (x = authentication_form; x.is_a?(::Io::Flow::V0::Models::AuthenticationForm) ? x : ::Io::Flow::V0::Models::AuthenticationForm.new(x))
            r = @client.request("/users/authenticate").with_json(authentication_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Returns information about a specific user.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update a user.
          def put_by_id(id, user_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = user_put_form; x.is_a?(::Io::Flow::V0::Models::UserPutForm) ? x : ::Io::Flow::V0::Models::UserPutForm.new(x))
            r = @client.request("/users/#{CGI.escape(id)}").with_json(user_put_form.to_json).put
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update the password for a user.
          def patch_passwords_by_id(id, password_change_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            (x = password_change_form; x.is_a?(::Io::Flow::V0::Models::PasswordChangeForm) ? x : ::Io::Flow::V0::Models::PasswordChangeForm.new(x))
            r = @client.request("/users/#{CGI.escape(id)}/passwords").with_json(password_change_form.to_json).patch
            nil
          end

          # Deletes a password for the given user.
          def delete_passwords_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").delete
            nil
          end

        end

      end

      module Models

        class AdyenNativeData

          module Types
            ADYEN_IDENTIFY_SHOPPER_DATA = 'adyen_identify_shopper_data' unless defined?(ADYEN_IDENTIFY_SHOPPER_DATA)
            ADYEN_CHALLENGE_SHOPPER_DATA = 'adyen_challenge_shopper_data' unless defined?(ADYEN_CHALLENGE_SHOPPER_DATA)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AdyenNativeData')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of adyen_native_data directly - must use one of the specific types: adyen_identify_shopper_data, adyen_challenge_shopper_data'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AdyenNativeData.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[adyen_native_data] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ADYEN_IDENTIFY_SHOPPER_DATA; AdyenIdentifyShopperData.new(hash)
              when Types::ADYEN_CHALLENGE_SHOPPER_DATA; AdyenChallengeShopperData.new(hash)
              else AdyenNativeDataUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AdyenNativeDataUndefinedType < AdyenNativeData

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AllocationComponent

          module Types
            ALLOCATION_DETAIL_COMPONENT = 'allocation_detail_component' unless defined?(ALLOCATION_DETAIL_COMPONENT)
            ALLOCATION_LEVY_COMPONENT = 'allocation_levy_component' unless defined?(ALLOCATION_LEVY_COMPONENT)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AllocationComponent')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of allocation_component directly - must use one of the specific types: allocation_detail_component, allocation_levy_component'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AllocationComponent.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[allocation_component] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ALLOCATION_DETAIL_COMPONENT; AllocationDetailComponent.new(hash)
              when Types::ALLOCATION_LEVY_COMPONENT; AllocationLevyComponent.new(hash)
              else AllocationComponentUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AllocationComponentUndefinedType < AllocationComponent

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AllocationDetail

          module Types
            ALLOCATION_LINE_DETAIL = 'allocation_line_detail' unless defined?(ALLOCATION_LINE_DETAIL)
            ALLOCATION_ORDER_DETAIL = 'allocation_order_detail' unless defined?(ALLOCATION_ORDER_DETAIL)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AllocationDetail')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of allocation_detail directly - must use one of the specific types: allocation_line_detail, allocation_order_detail'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AllocationDetail.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[allocation_detail] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ALLOCATION_LINE_DETAIL; AllocationLineDetail.new(hash)
              when Types::ALLOCATION_ORDER_DETAIL; AllocationOrderDetail.new(hash)
              else AllocationDetailUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AllocationDetailUndefinedType < AllocationDetail

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Authorization

          module Types
            CARD_AUTHORIZATION = 'card_authorization' unless defined?(CARD_AUTHORIZATION)
            ONLINE_AUTHORIZATION = 'online_authorization' unless defined?(ONLINE_AUTHORIZATION)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Authorization')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of authorization directly - must use one of the specific types: card_authorization, online_authorization'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Authorization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[authorization] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CARD_AUTHORIZATION; CardAuthorization.new(hash)
              when Types::ONLINE_AUTHORIZATION; OnlineAuthorization.new(hash)
              else AuthorizationUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AuthorizationUndefinedType < Authorization

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Flow provides several different options for creating an authorization
        class AuthorizationForm

          module Types
            # Creates a new authorization by copying an existing one.
            AUTHORIZATION_COPY_FORM = 'authorization_copy_form' unless defined?(AUTHORIZATION_COPY_FORM)
            # Enables card payments
            DIRECT_AUTHORIZATION_FORM = 'direct_authorization_form' unless defined?(DIRECT_AUTHORIZATION_FORM)
            # Enables card payments with Flow as Merchant of Record
            MERCHANT_OF_RECORD_AUTHORIZATION_FORM = 'merchant_of_record_authorization_form' unless defined?(MERCHANT_OF_RECORD_AUTHORIZATION_FORM)
            # Enables authorization via PayPal
            PAYPAL_AUTHORIZATION_FORM = 'paypal_authorization_form' unless defined?(PAYPAL_AUTHORIZATION_FORM)
            # Enables authorizations via redirect-based alternative payment methods, such as
            # AliPay.
            REDIRECT_AUTHORIZATION_FORM = 'redirect_authorization_form' unless defined?(REDIRECT_AUTHORIZATION_FORM)
            # Enables authorizations via inline widget alternative payment methods, such as
            # Klarna.
            INLINE_AUTHORIZATION_FORM = 'inline_authorization_form' unless defined?(INLINE_AUTHORIZATION_FORM)
            # Enables authorizations via ACH (Automated Clearing House) bank transfer.
            ACH_AUTHORIZATION_FORM = 'ach_authorization_form' unless defined?(ACH_AUTHORIZATION_FORM)
            # Enables authorizations via card payment source.
            CARD_PAYMENT_SOURCE_AUTHORIZATION_FORM = 'card_payment_source_authorization_form' unless defined?(CARD_PAYMENT_SOURCE_AUTHORIZATION_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AuthorizationForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of authorization_form directly - must use one of the specific types: authorization_copy_form, direct_authorization_form, merchant_of_record_authorization_form, paypal_authorization_form, redirect_authorization_form, inline_authorization_form, ach_authorization_form, card_payment_source_authorization_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AuthorizationForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[authorization_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AUTHORIZATION_COPY_FORM; AuthorizationCopyForm.new(hash)
              when Types::DIRECT_AUTHORIZATION_FORM; DirectAuthorizationForm.new(hash)
              when Types::MERCHANT_OF_RECORD_AUTHORIZATION_FORM; MerchantOfRecordAuthorizationForm.new(hash)
              when Types::PAYPAL_AUTHORIZATION_FORM; PaypalAuthorizationForm.new(hash)
              when Types::REDIRECT_AUTHORIZATION_FORM; RedirectAuthorizationForm.new(hash)
              when Types::INLINE_AUTHORIZATION_FORM; InlineAuthorizationForm.new(hash)
              when Types::ACH_AUTHORIZATION_FORM; AchAuthorizationForm.new(hash)
              when Types::CARD_PAYMENT_SOURCE_AUTHORIZATION_FORM; CardPaymentSourceAuthorizationForm.new(hash)
              else AuthorizationFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AuthorizationFormUndefinedType < AuthorizationForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AuthorizationPayloadParameters

          module Types
            GOOGLE_PAY_AUTHORIZATION_PAYLOAD = 'google_pay_authorization_payload' unless defined?(GOOGLE_PAY_AUTHORIZATION_PAYLOAD)
            APPLE_PAY_MERCHANT_VALIDATION_PAYLOAD = 'apple_pay_merchant_validation_payload' unless defined?(APPLE_PAY_MERCHANT_VALIDATION_PAYLOAD)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AuthorizationPayloadParameters')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of authorization_payload_parameters directly - must use one of the specific types: google_pay_authorization_payload, apple_pay_merchant_validation_payload'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AuthorizationPayloadParameters.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[authorization_payload_parameters] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::GOOGLE_PAY_AUTHORIZATION_PAYLOAD; GooglePayAuthorizationPayload.new(hash)
              when Types::APPLE_PAY_MERCHANT_VALIDATION_PAYLOAD; ApplePayMerchantValidationPayload.new(hash)
              else AuthorizationPayloadParametersUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AuthorizationPayloadParametersUndefinedType < AuthorizationPayloadParameters

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AuthorizationResultAction

          module Types
            AUTHORIZATION_RESULT_ACTION_GET = 'authorization_result_action_get' unless defined?(AUTHORIZATION_RESULT_ACTION_GET)
            AUTHORIZATION_RESULT_ACTION_POST = 'authorization_result_action_post' unless defined?(AUTHORIZATION_RESULT_ACTION_POST)
            AUTHORIZATION_RESULT_ACTION_WAIT = 'authorization_result_action_wait' unless defined?(AUTHORIZATION_RESULT_ACTION_WAIT)
            AUTHORIZATION_RESULT_ACTION_NATIVE = 'authorization_result_action_native' unless defined?(AUTHORIZATION_RESULT_ACTION_NATIVE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AuthorizationResultAction')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of authorization_result_action directly - must use one of the specific types: authorization_result_action_get, authorization_result_action_post, authorization_result_action_wait, authorization_result_action_native'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AuthorizationResultAction.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[authorization_result_action] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AUTHORIZATION_RESULT_ACTION_GET; AuthorizationResultActionGet.new(hash)
              when Types::AUTHORIZATION_RESULT_ACTION_POST; AuthorizationResultActionPost.new(hash)
              when Types::AUTHORIZATION_RESULT_ACTION_WAIT; AuthorizationResultActionWait.new(hash)
              when Types::AUTHORIZATION_RESULT_ACTION_NATIVE; AuthorizationResultActionNative.new(hash)
              else AuthorizationResultActionUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AuthorizationResultActionUndefinedType < AuthorizationResultAction

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AuthorizationResultActionDetails

          module Types
            ADYEN_NATIVE_ACTION_DETAILS = 'adyen_native_action_details' unless defined?(ADYEN_NATIVE_ACTION_DETAILS)
            STRIPE_AUTHORIZATION_RESULT_ACTION_DETAILS = 'stripe_authorization_result_action_details' unless defined?(STRIPE_AUTHORIZATION_RESULT_ACTION_DETAILS)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AuthorizationResultActionDetails')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of authorization_result_action_details directly - must use one of the specific types: adyen_native_action_details, stripe_authorization_result_action_details'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AuthorizationResultActionDetails.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[authorization_result_action_details] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ADYEN_NATIVE_ACTION_DETAILS; AdyenNativeActionDetails.new(hash)
              when Types::STRIPE_AUTHORIZATION_RESULT_ACTION_DETAILS; StripeAuthorizationResultActionDetails.new(hash)
              else AuthorizationResultActionDetailsUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AuthorizationResultActionDetailsUndefinedType < AuthorizationResultActionDetails

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AvailableFilter

          module Types
            AVAILABLE_FILTER_STRUCTURED = 'structured' unless defined?(AVAILABLE_FILTER_STRUCTURED)
            AVAILABLE_FILTER_UNSTRUCTURED = 'unstructured' unless defined?(AVAILABLE_FILTER_UNSTRUCTURED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AvailableFilter')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of available_filter directly - must use one of the specific types: available_filter_structured, available_filter_unstructured'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AvailableFilter.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[available_filter] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AVAILABLE_FILTER_STRUCTURED; AvailableFilterStructured.new(hash)
              when Types::AVAILABLE_FILTER_UNSTRUCTURED; AvailableFilterUnstructured.new(hash)
              else AvailableFilterUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AvailableFilterUndefinedType < AvailableFilter

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class CheckoutTokenForm

          module Types
            CHECKOUT_TOKEN_ORDER_FORM = 'checkout_token_order_form' unless defined?(CHECKOUT_TOKEN_ORDER_FORM)
            CHECKOUT_TOKEN_REFERENCE_FORM = 'checkout_token_reference_form' unless defined?(CHECKOUT_TOKEN_REFERENCE_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'checkout_token_reference_form', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of checkout_token_form directly - must use one of the specific types: checkout_token_order_form, checkout_token_reference_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def CheckoutTokenForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[checkout_token_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CHECKOUT_TOKEN_ORDER_FORM; CheckoutTokenOrderForm.new(hash)
              when Types::CHECKOUT_TOKEN_REFERENCE_FORM; CheckoutTokenReferenceForm.new(hash)
              else CheckoutTokenFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class CheckoutTokenFormUndefinedType < CheckoutTokenForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ConfirmationDetails

          module Types
            DIRECT_DEBIT = 'direct_debit' unless defined?(DIRECT_DEBIT)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ConfirmationDetails')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of confirmation_details directly - must use one of the specific types: direct_debit'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ConfirmationDetails.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[confirmation_details] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DIRECT_DEBIT; DirectDebit.new(hash)
              else ConfirmationDetailsUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ConfirmationDetailsUndefinedType < ConfirmationDetails

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ConsumerInvoiceLine

          module Types
            CONSUMER_INVOICE_LINE_ITEM = 'item' unless defined?(CONSUMER_INVOICE_LINE_ITEM)
            CONSUMER_INVOICE_LINE_DISCOUNT = 'discount' unless defined?(CONSUMER_INVOICE_LINE_DISCOUNT)
            CONSUMER_INVOICE_LINE_SHIPPING = 'shipping' unless defined?(CONSUMER_INVOICE_LINE_SHIPPING)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ConsumerInvoiceLine')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of consumer_invoice_line directly - must use one of the specific types: consumer_invoice_line_item, consumer_invoice_line_discount, consumer_invoice_line_shipping'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ConsumerInvoiceLine.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[consumer_invoice_line] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CONSUMER_INVOICE_LINE_ITEM; ConsumerInvoiceLineItem.new(hash)
              when Types::CONSUMER_INVOICE_LINE_DISCOUNT; ConsumerInvoiceLineDiscount.new(hash)
              when Types::CONSUMER_INVOICE_LINE_SHIPPING; ConsumerInvoiceLineShipping.new(hash)
              else ConsumerInvoiceLineUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ConsumerInvoiceLineUndefinedType < ConsumerInvoiceLine

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ConsumerInvoiceLineForm

          module Types
            CONSUMER_INVOICE_LINE_ITEM_FORM = 'item' unless defined?(CONSUMER_INVOICE_LINE_ITEM_FORM)
            CONSUMER_INVOICE_LINE_DISCOUNT_FORM = 'discount' unless defined?(CONSUMER_INVOICE_LINE_DISCOUNT_FORM)
            CONSUMER_INVOICE_LINE_SHIPPING_FORM = 'shipping' unless defined?(CONSUMER_INVOICE_LINE_SHIPPING_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ConsumerInvoiceLineForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of consumer_invoice_line_form directly - must use one of the specific types: consumer_invoice_line_item_form, consumer_invoice_line_discount_form, consumer_invoice_line_shipping_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ConsumerInvoiceLineForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[consumer_invoice_line_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CONSUMER_INVOICE_LINE_ITEM_FORM; ConsumerInvoiceLineItemForm.new(hash)
              when Types::CONSUMER_INVOICE_LINE_DISCOUNT_FORM; ConsumerInvoiceLineDiscountForm.new(hash)
              when Types::CONSUMER_INVOICE_LINE_SHIPPING_FORM; ConsumerInvoiceLineShippingForm.new(hash)
              else ConsumerInvoiceLineFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ConsumerInvoiceLineFormUndefinedType < ConsumerInvoiceLineForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A delivery represents a group of items that will be delivered together -
        # presenting a single price and delivery time frame, where applicable, to the
        # user. Deliveries commonly are created based on the type of item and, for
        # physical goods, their center of origin
        class Delivery

          module Types
            # Represents items that can be delivered electronically (e.g. a gift card
            # delivered via email)
            DIGITAL_DELIVERY = 'digital_delivery' unless defined?(DIGITAL_DELIVERY)
            # Represents items that are physical and require shipment
            PHYSICAL_DELIVERY = 'physical_delivery' unless defined?(PHYSICAL_DELIVERY)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'physical_delivery', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of delivery directly - must use one of the specific types: digital_delivery, physical_delivery'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Delivery.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[delivery] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DIGITAL_DELIVERY; DigitalDelivery.new(hash)
              when Types::PHYSICAL_DELIVERY; PhysicalDelivery.new(hash)
              else DeliveryUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class DeliveryUndefinedType < Delivery

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # De Minimis describes the country specific rules for exactly how tax and duties
        # are calculated, as well as any exemptions that apply. See
        # https://en.wikipedia.org/wiki/De_minimis for more information.
        class Deminimis

          module Types
            DEMINIMIS_SIMPLE = 'deminimis_simple' unless defined?(DEMINIMIS_SIMPLE)
            DEMINIMIS_PER_ITEM = 'deminimis_per_item' unless defined?(DEMINIMIS_PER_ITEM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Deminimis')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of deminimis directly - must use one of the specific types: deminimis_simple, deminimis_per_item'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Deminimis.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[deminimis] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DEMINIMIS_SIMPLE; DeminimisSimple.new(hash)
              when Types::DEMINIMIS_PER_ITEM; DeminimisPerItem.new(hash)
              else DeminimisUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class DeminimisUndefinedType < Deminimis

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class DiscountOffer

          module Types
            DISCOUNT_OFFER_FIXED = 'discount_offer_fixed' unless defined?(DISCOUNT_OFFER_FIXED)
            DISCOUNT_OFFER_PERCENT = 'discount_offer_percent' unless defined?(DISCOUNT_OFFER_PERCENT)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'DiscountOffer')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of discount_offer directly - must use one of the specific types: discount_offer_fixed, discount_offer_percent'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def DiscountOffer.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[discount_offer] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DISCOUNT_OFFER_FIXED; DiscountOfferFixed.new(hash)
              when Types::DISCOUNT_OFFER_PERCENT; DiscountOfferPercent.new(hash)
              else DiscountOfferUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class DiscountOfferUndefinedType < DiscountOffer

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Document

          module Types
            CATALOG_ITEM_DOCUMENT = 'catalog_item_document' unless defined?(CATALOG_ITEM_DOCUMENT)
            HARMONIZATION_DOCUMENT = 'harmonization_document' unless defined?(HARMONIZATION_DOCUMENT)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Document')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of document directly - must use one of the specific types: catalog_item_document, harmonization_document'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Document.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[document] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CATALOG_ITEM_DOCUMENT; CatalogItemDocument.new(hash)
              when Types::HARMONIZATION_DOCUMENT; HarmonizationDocument.new(hash)
              else DocumentUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class DocumentUndefinedType < Document

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class EmailNotificationData

          module Types
            EMAIL_NOTIFICATION_DATA_REFUND = 'refund' unless defined?(EMAIL_NOTIFICATION_DATA_REFUND)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'EmailNotificationData')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of email_notification_data directly - must use one of the specific types: email_notification_data_refund'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def EmailNotificationData.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[email_notification_data] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::EMAIL_NOTIFICATION_DATA_REFUND; EmailNotificationDataRefund.new(hash)
              else EmailNotificationDataUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class EmailNotificationDataUndefinedType < EmailNotificationData

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Event

          module Types
            ATTRIBUTE_UPSERTED = 'attribute_upserted' unless defined?(ATTRIBUTE_UPSERTED)
            ATTRIBUTE_DELETED = 'attribute_deleted' unless defined?(ATTRIBUTE_DELETED)
            ATTRIBUTE_UPSERTED_V2 = 'attribute_upserted_v2' unless defined?(ATTRIBUTE_UPSERTED_V2)
            ATTRIBUTE_DELETED_V2 = 'attribute_deleted_v2' unless defined?(ATTRIBUTE_DELETED_V2)
            CATALOG_UPSERTED = 'catalog_upserted' unless defined?(CATALOG_UPSERTED)
            CATALOG_DELETED = 'catalog_deleted' unless defined?(CATALOG_DELETED)
            SUBCATALOG_UPSERTED = 'subcatalog_upserted' unless defined?(SUBCATALOG_UPSERTED)
            SUBCATALOG_DELETED = 'subcatalog_deleted' unless defined?(SUBCATALOG_DELETED)
            CATALOG_ITEM_UPSERTED = 'catalog_item_upserted' unless defined?(CATALOG_ITEM_UPSERTED)
            CATALOG_ITEM_DELETED = 'catalog_item_deleted' unless defined?(CATALOG_ITEM_DELETED)
            CATALOG_ITEM_UPSERTED_V2 = 'catalog_item_upserted_v2' unless defined?(CATALOG_ITEM_UPSERTED_V2)
            CATALOG_ITEM_DELETED_V2 = 'catalog_item_deleted_v2' unless defined?(CATALOG_ITEM_DELETED_V2)
            SUBCATALOG_ITEM_UPSERTED = 'subcatalog_item_upserted' unless defined?(SUBCATALOG_ITEM_UPSERTED)
            SUBCATALOG_ITEM_DELETED = 'subcatalog_item_deleted' unless defined?(SUBCATALOG_ITEM_DELETED)
            B2B_INVOICE_UPSERTED = 'b2b_invoice_upserted' unless defined?(B2B_INVOICE_UPSERTED)
            B2B_INVOICE_DELETED = 'b2b_invoice_deleted' unless defined?(B2B_INVOICE_DELETED)
            B2B_CREDIT_MEMO_UPSERTED = 'b2b_credit_memo_upserted' unless defined?(B2B_CREDIT_MEMO_UPSERTED)
            B2B_CREDIT_MEMO_DELETED = 'b2b_credit_memo_deleted' unless defined?(B2B_CREDIT_MEMO_DELETED)
            CONSUMER_INVOICE_UPSERTED = 'consumer_invoice_upserted' unless defined?(CONSUMER_INVOICE_UPSERTED)
            CONSUMER_INVOICE_DELETED = 'consumer_invoice_deleted' unless defined?(CONSUMER_INVOICE_DELETED)
            CREDIT_MEMO_UPSERTED = 'credit_memo_upserted' unless defined?(CREDIT_MEMO_UPSERTED)
            CREDIT_MEMO_DELETED = 'credit_memo_deleted' unless defined?(CREDIT_MEMO_DELETED)
            CROSSDOCK_SHIPMENT_UPSERTED = 'crossdock_shipment_upserted' unless defined?(CROSSDOCK_SHIPMENT_UPSERTED)
            RATE_DELETED = 'rate_deleted' unless defined?(RATE_DELETED)
            RATE_UPSERTED = 'rate_upserted' unless defined?(RATE_UPSERTED)
            RATE_DELETED_V3 = 'rate_deleted_v3' unless defined?(RATE_DELETED_V3)
            RATE_UPSERTED_V3 = 'rate_upserted_v3' unless defined?(RATE_UPSERTED_V3)
            CUSTOMER_UPSERTED = 'customer_upserted' unless defined?(CUSTOMER_UPSERTED)
            CUSTOMER_DELETED = 'customer_deleted' unless defined?(CUSTOMER_DELETED)
            CUSTOMER_ADDRESS_BOOK_CONTACT_UPSERTED = 'customer_address_book_contact_upserted' unless defined?(CUSTOMER_ADDRESS_BOOK_CONTACT_UPSERTED)
            CUSTOMER_ADDRESS_BOOK_CONTACT_DELETED = 'customer_address_book_contact_deleted' unless defined?(CUSTOMER_ADDRESS_BOOK_CONTACT_DELETED)
            EMAIL_NOTIFICATION_UPSERTED = 'email_notification_upserted' unless defined?(EMAIL_NOTIFICATION_UPSERTED)
            EMAIL_NOTIFICATION_DELETED = 'email_notification_deleted' unless defined?(EMAIL_NOTIFICATION_DELETED)
            AVAILABLE_PROMOTIONS_UPSERTED = 'available_promotions_upserted' unless defined?(AVAILABLE_PROMOTIONS_UPSERTED)
            AVAILABLE_PROMOTIONS_DELETED = 'available_promotions_deleted' unless defined?(AVAILABLE_PROMOTIONS_DELETED)
            AVAILABLE_PROMOTIONS_UPSERTED_V2 = 'available_promotions_upserted_v2' unless defined?(AVAILABLE_PROMOTIONS_UPSERTED_V2)
            AVAILABLE_PROMOTIONS_DELETED_V2 = 'available_promotions_deleted_v2' unless defined?(AVAILABLE_PROMOTIONS_DELETED_V2)
            ALLOCATION_DELETED_V2 = 'allocation_deleted_v2' unless defined?(ALLOCATION_DELETED_V2)
            ALLOCATION_UPSERTED_V2 = 'allocation_upserted_v2' unless defined?(ALLOCATION_UPSERTED_V2)
            CURRENCY_FORMAT_DELETED = 'currency_format_deleted' unless defined?(CURRENCY_FORMAT_DELETED)
            CURRENCY_FORMAT_UPSERTED = 'currency_format_upserted' unless defined?(CURRENCY_FORMAT_UPSERTED)
            EXPERIENCE_DELETED = 'experience_deleted' unless defined?(EXPERIENCE_DELETED)
            EXPERIENCE_UPSERTED = 'experience_upserted' unless defined?(EXPERIENCE_UPSERTED)
            EXPERIENCE_DELETED_V2 = 'experience_deleted_v2' unless defined?(EXPERIENCE_DELETED_V2)
            EXPERIENCE_UPSERTED_V2 = 'experience_upserted_v2' unless defined?(EXPERIENCE_UPSERTED_V2)
            EXPERIENCE_PRICE_BOOK_MAPPING_DELETED = 'experience_price_book_mapping_deleted' unless defined?(EXPERIENCE_PRICE_BOOK_MAPPING_DELETED)
            EXPERIENCE_PRICE_BOOK_MAPPING_UPSERTED = 'experience_price_book_mapping_upserted' unless defined?(EXPERIENCE_PRICE_BOOK_MAPPING_UPSERTED)
            EXPERIENCE_LOGISTICS_SETTINGS_UPSERTED = 'experience_logistics_settings_upserted' unless defined?(EXPERIENCE_LOGISTICS_SETTINGS_UPSERTED)
            EXPERIENCE_LOGISTICS_SETTINGS_DELETED = 'experience_logistics_settings_deleted' unless defined?(EXPERIENCE_LOGISTICS_SETTINGS_DELETED)
            ITEM_MARGIN_DELETED = 'item_margin_deleted' unless defined?(ITEM_MARGIN_DELETED)
            ITEM_MARGIN_UPSERTED = 'item_margin_upserted' unless defined?(ITEM_MARGIN_UPSERTED)
            ITEM_SALES_MARGIN_DELETED = 'item_sales_margin_deleted' unless defined?(ITEM_SALES_MARGIN_DELETED)
            ITEM_SALES_MARGIN_UPSERTED = 'item_sales_margin_upserted' unless defined?(ITEM_SALES_MARGIN_UPSERTED)
            LABEL_FORMAT_DELETED = 'label_format_deleted' unless defined?(LABEL_FORMAT_DELETED)
            LABEL_FORMAT_UPSERTED = 'label_format_upserted' unless defined?(LABEL_FORMAT_UPSERTED)
            ORDER_DELETED = 'order_deleted' unless defined?(ORDER_DELETED)
            ORDER_UPSERTED = 'order_upserted' unless defined?(ORDER_UPSERTED)
            ORDER_DELETED_V2 = 'order_deleted_v2' unless defined?(ORDER_DELETED_V2)
            ORDER_UPSERTED_V2 = 'order_upserted_v2' unless defined?(ORDER_UPSERTED_V2)
            ORDER_IDENTIFIER_DELETED = 'order_identifier_deleted' unless defined?(ORDER_IDENTIFIER_DELETED)
            ORDER_IDENTIFIER_UPSERTED = 'order_identifier_upserted' unless defined?(ORDER_IDENTIFIER_UPSERTED)
            ORDER_IDENTIFIER_DELETED_V2 = 'order_identifier_deleted_v2' unless defined?(ORDER_IDENTIFIER_DELETED_V2)
            ORDER_IDENTIFIER_UPSERTED_V2 = 'order_identifier_upserted_v2' unless defined?(ORDER_IDENTIFIER_UPSERTED_V2)
            ORDER_IDENTIFIER_UPSERTED_V3 = 'order_identifier_upserted_v3' unless defined?(ORDER_IDENTIFIER_UPSERTED_V3)
            PRICING_DELETED = 'pricing_deleted' unless defined?(PRICING_DELETED)
            PRICING_UPSERTED = 'pricing_upserted' unless defined?(PRICING_UPSERTED)
            ORDER_SERVICE_CHANGE_REQUEST = 'order_service_change_request' unless defined?(ORDER_SERVICE_CHANGE_REQUEST)
            FRAUD_STATUS_CHANGED = 'fraud_status_changed' unless defined?(FRAUD_STATUS_CHANGED)
            CENTER_UPSERTED = 'center_upserted' unless defined?(CENTER_UPSERTED)
            CENTER_DELETED = 'center_deleted' unless defined?(CENTER_DELETED)
            SHIPPING_CONFIGURATION_UPSERTED = 'shipping_configuration_upserted' unless defined?(SHIPPING_CONFIGURATION_UPSERTED)
            SHIPPING_CONFIGURATION_DELETED = 'shipping_configuration_deleted' unless defined?(SHIPPING_CONFIGURATION_DELETED)
            TIER_UPSERTED_V2 = 'tier_upserted_v2' unless defined?(TIER_UPSERTED_V2)
            TIER_DELETED_V2 = 'tier_deleted_v2' unless defined?(TIER_DELETED_V2)
            SHIPPING_LANE_UPSERTED = 'shipping_lane_upserted' unless defined?(SHIPPING_LANE_UPSERTED)
            SHIPPING_LANE_DELETED = 'shipping_lane_deleted' unless defined?(SHIPPING_LANE_DELETED)
            SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_UPSERTED = 'shipping_configuration_item_availability_upserted' unless defined?(SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_UPSERTED)
            SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_DELETED = 'shipping_configuration_item_availability_deleted' unless defined?(SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_DELETED)
            SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_UPSERTED = 'shipping_configuration_item_shipping_pricing_upserted' unless defined?(SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_UPSERTED)
            SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_DELETED = 'shipping_configuration_item_shipping_pricing_deleted' unless defined?(SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_DELETED)
            HS6_CODE_UPSERTED = 'hs6_code_upserted' unless defined?(HS6_CODE_UPSERTED)
            HS6_CODE_DELETED = 'hs6_code_deleted' unless defined?(HS6_CODE_DELETED)
            HS10_CODE_UPSERTED = 'hs10_code_upserted' unless defined?(HS10_CODE_UPSERTED)
            HS10_CODE_DELETED = 'hs10_code_deleted' unless defined?(HS10_CODE_DELETED)
            ITEM_ORIGIN_UPSERTED = 'item_origin_upserted' unless defined?(ITEM_ORIGIN_UPSERTED)
            ITEM_ORIGIN_DELETED = 'item_origin_deleted' unless defined?(ITEM_ORIGIN_DELETED)
            HARMONIZED_LANDED_COST_UPSERTED = 'harmonized_landed_cost_upserted' unless defined?(HARMONIZED_LANDED_COST_UPSERTED)
            FULLY_HARMONIZED_ITEM_UPSERTED = 'fully_harmonized_item_upserted' unless defined?(FULLY_HARMONIZED_ITEM_UPSERTED)
            RULE_UPSERTED = 'rule_upserted' unless defined?(RULE_UPSERTED)
            RULE_DELETED = 'rule_deleted' unless defined?(RULE_DELETED)
            SERIAL_UPSERTED = 'serial_upserted' unless defined?(SERIAL_UPSERTED)
            SERIAL_DELETED = 'serial_deleted' unless defined?(SERIAL_DELETED)
            SNAPSHOT_UPSERTED = 'snapshot_upserted' unless defined?(SNAPSHOT_UPSERTED)
            SNAPSHOT_DELETED = 'snapshot_deleted' unless defined?(SNAPSHOT_DELETED)
            LABEL_UPSERTED = 'label_upserted' unless defined?(LABEL_UPSERTED)
            NOTIFICATION_UPSERTED = 'notification_upserted' unless defined?(NOTIFICATION_UPSERTED)
            NOTIFICATION_DELETED = 'notification_deleted' unless defined?(NOTIFICATION_DELETED)
            MANIFESTED_LABEL_UPSERTED = 'manifested_label_upserted' unless defined?(MANIFESTED_LABEL_UPSERTED)
            MANIFESTED_LABEL_DELETED = 'manifested_label_deleted' unless defined?(MANIFESTED_LABEL_DELETED)
            LOCAL_ITEM_UPSERTED = 'local_item_upserted' unless defined?(LOCAL_ITEM_UPSERTED)
            LOCAL_ITEM_DELETED = 'local_item_deleted' unless defined?(LOCAL_ITEM_DELETED)
            CHECKOUT_OPTIN_RESPONSES_UPSERTED = 'checkout_optin_responses_upserted' unless defined?(CHECKOUT_OPTIN_RESPONSES_UPSERTED)
            CHECKOUT_OPTIN_RESPONSES_DELETED = 'checkout_optin_responses_deleted' unless defined?(CHECKOUT_OPTIN_RESPONSES_DELETED)
            BROWSE_OPTIN_RESPONSES_UPSERTED = 'browse_optin_responses_upserted' unless defined?(BROWSE_OPTIN_RESPONSES_UPSERTED)
            BROWSE_OPTIN_RESPONSES_DELETED = 'browse_optin_responses_deleted' unless defined?(BROWSE_OPTIN_RESPONSES_DELETED)
            ORDER_PLACED = 'order_placed' unless defined?(ORDER_PLACED)
            ORDER_PLACED_V2 = 'order_placed_v2' unless defined?(ORDER_PLACED_V2)
            READY_TO_FULFILL = 'ready_to_fulfill' unless defined?(READY_TO_FULFILL)
            MEMBERSHIP_UPSERTED_V2 = 'membership_upserted_v2' unless defined?(MEMBERSHIP_UPSERTED_V2)
            MEMBERSHIP_DELETED_V2 = 'membership_deleted_v2' unless defined?(MEMBERSHIP_DELETED_V2)
            ORGANIZATION_UPSERTED = 'organization_upserted' unless defined?(ORGANIZATION_UPSERTED)
            ORGANIZATION_DELETED = 'organization_deleted' unless defined?(ORGANIZATION_DELETED)
            ORGANIZATION_UPSERTED_V2 = 'organization_upserted_v2' unless defined?(ORGANIZATION_UPSERTED_V2)
            ORGANIZATION_DELETED_V2 = 'organization_deleted_v2' unless defined?(ORGANIZATION_DELETED_V2)
            ORGANIZATION_SHORT_ID_UPSERTED = 'organization_short_id_upserted' unless defined?(ORGANIZATION_SHORT_ID_UPSERTED)
            ORGANIZATION_SHORT_ID_DELETED = 'organization_short_id_deleted' unless defined?(ORGANIZATION_SHORT_ID_DELETED)
            ORGANIZATION_DEFAULT_CONFIGURATIONS_UPSERTED = 'organization_default_configurations_upserted' unless defined?(ORGANIZATION_DEFAULT_CONFIGURATIONS_UPSERTED)
            ORGANIZATION_DEFAULT_CONFIGURATIONS_DELETED = 'organization_default_configurations_deleted' unless defined?(ORGANIZATION_DEFAULT_CONFIGURATIONS_DELETED)
            ECOMMERCE_PLATFORM_UPSERTED = 'ecommerce_platform_upserted' unless defined?(ECOMMERCE_PLATFORM_UPSERTED)
            ECOMMERCE_PLATFORM_DELETED = 'ecommerce_platform_deleted' unless defined?(ECOMMERCE_PLATFORM_DELETED)
            AUTHORIZATION_DELETED_V2 = 'authorization_deleted_v2' unless defined?(AUTHORIZATION_DELETED_V2)
            # Trigger whenever an auth status changes (e.g. from pending to authorized).
            # Common use case is to subscribe to this event to know when an auth is cleared
            # from fraud review.
            AUTHORIZATION_STATUS_CHANGED = 'authorization_status_changed' unless defined?(AUTHORIZATION_STATUS_CHANGED)
            CARD_AUTHORIZATION_UPSERTED_V2 = 'card_authorization_upserted_v2' unless defined?(CARD_AUTHORIZATION_UPSERTED_V2)
            CARD_AUTHORIZATION_DELETED_V2 = 'card_authorization_deleted_v2' unless defined?(CARD_AUTHORIZATION_DELETED_V2)
            ONLINE_AUTHORIZATION_UPSERTED_V2 = 'online_authorization_upserted_v2' unless defined?(ONLINE_AUTHORIZATION_UPSERTED_V2)
            ONLINE_AUTHORIZATION_DELETED_V2 = 'online_authorization_deleted_v2' unless defined?(ONLINE_AUTHORIZATION_DELETED_V2)
            CAPTURE_UPSERTED_V2 = 'capture_upserted_v2' unless defined?(CAPTURE_UPSERTED_V2)
            CAPTURE_DELETED = 'capture_deleted' unless defined?(CAPTURE_DELETED)
            CARD_UPSERTED_V2 = 'card_upserted_v2' unless defined?(CARD_UPSERTED_V2)
            CARD_DELETED = 'card_deleted' unless defined?(CARD_DELETED)
            PAYMENT_UPSERTED = 'payment_upserted' unless defined?(PAYMENT_UPSERTED)
            PAYMENT_DELETED = 'payment_deleted' unless defined?(PAYMENT_DELETED)
            REFUND_UPSERTED_V2 = 'refund_upserted_v2' unless defined?(REFUND_UPSERTED_V2)
            REFUND_DELETED_V2 = 'refund_deleted_v2' unless defined?(REFUND_DELETED_V2)
            REFUND_CAPTURE_UPSERTED_V2 = 'refund_capture_upserted_v2' unless defined?(REFUND_CAPTURE_UPSERTED_V2)
            REVERSAL_UPSERTED = 'reversal_upserted' unless defined?(REVERSAL_UPSERTED)
            REVERSAL_DELETED = 'reversal_deleted' unless defined?(REVERSAL_DELETED)
            CAPTURE_IDENTIFIER_UPSERTED = 'capture_identifier_upserted' unless defined?(CAPTURE_IDENTIFIER_UPSERTED)
            CAPTURE_IDENTIFIER_DELETED = 'capture_identifier_deleted' unless defined?(CAPTURE_IDENTIFIER_DELETED)
            REFUND_IDENTIFIER_UPSERTED = 'refund_identifier_upserted' unless defined?(REFUND_IDENTIFIER_UPSERTED)
            REFUND_IDENTIFIER_DELETED = 'refund_identifier_deleted' unless defined?(REFUND_IDENTIFIER_DELETED)
            VIRTUAL_CARD_CAPTURE_UPSERTED = 'virtual_card_capture_upserted' unless defined?(VIRTUAL_CARD_CAPTURE_UPSERTED)
            VIRTUAL_CARD_CAPTURE_DELETED = 'virtual_card_capture_deleted' unless defined?(VIRTUAL_CARD_CAPTURE_DELETED)
            VIRTUAL_CARD_REFUND_UPSERTED = 'virtual_card_refund_upserted' unless defined?(VIRTUAL_CARD_REFUND_UPSERTED)
            VIRTUAL_CARD_REFUND_DELETED = 'virtual_card_refund_deleted' unless defined?(VIRTUAL_CARD_REFUND_DELETED)
            PRICE_BOOK_UPSERTED = 'price_book_upserted' unless defined?(PRICE_BOOK_UPSERTED)
            PRICE_BOOK_DELETED = 'price_book_deleted' unless defined?(PRICE_BOOK_DELETED)
            PRICE_BOOK_ITEM_UPSERTED = 'price_book_item_upserted' unless defined?(PRICE_BOOK_ITEM_UPSERTED)
            PRICE_BOOK_ITEM_DELETED = 'price_book_item_deleted' unless defined?(PRICE_BOOK_ITEM_DELETED)
            ORGANIZATION_RATES_PUBLISHED = 'organization_rates_published' unless defined?(ORGANIZATION_RATES_PUBLISHED)
            RATECARD_LANE_UPSERTED = 'ratecard_lane_upserted' unless defined?(RATECARD_LANE_UPSERTED)
            RATECARD_LANE_DELETED = 'ratecard_lane_deleted' unless defined?(RATECARD_LANE_DELETED)
            RATECARD_UPSERTED = 'ratecard_upserted' unless defined?(RATECARD_UPSERTED)
            RATECARD_DELETED = 'ratecard_deleted' unless defined?(RATECARD_DELETED)
            RETURN_UPSERTED = 'return_upserted' unless defined?(RETURN_UPSERTED)
            RETURN_DELETED = 'return_deleted' unless defined?(RETURN_DELETED)
            SHOPIFY_LOCALIZATION_SETTING_UPSERTED = 'shopify_localization_setting_upserted' unless defined?(SHOPIFY_LOCALIZATION_SETTING_UPSERTED)
            SHOPIFY_LOCALIZATION_SETTING_DELETED = 'shopify_localization_setting_deleted' unless defined?(SHOPIFY_LOCALIZATION_SETTING_DELETED)
            TARGETING_ITEM_UPSERTED = 'targeting_item_upserted' unless defined?(TARGETING_ITEM_UPSERTED)
            TARGETING_ITEM_UPSERTED_V2 = 'targeting_item_upserted_v2' unless defined?(TARGETING_ITEM_UPSERTED_V2)
            TARGETING_ITEM_DELETED = 'targeting_item_deleted' unless defined?(TARGETING_ITEM_DELETED)
            TARGETING_ITEM_DELETED_V3 = 'targeting_item_deleted_v3' unless defined?(TARGETING_ITEM_DELETED_V3)
            TRACKING_LABEL_EVENT_UPSERTED = 'tracking_label_event_upserted' unless defined?(TRACKING_LABEL_EVENT_UPSERTED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Event')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of event directly - must use one of the specific types: attribute_upserted, attribute_deleted, attribute_upserted_v2, attribute_deleted_v2, catalog_upserted, catalog_deleted, subcatalog_upserted, subcatalog_deleted, catalog_item_upserted, catalog_item_deleted, catalog_item_upserted_v2, catalog_item_deleted_v2, subcatalog_item_upserted, subcatalog_item_deleted, b2b_invoice_upserted, b2b_invoice_deleted, b2b_credit_memo_upserted, b2b_credit_memo_deleted, consumer_invoice_upserted, consumer_invoice_deleted, credit_memo_upserted, credit_memo_deleted, crossdock_shipment_upserted, rate_deleted, rate_upserted, rate_deleted_v3, rate_upserted_v3, customer_upserted, customer_deleted, customer_address_book_contact_upserted, customer_address_book_contact_deleted, email_notification_upserted, email_notification_deleted, available_promotions_upserted, available_promotions_deleted, available_promotions_upserted_v2, available_promotions_deleted_v2, allocation_deleted_v2, allocation_upserted_v2, currency_format_deleted, currency_format_upserted, experience_deleted, experience_upserted, experience_deleted_v2, experience_upserted_v2, experience_price_book_mapping_deleted, experience_price_book_mapping_upserted, experience_logistics_settings_upserted, experience_logistics_settings_deleted, item_margin_deleted, item_margin_upserted, item_sales_margin_deleted, item_sales_margin_upserted, label_format_deleted, label_format_upserted, order_deleted, order_upserted, order_deleted_v2, order_upserted_v2, order_identifier_deleted, order_identifier_upserted, order_identifier_deleted_v2, order_identifier_upserted_v2, order_identifier_upserted_v3, pricing_deleted, pricing_upserted, order_service_change_request, fraud_status_changed, center_upserted, center_deleted, shipping_configuration_upserted, shipping_configuration_deleted, tier_upserted_v2, tier_deleted_v2, shipping_lane_upserted, shipping_lane_deleted, shipping_configuration_item_availability_upserted, shipping_configuration_item_availability_deleted, shipping_configuration_item_shipping_pricing_upserted, shipping_configuration_item_shipping_pricing_deleted, hs6_code_upserted, hs6_code_deleted, hs10_code_upserted, hs10_code_deleted, item_origin_upserted, item_origin_deleted, harmonized_landed_cost_upserted, fully_harmonized_item_upserted, rule_upserted, rule_deleted, serial_upserted, serial_deleted, snapshot_upserted, snapshot_deleted, label_upserted, notification_upserted, notification_deleted, manifested_label_upserted, manifested_label_deleted, local_item_upserted, local_item_deleted, checkout_optin_responses_upserted, checkout_optin_responses_deleted, browse_optin_responses_upserted, browse_optin_responses_deleted, order_placed, order_placed_v2, ready_to_fulfill, membership_upserted_v2, membership_deleted_v2, organization_upserted, organization_deleted, organization_upserted_v2, organization_deleted_v2, organization_short_id_upserted, organization_short_id_deleted, organization_default_configurations_upserted, organization_default_configurations_deleted, ecommerce_platform_upserted, ecommerce_platform_deleted, authorization_deleted_v2, authorization_status_changed, card_authorization_upserted_v2, card_authorization_deleted_v2, online_authorization_upserted_v2, online_authorization_deleted_v2, capture_upserted_v2, capture_deleted, card_upserted_v2, card_deleted, payment_upserted, payment_deleted, refund_upserted_v2, refund_deleted_v2, refund_capture_upserted_v2, reversal_upserted, reversal_deleted, capture_identifier_upserted, capture_identifier_deleted, refund_identifier_upserted, refund_identifier_deleted, virtual_card_capture_upserted, virtual_card_capture_deleted, virtual_card_refund_upserted, virtual_card_refund_deleted, price_book_upserted, price_book_deleted, price_book_item_upserted, price_book_item_deleted, organization_rates_published, ratecard_lane_upserted, ratecard_lane_deleted, ratecard_upserted, ratecard_deleted, return_upserted, return_deleted, shopify_localization_setting_upserted, shopify_localization_setting_deleted, targeting_item_upserted, targeting_item_upserted_v2, targeting_item_deleted, targeting_item_deleted_v3, tracking_label_event_upserted'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Event.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[event] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ATTRIBUTE_UPSERTED; AttributeUpserted.new(hash)
              when Types::ATTRIBUTE_DELETED; AttributeDeleted.new(hash)
              when Types::ATTRIBUTE_UPSERTED_V2; AttributeUpsertedV2.new(hash)
              when Types::ATTRIBUTE_DELETED_V2; AttributeDeletedV2.new(hash)
              when Types::CATALOG_UPSERTED; CatalogUpserted.new(hash)
              when Types::CATALOG_DELETED; CatalogDeleted.new(hash)
              when Types::SUBCATALOG_UPSERTED; SubcatalogUpserted.new(hash)
              when Types::SUBCATALOG_DELETED; SubcatalogDeleted.new(hash)
              when Types::CATALOG_ITEM_UPSERTED; CatalogItemUpserted.new(hash)
              when Types::CATALOG_ITEM_DELETED; CatalogItemDeleted.new(hash)
              when Types::CATALOG_ITEM_UPSERTED_V2; CatalogItemUpsertedV2.new(hash)
              when Types::CATALOG_ITEM_DELETED_V2; CatalogItemDeletedV2.new(hash)
              when Types::SUBCATALOG_ITEM_UPSERTED; SubcatalogItemUpserted.new(hash)
              when Types::SUBCATALOG_ITEM_DELETED; SubcatalogItemDeleted.new(hash)
              when Types::B2B_INVOICE_UPSERTED; B2bInvoiceUpserted.new(hash)
              when Types::B2B_INVOICE_DELETED; B2bInvoiceDeleted.new(hash)
              when Types::B2B_CREDIT_MEMO_UPSERTED; B2bCreditMemoUpserted.new(hash)
              when Types::B2B_CREDIT_MEMO_DELETED; B2bCreditMemoDeleted.new(hash)
              when Types::CONSUMER_INVOICE_UPSERTED; ConsumerInvoiceUpserted.new(hash)
              when Types::CONSUMER_INVOICE_DELETED; ConsumerInvoiceDeleted.new(hash)
              when Types::CREDIT_MEMO_UPSERTED; CreditMemoUpserted.new(hash)
              when Types::CREDIT_MEMO_DELETED; CreditMemoDeleted.new(hash)
              when Types::CROSSDOCK_SHIPMENT_UPSERTED; CrossdockShipmentUpserted.new(hash)
              when Types::RATE_DELETED; RateDeleted.new(hash)
              when Types::RATE_UPSERTED; RateUpserted.new(hash)
              when Types::RATE_DELETED_V3; RateDeletedV3.new(hash)
              when Types::RATE_UPSERTED_V3; RateUpsertedV3.new(hash)
              when Types::CUSTOMER_UPSERTED; CustomerUpserted.new(hash)
              when Types::CUSTOMER_DELETED; CustomerDeleted.new(hash)
              when Types::CUSTOMER_ADDRESS_BOOK_CONTACT_UPSERTED; CustomerAddressBookContactUpserted.new(hash)
              when Types::CUSTOMER_ADDRESS_BOOK_CONTACT_DELETED; CustomerAddressBookContactDeleted.new(hash)
              when Types::EMAIL_NOTIFICATION_UPSERTED; EmailNotificationUpserted.new(hash)
              when Types::EMAIL_NOTIFICATION_DELETED; EmailNotificationDeleted.new(hash)
              when Types::AVAILABLE_PROMOTIONS_UPSERTED; AvailablePromotionsUpserted.new(hash)
              when Types::AVAILABLE_PROMOTIONS_DELETED; AvailablePromotionsDeleted.new(hash)
              when Types::AVAILABLE_PROMOTIONS_UPSERTED_V2; AvailablePromotionsUpsertedV2.new(hash)
              when Types::AVAILABLE_PROMOTIONS_DELETED_V2; AvailablePromotionsDeletedV2.new(hash)
              when Types::ALLOCATION_DELETED_V2; AllocationDeletedV2.new(hash)
              when Types::ALLOCATION_UPSERTED_V2; AllocationUpsertedV2.new(hash)
              when Types::CURRENCY_FORMAT_DELETED; CurrencyFormatDeleted.new(hash)
              when Types::CURRENCY_FORMAT_UPSERTED; CurrencyFormatUpserted.new(hash)
              when Types::EXPERIENCE_DELETED; ExperienceDeleted.new(hash)
              when Types::EXPERIENCE_UPSERTED; ExperienceUpserted.new(hash)
              when Types::EXPERIENCE_DELETED_V2; ExperienceDeletedV2.new(hash)
              when Types::EXPERIENCE_UPSERTED_V2; ExperienceUpsertedV2.new(hash)
              when Types::EXPERIENCE_PRICE_BOOK_MAPPING_DELETED; ExperiencePriceBookMappingDeleted.new(hash)
              when Types::EXPERIENCE_PRICE_BOOK_MAPPING_UPSERTED; ExperiencePriceBookMappingUpserted.new(hash)
              when Types::EXPERIENCE_LOGISTICS_SETTINGS_UPSERTED; ExperienceLogisticsSettingsUpserted.new(hash)
              when Types::EXPERIENCE_LOGISTICS_SETTINGS_DELETED; ExperienceLogisticsSettingsDeleted.new(hash)
              when Types::ITEM_MARGIN_DELETED; ItemMarginDeleted.new(hash)
              when Types::ITEM_MARGIN_UPSERTED; ItemMarginUpserted.new(hash)
              when Types::ITEM_SALES_MARGIN_DELETED; ItemSalesMarginDeleted.new(hash)
              when Types::ITEM_SALES_MARGIN_UPSERTED; ItemSalesMarginUpserted.new(hash)
              when Types::LABEL_FORMAT_DELETED; LabelFormatDeleted.new(hash)
              when Types::LABEL_FORMAT_UPSERTED; LabelFormatUpserted.new(hash)
              when Types::ORDER_DELETED; OrderDeleted.new(hash)
              when Types::ORDER_UPSERTED; OrderUpserted.new(hash)
              when Types::ORDER_DELETED_V2; OrderDeletedV2.new(hash)
              when Types::ORDER_UPSERTED_V2; OrderUpsertedV2.new(hash)
              when Types::ORDER_IDENTIFIER_DELETED; OrderIdentifierDeleted.new(hash)
              when Types::ORDER_IDENTIFIER_UPSERTED; OrderIdentifierUpserted.new(hash)
              when Types::ORDER_IDENTIFIER_DELETED_V2; OrderIdentifierDeletedV2.new(hash)
              when Types::ORDER_IDENTIFIER_UPSERTED_V2; OrderIdentifierUpsertedV2.new(hash)
              when Types::ORDER_IDENTIFIER_UPSERTED_V3; OrderIdentifierUpsertedV3.new(hash)
              when Types::PRICING_DELETED; PricingDeleted.new(hash)
              when Types::PRICING_UPSERTED; PricingUpserted.new(hash)
              when Types::ORDER_SERVICE_CHANGE_REQUEST; OrderServiceChangeRequest.new(hash)
              when Types::FRAUD_STATUS_CHANGED; FraudStatusChanged.new(hash)
              when Types::CENTER_UPSERTED; CenterUpserted.new(hash)
              when Types::CENTER_DELETED; CenterDeleted.new(hash)
              when Types::SHIPPING_CONFIGURATION_UPSERTED; ShippingConfigurationUpserted.new(hash)
              when Types::SHIPPING_CONFIGURATION_DELETED; ShippingConfigurationDeleted.new(hash)
              when Types::TIER_UPSERTED_V2; TierUpsertedV2.new(hash)
              when Types::TIER_DELETED_V2; TierDeletedV2.new(hash)
              when Types::SHIPPING_LANE_UPSERTED; ShippingLaneUpserted.new(hash)
              when Types::SHIPPING_LANE_DELETED; ShippingLaneDeleted.new(hash)
              when Types::SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_UPSERTED; ShippingConfigurationItemAvailabilityUpserted.new(hash)
              when Types::SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_DELETED; ShippingConfigurationItemAvailabilityDeleted.new(hash)
              when Types::SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_UPSERTED; ShippingConfigurationItemShippingPricingUpserted.new(hash)
              when Types::SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_DELETED; ShippingConfigurationItemShippingPricingDeleted.new(hash)
              when Types::HS6_CODE_UPSERTED; Hs6CodeUpserted.new(hash)
              when Types::HS6_CODE_DELETED; Hs6CodeDeleted.new(hash)
              when Types::HS10_CODE_UPSERTED; Hs10CodeUpserted.new(hash)
              when Types::HS10_CODE_DELETED; Hs10CodeDeleted.new(hash)
              when Types::ITEM_ORIGIN_UPSERTED; ItemOriginUpserted.new(hash)
              when Types::ITEM_ORIGIN_DELETED; ItemOriginDeleted.new(hash)
              when Types::HARMONIZED_LANDED_COST_UPSERTED; HarmonizedLandedCostUpserted.new(hash)
              when Types::FULLY_HARMONIZED_ITEM_UPSERTED; FullyHarmonizedItemUpserted.new(hash)
              when Types::RULE_UPSERTED; RuleUpserted.new(hash)
              when Types::RULE_DELETED; RuleDeleted.new(hash)
              when Types::SERIAL_UPSERTED; SerialUpserted.new(hash)
              when Types::SERIAL_DELETED; SerialDeleted.new(hash)
              when Types::SNAPSHOT_UPSERTED; SnapshotUpserted.new(hash)
              when Types::SNAPSHOT_DELETED; SnapshotDeleted.new(hash)
              when Types::LABEL_UPSERTED; LabelUpserted.new(hash)
              when Types::NOTIFICATION_UPSERTED; NotificationUpserted.new(hash)
              when Types::NOTIFICATION_DELETED; NotificationDeleted.new(hash)
              when Types::MANIFESTED_LABEL_UPSERTED; ManifestedLabelUpserted.new(hash)
              when Types::MANIFESTED_LABEL_DELETED; ManifestedLabelDeleted.new(hash)
              when Types::LOCAL_ITEM_UPSERTED; LocalItemUpserted.new(hash)
              when Types::LOCAL_ITEM_DELETED; LocalItemDeleted.new(hash)
              when Types::CHECKOUT_OPTIN_RESPONSES_UPSERTED; CheckoutOptinResponsesUpserted.new(hash)
              when Types::CHECKOUT_OPTIN_RESPONSES_DELETED; CheckoutOptinResponsesDeleted.new(hash)
              when Types::BROWSE_OPTIN_RESPONSES_UPSERTED; BrowseOptinResponsesUpserted.new(hash)
              when Types::BROWSE_OPTIN_RESPONSES_DELETED; BrowseOptinResponsesDeleted.new(hash)
              when Types::ORDER_PLACED; OrderPlaced.new(hash)
              when Types::ORDER_PLACED_V2; OrderPlacedV2.new(hash)
              when Types::READY_TO_FULFILL; ReadyToFulfill.new(hash)
              when Types::MEMBERSHIP_UPSERTED_V2; MembershipUpsertedV2.new(hash)
              when Types::MEMBERSHIP_DELETED_V2; MembershipDeletedV2.new(hash)
              when Types::ORGANIZATION_UPSERTED; OrganizationUpserted.new(hash)
              when Types::ORGANIZATION_DELETED; OrganizationDeleted.new(hash)
              when Types::ORGANIZATION_UPSERTED_V2; OrganizationUpsertedV2.new(hash)
              when Types::ORGANIZATION_DELETED_V2; OrganizationDeletedV2.new(hash)
              when Types::ORGANIZATION_SHORT_ID_UPSERTED; OrganizationShortIdUpserted.new(hash)
              when Types::ORGANIZATION_SHORT_ID_DELETED; OrganizationShortIdDeleted.new(hash)
              when Types::ORGANIZATION_DEFAULT_CONFIGURATIONS_UPSERTED; OrganizationDefaultConfigurationsUpserted.new(hash)
              when Types::ORGANIZATION_DEFAULT_CONFIGURATIONS_DELETED; OrganizationDefaultConfigurationsDeleted.new(hash)
              when Types::ECOMMERCE_PLATFORM_UPSERTED; EcommercePlatformUpserted.new(hash)
              when Types::ECOMMERCE_PLATFORM_DELETED; EcommercePlatformDeleted.new(hash)
              when Types::AUTHORIZATION_DELETED_V2; AuthorizationDeletedV2.new(hash)
              when Types::AUTHORIZATION_STATUS_CHANGED; AuthorizationStatusChanged.new(hash)
              when Types::CARD_AUTHORIZATION_UPSERTED_V2; CardAuthorizationUpsertedV2.new(hash)
              when Types::CARD_AUTHORIZATION_DELETED_V2; CardAuthorizationDeletedV2.new(hash)
              when Types::ONLINE_AUTHORIZATION_UPSERTED_V2; OnlineAuthorizationUpsertedV2.new(hash)
              when Types::ONLINE_AUTHORIZATION_DELETED_V2; OnlineAuthorizationDeletedV2.new(hash)
              when Types::CAPTURE_UPSERTED_V2; CaptureUpsertedV2.new(hash)
              when Types::CAPTURE_DELETED; CaptureDeleted.new(hash)
              when Types::CARD_UPSERTED_V2; CardUpsertedV2.new(hash)
              when Types::CARD_DELETED; CardDeleted.new(hash)
              when Types::PAYMENT_UPSERTED; PaymentUpserted.new(hash)
              when Types::PAYMENT_DELETED; PaymentDeleted.new(hash)
              when Types::REFUND_UPSERTED_V2; RefundUpsertedV2.new(hash)
              when Types::REFUND_DELETED_V2; RefundDeletedV2.new(hash)
              when Types::REFUND_CAPTURE_UPSERTED_V2; RefundCaptureUpsertedV2.new(hash)
              when Types::REVERSAL_UPSERTED; ReversalUpserted.new(hash)
              when Types::REVERSAL_DELETED; ReversalDeleted.new(hash)
              when Types::CAPTURE_IDENTIFIER_UPSERTED; CaptureIdentifierUpserted.new(hash)
              when Types::CAPTURE_IDENTIFIER_DELETED; CaptureIdentifierDeleted.new(hash)
              when Types::REFUND_IDENTIFIER_UPSERTED; RefundIdentifierUpserted.new(hash)
              when Types::REFUND_IDENTIFIER_DELETED; RefundIdentifierDeleted.new(hash)
              when Types::VIRTUAL_CARD_CAPTURE_UPSERTED; VirtualCardCaptureUpserted.new(hash)
              when Types::VIRTUAL_CARD_CAPTURE_DELETED; VirtualCardCaptureDeleted.new(hash)
              when Types::VIRTUAL_CARD_REFUND_UPSERTED; VirtualCardRefundUpserted.new(hash)
              when Types::VIRTUAL_CARD_REFUND_DELETED; VirtualCardRefundDeleted.new(hash)
              when Types::PRICE_BOOK_UPSERTED; PriceBookUpserted.new(hash)
              when Types::PRICE_BOOK_DELETED; PriceBookDeleted.new(hash)
              when Types::PRICE_BOOK_ITEM_UPSERTED; PriceBookItemUpserted.new(hash)
              when Types::PRICE_BOOK_ITEM_DELETED; PriceBookItemDeleted.new(hash)
              when Types::ORGANIZATION_RATES_PUBLISHED; OrganizationRatesPublished.new(hash)
              when Types::RATECARD_LANE_UPSERTED; RatecardLaneUpserted.new(hash)
              when Types::RATECARD_LANE_DELETED; RatecardLaneDeleted.new(hash)
              when Types::RATECARD_UPSERTED; RatecardUpserted.new(hash)
              when Types::RATECARD_DELETED; RatecardDeleted.new(hash)
              when Types::RETURN_UPSERTED; ReturnUpserted.new(hash)
              when Types::RETURN_DELETED; ReturnDeleted.new(hash)
              when Types::SHOPIFY_LOCALIZATION_SETTING_UPSERTED; ShopifyLocalizationSettingUpserted.new(hash)
              when Types::SHOPIFY_LOCALIZATION_SETTING_DELETED; ShopifyLocalizationSettingDeleted.new(hash)
              when Types::TARGETING_ITEM_UPSERTED; TargetingItemUpserted.new(hash)
              when Types::TARGETING_ITEM_UPSERTED_V2; TargetingItemUpsertedV2.new(hash)
              when Types::TARGETING_ITEM_DELETED; TargetingItemDeleted.new(hash)
              when Types::TARGETING_ITEM_DELETED_V3; TargetingItemDeletedV3.new(hash)
              when Types::TRACKING_LABEL_EVENT_UPSERTED; TrackingLabelEventUpserted.new(hash)
              else EventUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class EventUndefinedType < Event

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableCard

          module Types
            CARD = 'card' unless defined?(CARD)
            CARD_REFERENCE = 'card_reference' unless defined?(CARD_REFERENCE)
            CARD_SUMMARY = 'card_summary' unless defined?(CARD_SUMMARY)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableCard')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_card directly - must use one of the specific types: card, card_reference, card_summary'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableCard.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_card] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CARD; Card.new(hash)
              when Types::CARD_REFERENCE; CardReference.new(hash)
              when Types::CARD_SUMMARY; CardSummary.new(hash)
              else ExpandableCardUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableCardUndefinedType < ExpandableCard

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableCenter

          module Types
            CENTER = 'center' unless defined?(CENTER)
            CENTER_REFERENCE = 'center_reference' unless defined?(CENTER_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableCenter')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_center directly - must use one of the specific types: center, center_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableCenter.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_center] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CENTER; Center.new(hash)
              when Types::CENTER_REFERENCE; CenterReference.new(hash)
              else ExpandableCenterUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableCenterUndefinedType < ExpandableCenter

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableExperience

          module Types
            EXPERIENCE = 'experience' unless defined?(EXPERIENCE)
            EXPERIENCE_REFERENCE = 'experience_reference' unless defined?(EXPERIENCE_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableExperience')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_experience directly - must use one of the specific types: experience, experience_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableExperience.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_experience] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::EXPERIENCE; Experience.new(hash)
              when Types::EXPERIENCE_REFERENCE; ExperienceReference.new(hash)
              else ExpandableExperienceUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableExperienceUndefinedType < ExpandableExperience

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableOrder

          module Types
            ORDER = 'order' unless defined?(ORDER)
            ORDER_REFERENCE = 'order_reference' unless defined?(ORDER_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableOrder')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_order directly - must use one of the specific types: order, order_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableOrder.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_order] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORDER; Order.new(hash)
              when Types::ORDER_REFERENCE; OrderReference.new(hash)
              else ExpandableOrderUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableOrderUndefinedType < ExpandableOrder

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableOrganization

          module Types
            ORGANIZATION = 'organization' unless defined?(ORGANIZATION)
            ORGANIZATION_REFERENCE = 'organization_reference' unless defined?(ORGANIZATION_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableOrganization')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_organization directly - must use one of the specific types: organization, organization_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableOrganization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_organization] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION; Organization.new(hash)
              when Types::ORGANIZATION_REFERENCE; OrganizationReference.new(hash)
              else ExpandableOrganizationUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableOrganizationUndefinedType < ExpandableOrganization

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A subcatalog can be represented with just it's ID, or the entire model
        class ExpandableSubcatalog

          module Types
            SUBCATALOG = 'subcatalog' unless defined?(SUBCATALOG)
            SUBCATALOG_REFERENCE = 'subcatalog_reference' unless defined?(SUBCATALOG_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableSubcatalog')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_subcatalog directly - must use one of the specific types: subcatalog, subcatalog_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableSubcatalog.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_subcatalog] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::SUBCATALOG; Subcatalog.new(hash)
              when Types::SUBCATALOG_REFERENCE; SubcatalogReference.new(hash)
              else ExpandableSubcatalogUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableSubcatalogUndefinedType < ExpandableSubcatalog

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableUser

          module Types
            USER = 'user' unless defined?(USER)
            USER_REFERENCE = 'user_reference' unless defined?(USER_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableUser')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_user directly - must use one of the specific types: user, user_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableUser.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_user] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::USER; User.new(hash)
              when Types::USER_REFERENCE; UserReference.new(hash)
              else ExpandableUserUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableUserUndefinedType < ExpandableUser

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Export deliveries represent actions to take once a requested export has
        # completed. A common pattern would be to request delivery of the export via
        # email - you will then receive an email notification once the requested export
        # is ready
        class ExportDelivery

          module Types
            EXPORT_DELIVERY_EMAIL = 'export_delivery_email' unless defined?(EXPORT_DELIVERY_EMAIL)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExportDelivery')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of export_delivery directly - must use one of the specific types: export_delivery_email'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExportDelivery.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[export_delivery] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::EXPORT_DELIVERY_EMAIL; ExportDeliveryEmail.new(hash)
              else ExportDeliveryUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExportDeliveryUndefinedType < ExportDelivery

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Defines the specific export data that defines which records are exported and
        # into which format
        class ExportType

          module Types
            ACCOUNT_TRANSACTIONS_EXPORT_TYPE = 'account_transactions_export_type' unless defined?(ACCOUNT_TRANSACTIONS_EXPORT_TYPE)
            ACCOUNT_ORDERS_EXPORT_TYPE = 'account_orders_export_type' unless defined?(ACCOUNT_ORDERS_EXPORT_TYPE)
            ANALYTICS_EXPORT_TYPE = 'analytics_export_type' unless defined?(ANALYTICS_EXPORT_TYPE)
            CATALOG_ITEM_EXPORT_TYPE = 'catalog_item_export_type' unless defined?(CATALOG_ITEM_EXPORT_TYPE)
            EXPERIENCE_EXPORT_TYPE = 'experience_export_type' unless defined?(EXPERIENCE_EXPORT_TYPE)
            HARMONIZATION_OVERVIEW_EXPORT_TYPE = 'harmonization_overview_export_type' unless defined?(HARMONIZATION_OVERVIEW_EXPORT_TYPE)
            HARMONIZATION_HS6_EXPORT_TYPE = 'harmonization_hs6_export_type' unless defined?(HARMONIZATION_HS6_EXPORT_TYPE)
            HARMONIZATION_HS10_EXPORT_TYPE = 'harmonization_hs10_export_type' unless defined?(HARMONIZATION_HS10_EXPORT_TYPE)
            UNHARMONIZED_ITEM_EXPORT_TYPE = 'unharmonized_item_export_type' unless defined?(UNHARMONIZED_ITEM_EXPORT_TYPE)
            HARMONIZATION_LANDED_COST_EXPORT_TYPE = 'harmonization_landed_cost_export_type' unless defined?(HARMONIZATION_LANDED_COST_EXPORT_TYPE)
            ORDER_EXPORT_TYPE = 'order_export_type' unless defined?(ORDER_EXPORT_TYPE)
            PRICE_BOOK_ITEM_EXPORT_TYPE = 'price_book_item_export_type' unless defined?(PRICE_BOOK_ITEM_EXPORT_TYPE)
            SOLIDUS_PRODUCT_EXPORT_TYPE = 'solidus_product_export_type' unless defined?(SOLIDUS_PRODUCT_EXPORT_TYPE)
            SOLIDUS_VARIANT_EXPORT_TYPE = 'solidus_variant_export_type' unless defined?(SOLIDUS_VARIANT_EXPORT_TYPE)
            LOCALIZED_ITEM_PRICES_EXPORT_TYPE = 'localized_item_prices_export_type' unless defined?(LOCALIZED_ITEM_PRICES_EXPORT_TYPE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExportType')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of export_type directly - must use one of the specific types: account_transactions_export_type, account_orders_export_type, analytics_export_type, catalog_item_export_type, experience_export_type, harmonization_overview_export_type, harmonization_hs6_export_type, harmonization_hs10_export_type, unharmonized_item_export_type, harmonization_landed_cost_export_type, order_export_type, price_book_item_export_type, solidus_product_export_type, solidus_variant_export_type, localized_item_prices_export_type'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExportType.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[export_type] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ACCOUNT_TRANSACTIONS_EXPORT_TYPE; AccountTransactionsExportType.new(hash)
              when Types::ACCOUNT_ORDERS_EXPORT_TYPE; AccountOrdersExportType.new(hash)
              when Types::ANALYTICS_EXPORT_TYPE; AnalyticsExportType.new(hash)
              when Types::CATALOG_ITEM_EXPORT_TYPE; CatalogItemExportType.new(hash)
              when Types::EXPERIENCE_EXPORT_TYPE; ExperienceExportType.new(hash)
              when Types::HARMONIZATION_OVERVIEW_EXPORT_TYPE; HarmonizationOverviewExportType.new(hash)
              when Types::HARMONIZATION_HS6_EXPORT_TYPE; HarmonizationHs6ExportType.new(hash)
              when Types::HARMONIZATION_HS10_EXPORT_TYPE; HarmonizationHs10ExportType.new(hash)
              when Types::UNHARMONIZED_ITEM_EXPORT_TYPE; UnharmonizedItemExportType.new(hash)
              when Types::HARMONIZATION_LANDED_COST_EXPORT_TYPE; HarmonizationLandedCostExportType.new(hash)
              when Types::ORDER_EXPORT_TYPE; OrderExportType.new(hash)
              when Types::PRICE_BOOK_ITEM_EXPORT_TYPE; PriceBookItemExportType.new(hash)
              when Types::SOLIDUS_PRODUCT_EXPORT_TYPE; SolidusProductExportType.new(hash)
              when Types::SOLIDUS_VARIANT_EXPORT_TYPE; SolidusVariantExportType.new(hash)
              when Types::LOCALIZED_ITEM_PRICES_EXPORT_TYPE; LocalizedItemPricesExportType.new(hash)
              else ExportTypeUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExportTypeUndefinedType < ExportType

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class FieldValidationRule

          module Types
            FIELD_VALIDATION_REQUIRED = 'required' unless defined?(FIELD_VALIDATION_REQUIRED)
            FIELD_VALIDATION_MIN = 'min' unless defined?(FIELD_VALIDATION_MIN)
            FIELD_VALIDATION_MAX = 'max' unless defined?(FIELD_VALIDATION_MAX)
            FIELD_VALIDATION_PATTERN = 'pattern' unless defined?(FIELD_VALIDATION_PATTERN)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'FieldValidationRule')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of field_validation_rule directly - must use one of the specific types: field_validation_required, field_validation_min, field_validation_max, field_validation_pattern'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def FieldValidationRule.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[field_validation_rule] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::FIELD_VALIDATION_REQUIRED; FieldValidationRequired.new(hash)
              when Types::FIELD_VALIDATION_MIN; FieldValidationMin.new(hash)
              when Types::FIELD_VALIDATION_MAX; FieldValidationMax.new(hash)
              when Types::FIELD_VALIDATION_PATTERN; FieldValidationPattern.new(hash)
              else FieldValidationRuleUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class FieldValidationRuleUndefinedType < FieldValidationRule

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # All roles available to attach to a user.
        class FlowRole

          module Types
            FLOW_USER_ROLE = 'flow_user_role' unless defined?(FLOW_USER_ROLE)
            FLOW_ADDON_ROLE = 'flow_addon_role' unless defined?(FLOW_ADDON_ROLE)
          end

          attr_reader :__discriminator__

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @__discriminator__ = opts[:__discriminator__] ||'flow_role'
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of flow_role directly - must use one of the specific types: flow_user_role, flow_addon_role'
          end

          def to_hash
            { @__discriminator__ => subtype_to_hash }
          end

          def FlowRole.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            hash.map do |union_type_name, data|
              case union_type_name
                when Types::FLOW_USER_ROLE; FlowUserRole.new(data)
                when Types::FLOW_ADDON_ROLE; FlowAddonRole.new(data)
                else FlowRoleUndefinedType.new(:__discriminator__ => union_type_name)
              end
            end.first
          end

        end

        class FlowRoleUndefinedType < FlowRole

          attr_reader :name

          def initialize(incoming={})
            super(:__discriminator__ => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:__discriminator__), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class GatewayAuthenticationData

          module Types
            STRIPE_AUTHENTICATION_DATA = 'stripe_authentication_data' unless defined?(STRIPE_AUTHENTICATION_DATA)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'GatewayAuthenticationData')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of gateway_authentication_data directly - must use one of the specific types: stripe_authentication_data'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def GatewayAuthenticationData.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[gateway_authentication_data] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::STRIPE_AUTHENTICATION_DATA; StripeAuthenticationData.new(hash)
              else GatewayAuthenticationDataUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class GatewayAuthenticationDataUndefinedType < GatewayAuthenticationData

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class GatewayAuthenticationDataForm

          module Types
            STRIPE_AUTHENTICATION_DATA_FORM = 'stripe_authentication_data_form' unless defined?(STRIPE_AUTHENTICATION_DATA_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'GatewayAuthenticationDataForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of gateway_authentication_data_form directly - must use one of the specific types: stripe_authentication_data_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def GatewayAuthenticationDataForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[gateway_authentication_data_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::STRIPE_AUTHENTICATION_DATA_FORM; StripeAuthenticationDataForm.new(hash)
              else GatewayAuthenticationDataFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class GatewayAuthenticationDataFormUndefinedType < GatewayAuthenticationDataForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class InputSpecificationLimitation

          module Types
            INPUT_SPECIFICATION_LIMITATION_MAX = 'input_specification_limitation_max' unless defined?(INPUT_SPECIFICATION_LIMITATION_MAX)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'InputSpecificationLimitation')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of input_specification_limitation directly - must use one of the specific types: input_specification_limitation_max'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def InputSpecificationLimitation.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[input_specification_limitation] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::INPUT_SPECIFICATION_LIMITATION_MAX; InputSpecificationLimitationMax.new(hash)
              else InputSpecificationLimitationUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class InputSpecificationLimitationUndefinedType < InputSpecificationLimitation

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Types of rules used to apply on inventory to calculate available quantity
        class InventoryStrategy

          module Types
            # Enables backorders, setting an optional number of units that we allow for
            # backorder. For example, a backorder w/ quantity 10 will enable selling until
            # the actual inventory quantity is -10.
            INVENTORY_BACKORDER = 'inventory_backorder' unless defined?(INVENTORY_BACKORDER)
            # Treats inventory as available as long as the actual inventory quantity is >
            # the specified quantity. A common use case is to set quantity to zero to
            # indicate availability as long as there is at least 1 unit available.
            INVENTORY_STOCK = 'inventory_stock' unless defined?(INVENTORY_STOCK)
            # Items affected with rules pursuing an unlimited strategy will always be
            # available
            INVENTORY_UNLIMITED = 'inventory_unlimited' unless defined?(INVENTORY_UNLIMITED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'InventoryStrategy')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of inventory_strategy directly - must use one of the specific types: inventory_backorder, inventory_stock, inventory_unlimited'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def InventoryStrategy.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[inventory_strategy] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::INVENTORY_BACKORDER; InventoryBackorder.new(hash)
              when Types::INVENTORY_STOCK; InventoryStock.new(hash)
              when Types::INVENTORY_UNLIMITED; InventoryUnlimited.new(hash)
              else InventoryStrategyUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class InventoryStrategyUndefinedType < InventoryStrategy

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # The localized prices for an item are returned as a list - the key of each
        # element is defined here
        class LocalizedPrice

          module Types
            LOCALIZED_ITEM_PRICE = 'localized_item_price' unless defined?(LOCALIZED_ITEM_PRICE)
            LOCALIZED_ITEM_VAT = 'localized_item_vat' unless defined?(LOCALIZED_ITEM_VAT)
            LOCALIZED_ITEM_DUTY = 'localized_item_duty' unless defined?(LOCALIZED_ITEM_DUTY)
            LOCALIZED_TOTAL = 'localized_total' unless defined?(LOCALIZED_TOTAL)
          end

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'LocalizedPrice')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of localized_price directly - must use one of the specific types: localized_item_price, localized_item_vat, localized_item_duty, localized_total'
          end

          def to_hash
            subtype_to_hash.merge(:key => @key)
          end

          def LocalizedPrice.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:key].to_s.strip
            if discriminator.empty?
              raise "Union type[localized_price] requires a field named 'key'"
            end
            case discriminator
              when Types::LOCALIZED_ITEM_PRICE; LocalizedItemPrice.new(hash)
              when Types::LOCALIZED_ITEM_VAT; LocalizedItemVat.new(hash)
              when Types::LOCALIZED_ITEM_DUTY; LocalizedItemDuty.new(hash)
              when Types::LOCALIZED_TOTAL; LocalizedTotal.new(hash)
              else LocalizedPriceUndefinedType.new(:key => discriminator)
            end
          end

        end

        class LocalizedPriceUndefinedType < LocalizedPrice

          attr_reader :name

          def initialize(incoming={})
            super(:key => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:key), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class OnlineAuthorizationDetails

          module Types
            PAYPAL_AUTHORIZATION_DETAILS = 'paypal_authorization_details' unless defined?(PAYPAL_AUTHORIZATION_DETAILS)
            REDIRECT_AUTHORIZATION_DETAILS = 'redirect_authorization_details' unless defined?(REDIRECT_AUTHORIZATION_DETAILS)
            INLINE_AUTHORIZATION_DETAILS = 'inline_authorization_details' unless defined?(INLINE_AUTHORIZATION_DETAILS)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'OnlineAuthorizationDetails')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of online_authorization_details directly - must use one of the specific types: paypal_authorization_details, redirect_authorization_details, inline_authorization_details'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def OnlineAuthorizationDetails.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[online_authorization_details] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::PAYPAL_AUTHORIZATION_DETAILS; PaypalAuthorizationDetails.new(hash)
              when Types::REDIRECT_AUTHORIZATION_DETAILS; RedirectAuthorizationDetails.new(hash)
              when Types::INLINE_AUTHORIZATION_DETAILS; InlineAuthorizationDetails.new(hash)
              else OnlineAuthorizationDetailsUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class OnlineAuthorizationDetailsUndefinedType < OnlineAuthorizationDetails

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class OrderNumberGenerator

          module Types
            ORDER_NUMBER_GENERATOR_UUID = 'uuid' unless defined?(ORDER_NUMBER_GENERATOR_UUID)
            ORDER_NUMBER_GENERATOR_HEXADECIMAL = 'hexadecimal' unless defined?(ORDER_NUMBER_GENERATOR_HEXADECIMAL)
            ORDER_NUMBER_GENERATOR_PREFIX_SUFFIX = 'prefix_suffix' unless defined?(ORDER_NUMBER_GENERATOR_PREFIX_SUFFIX)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'OrderNumberGenerator')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of order_number_generator directly - must use one of the specific types: order_number_generator_uuid, order_number_generator_hexadecimal, order_number_generator_prefix_suffix'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def OrderNumberGenerator.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[order_number_generator] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORDER_NUMBER_GENERATOR_UUID; OrderNumberGeneratorUuid.new(hash)
              when Types::ORDER_NUMBER_GENERATOR_HEXADECIMAL; OrderNumberGeneratorHexadecimal.new(hash)
              when Types::ORDER_NUMBER_GENERATOR_PREFIX_SUFFIX; OrderNumberGeneratorPrefixSuffix.new(hash)
              else OrderNumberGeneratorUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class OrderNumberGeneratorUndefinedType < OrderNumberGenerator

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class OrderPromotion

          module Types
            FREE_SHIPPING_ORDER_PROMOTION = 'free_shipping_order_promotion' unless defined?(FREE_SHIPPING_ORDER_PROMOTION)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'OrderPromotion')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of order_promotion directly - must use one of the specific types: free_shipping_order_promotion'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def OrderPromotion.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[order_promotion] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::FREE_SHIPPING_ORDER_PROMOTION; FreeShippingOrderPromotion.new(hash)
              else OrderPromotionUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class OrderPromotionUndefinedType < OrderPromotion

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class OrderPromotionForm

          module Types
            FREE_SHIPPING_ORDER_PROMOTION_FORM = 'free_shipping_order_promotion_form' unless defined?(FREE_SHIPPING_ORDER_PROMOTION_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'OrderPromotionForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of order_promotion_form directly - must use one of the specific types: free_shipping_order_promotion_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def OrderPromotionForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[order_promotion_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::FREE_SHIPPING_ORDER_PROMOTION_FORM; FreeShippingOrderPromotionForm.new(hash)
              else OrderPromotionFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class OrderPromotionFormUndefinedType < OrderPromotionForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class PartnerCenterFee

          module Types
            COMMERCIAL_INVOICE_FEE = 'commercial_invoice_fee' unless defined?(COMMERCIAL_INVOICE_FEE)
            INBOUND_CARTON_FEE = 'inbound_carton_fee' unless defined?(INBOUND_CARTON_FEE)
            OUTBOUND_CARTON_FEE = 'outbound_carton_fee' unless defined?(OUTBOUND_CARTON_FEE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'PartnerCenterFee')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of partner_center_fee directly - must use one of the specific types: commercial_invoice_fee, inbound_carton_fee, outbound_carton_fee'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def PartnerCenterFee.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[partner_center_fee] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::COMMERCIAL_INVOICE_FEE; CommercialInvoiceFee.new(hash)
              when Types::INBOUND_CARTON_FEE; InboundCartonFee.new(hash)
              when Types::OUTBOUND_CARTON_FEE; OutboundCartonFee.new(hash)
              else PartnerCenterFeeUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PartnerCenterFeeUndefinedType < PartnerCenterFee

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Represents data for a specific online payment method
        class Payment

          module Types
            PAYMENT_PAYPAL = 'payment_paypal' unless defined?(PAYMENT_PAYPAL)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Payment')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of payment directly - must use one of the specific types: payment_paypal'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Payment.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[payment] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::PAYMENT_PAYPAL; PaymentPaypal.new(hash)
              else PaymentUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PaymentUndefinedType < Payment

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Represents the data needed to initiate an online payment
        class PaymentForm

          module Types
            MERCHANT_OF_RECORD_PAYMENT_FORM = 'merchant_of_record_payment_form' unless defined?(MERCHANT_OF_RECORD_PAYMENT_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'PaymentForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of payment_form directly - must use one of the specific types: merchant_of_record_payment_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def PaymentForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[payment_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::MERCHANT_OF_RECORD_PAYMENT_FORM; MerchantOfRecordPaymentForm.new(hash)
              else PaymentFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PaymentFormUndefinedType < PaymentForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class PaymentMethodTag

          module Types
            ORGANIZATION_PAYMENT_METHOD_TAG = 'organization_payment_method_tag' unless defined?(ORGANIZATION_PAYMENT_METHOD_TAG)
            EXPERIENCE_PAYMENT_METHOD_TAG = 'experience_payment_method_tag' unless defined?(EXPERIENCE_PAYMENT_METHOD_TAG)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'PaymentMethodTag')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of payment_method_tag directly - must use one of the specific types: organization_payment_method_tag, experience_payment_method_tag'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def PaymentMethodTag.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[payment_method_tag] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_PAYMENT_METHOD_TAG; OrganizationPaymentMethodTag.new(hash)
              when Types::EXPERIENCE_PAYMENT_METHOD_TAG; ExperiencePaymentMethodTag.new(hash)
              else PaymentMethodTagUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PaymentMethodTagUndefinedType < PaymentMethodTag

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Represents a source of payment that can be saved and used in the future.
        class PaymentSource

          module Types
            CARD_PAYMENT_SOURCE = 'card_payment_source' unless defined?(CARD_PAYMENT_SOURCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'PaymentSource')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of payment_source directly - must use one of the specific types: card_payment_source'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def PaymentSource.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[payment_source] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CARD_PAYMENT_SOURCE; CardPaymentSource.new(hash)
              else PaymentSourceUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PaymentSourceUndefinedType < PaymentSource

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class PaymentSourceForm

          module Types
            CARD_PAYMENT_SOURCE_FORM = 'card_payment_source_form' unless defined?(CARD_PAYMENT_SOURCE_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'PaymentSourceForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of payment_source_form directly - must use one of the specific types: card_payment_source_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def PaymentSourceForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[payment_source_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CARD_PAYMENT_SOURCE_FORM; CardPaymentSourceForm.new(hash)
              else PaymentSourceFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PaymentSourceFormUndefinedType < PaymentSourceForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class PriceSource

          module Types
            PRICE_SOURCE_PRICE_BOOK = 'price_book' unless defined?(PRICE_SOURCE_PRICE_BOOK)
            PRICE_SOURCE_CATALOG = 'catalog' unless defined?(PRICE_SOURCE_CATALOG)
            PRICE_SOURCE_PROVIDED = 'provided' unless defined?(PRICE_SOURCE_PROVIDED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'PriceSource')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of price_source directly - must use one of the specific types: price_source_price_book, price_source_catalog, price_source_provided'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def PriceSource.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[price_source] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::PRICE_SOURCE_PRICE_BOOK; PriceSourcePriceBook.new(hash)
              when Types::PRICE_SOURCE_CATALOG; PriceSourceCatalog.new(hash)
              when Types::PRICE_SOURCE_PROVIDED; PriceSourceProvided.new(hash)
              else PriceSourceUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PriceSourceUndefinedType < PriceSource

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Promotion

          module Types
            FREE_SHIPPING = 'free_shipping' unless defined?(FREE_SHIPPING)
            DISCOUNT = 'discount' unless defined?(DISCOUNT)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Promotion')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of promotion directly - must use one of the specific types: free_shipping, discount'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Promotion.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[promotion] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::FREE_SHIPPING; FreeShipping.new(hash)
              when Types::DISCOUNT; Discount.new(hash)
              else PromotionUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PromotionUndefinedType < Promotion

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class QueryBuilderForm

          module Types
            QUERY_BUILDER_FILTER_FORM = 'filter' unless defined?(QUERY_BUILDER_FILTER_FORM)
            QUERY_BUILDER_QUERY_FORM = 'query' unless defined?(QUERY_BUILDER_QUERY_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'QueryBuilderForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of query_builder_form directly - must use one of the specific types: query_builder_filter_form, query_builder_query_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def QueryBuilderForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[query_builder_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::QUERY_BUILDER_FILTER_FORM; QueryBuilderFilterForm.new(hash)
              when Types::QUERY_BUILDER_QUERY_FORM; QueryBuilderQueryForm.new(hash)
              else QueryBuilderFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class QueryBuilderFormUndefinedType < QueryBuilderForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class QueryFilter

          module Types
            QUERY_FILTER_STRUCTURED = 'structured' unless defined?(QUERY_FILTER_STRUCTURED)
            QUERY_FILTER_UNSTRUCTURED = 'unstructured' unless defined?(QUERY_FILTER_UNSTRUCTURED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'query_filter_structured', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of query_filter directly - must use one of the specific types: query_filter_structured, query_filter_unstructured'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def QueryFilter.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[query_filter] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::QUERY_FILTER_STRUCTURED; QueryFilterStructured.new(hash)
              when Types::QUERY_FILTER_UNSTRUCTURED; QueryFilterUnstructured.new(hash)
              else QueryFilterUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class QueryFilterUndefinedType < QueryFilter

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class QueryFilterForm

          module Types
            QUERY_FILTER_STRUCTURED_FORM = 'structured' unless defined?(QUERY_FILTER_STRUCTURED_FORM)
            QUERY_FILTER_UNSTRUCTURED_FORM = 'unstructured' unless defined?(QUERY_FILTER_UNSTRUCTURED_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'query_filter_structured_form', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of query_filter_form directly - must use one of the specific types: query_filter_structured_form, query_filter_unstructured_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def QueryFilterForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[query_filter_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::QUERY_FILTER_STRUCTURED_FORM; QueryFilterStructuredForm.new(hash)
              when Types::QUERY_FILTER_UNSTRUCTURED_FORM; QueryFilterUnstructuredForm.new(hash)
              else QueryFilterFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class QueryFilterFormUndefinedType < QueryFilterForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class RatecardEstimate

          module Types
            RATECARD_ESTIMATE_V1 = 'ratecard_estimate_v1' unless defined?(RATECARD_ESTIMATE_V1)
            RATECARD_ESTIMATE_V2 = 'ratecard_estimate_v2' unless defined?(RATECARD_ESTIMATE_V2)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'ratecard_estimate_v1', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of ratecard_estimate directly - must use one of the specific types: ratecard_estimate_v1, ratecard_estimate_v2'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def RatecardEstimate.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[ratecard_estimate] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::RATECARD_ESTIMATE_V1; RatecardEstimateV1.new(hash)
              when Types::RATECARD_ESTIMATE_V2; RatecardEstimateV2.new(hash)
              else RatecardEstimateUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class RatecardEstimateUndefinedType < RatecardEstimate

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class RatecardEstimateForm

          module Types
            RATECARD_ESTIMATE_FORM_V1 = 'ratecard_estimate_form_v1' unless defined?(RATECARD_ESTIMATE_FORM_V1)
            RATECARD_ESTIMATE_FORM_V2 = 'ratecard_estimate_form_v2' unless defined?(RATECARD_ESTIMATE_FORM_V2)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'ratecard_estimate_form_v1', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of ratecard_estimate_form directly - must use one of the specific types: ratecard_estimate_form_v1, ratecard_estimate_form_v2'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def RatecardEstimateForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[ratecard_estimate_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::RATECARD_ESTIMATE_FORM_V1; RatecardEstimateFormV1.new(hash)
              when Types::RATECARD_ESTIMATE_FORM_V2; RatecardEstimateFormV2.new(hash)
              else RatecardEstimateFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class RatecardEstimateFormUndefinedType < RatecardEstimateForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class RatecardFee

          module Types
            DDP_RATECARD_FEE = 'ddp_ratecard_fee' unless defined?(DDP_RATECARD_FEE)
            FUEL_SURCHARGE_RATECARD_FEE = 'fuel_surcharge_ratecard_fee' unless defined?(FUEL_SURCHARGE_RATECARD_FEE)
            OVERSIZED_SHIPMENT_RATECARD_FEE = 'oversized_shipment_ratecard_fee' unless defined?(OVERSIZED_SHIPMENT_RATECARD_FEE)
            RETURN_PACKAGE_RATECARD_FEE = 'return_package_ratecard_fee' unless defined?(RETURN_PACKAGE_RATECARD_FEE)
            CROSSDOCK_RATECARD_FEE = 'crossdock_ratecard_fee' unless defined?(CROSSDOCK_RATECARD_FEE)
            REMOTE_AREA_RATECARD_FEE = 'remote_area_ratecard_fee' unless defined?(REMOTE_AREA_RATECARD_FEE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'RatecardFee')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of ratecard_fee directly - must use one of the specific types: ddp_ratecard_fee, fuel_surcharge_ratecard_fee, oversized_shipment_ratecard_fee, return_package_ratecard_fee, crossdock_ratecard_fee, remote_area_ratecard_fee'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def RatecardFee.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[ratecard_fee] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DDP_RATECARD_FEE; DdpRatecardFee.new(hash)
              when Types::FUEL_SURCHARGE_RATECARD_FEE; FuelSurchargeRatecardFee.new(hash)
              when Types::OVERSIZED_SHIPMENT_RATECARD_FEE; OversizedShipmentRatecardFee.new(hash)
              when Types::RETURN_PACKAGE_RATECARD_FEE; ReturnPackageRatecardFee.new(hash)
              when Types::CROSSDOCK_RATECARD_FEE; CrossdockRatecardFee.new(hash)
              when Types::REMOTE_AREA_RATECARD_FEE; RemoteAreaRatecardFee.new(hash)
              else RatecardFeeUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class RatecardFeeUndefinedType < RatecardFee

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class RepeatSchedule

          module Types
            REPEAT_HOURLY = 'repeat_hourly' unless defined?(REPEAT_HOURLY)
            REPEAT_DAILY = 'repeat_daily' unless defined?(REPEAT_DAILY)
            REPEAT_WEEKLY = 'repeat_weekly' unless defined?(REPEAT_WEEKLY)
            REPEAT_MONTHLY = 'repeat_monthly' unless defined?(REPEAT_MONTHLY)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'RepeatSchedule')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of repeat_schedule directly - must use one of the specific types: repeat_hourly, repeat_daily, repeat_weekly, repeat_monthly'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def RepeatSchedule.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[repeat_schedule] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::REPEAT_HOURLY; RepeatHourly.new(hash)
              when Types::REPEAT_DAILY; RepeatDaily.new(hash)
              when Types::REPEAT_WEEKLY; RepeatWeekly.new(hash)
              when Types::REPEAT_MONTHLY; RepeatMonthly.new(hash)
              else RepeatScheduleUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class RepeatScheduleUndefinedType < RepeatSchedule

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Types of failed inventory reservation reasons
        class ReservationError

          module Types
            # Inventory is not available for all or subset of item quantities requested
            NO_INVENTORY_RESERVATION_ERROR = 'no_inventory' unless defined?(NO_INVENTORY_RESERVATION_ERROR)
            # API call to external API (ex: PFS) timed out
            EXTERNAL_API_TIMEOUT_RESERVATION_ERROR = 'external_api_timeout' unless defined?(EXTERNAL_API_TIMEOUT_RESERVATION_ERROR)
            # Generic reservation error
            GENERIC_RESERVATION_ERROR = 'generic_reservation_error' unless defined?(GENERIC_RESERVATION_ERROR)
          end

          attr_reader :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'ReservationError')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of reservation_error directly - must use one of the specific types: no_inventory_reservation_error, external_api_timeout_reservation_error, generic_reservation_error'
          end

          def to_hash
            subtype_to_hash.merge(:code => @code)
          end

          def ReservationError.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:code].to_s.strip
            if discriminator.empty?
              raise "Union type[reservation_error] requires a field named 'code'"
            end
            case discriminator
              when Types::NO_INVENTORY_RESERVATION_ERROR; NoInventoryReservationError.new(hash)
              when Types::EXTERNAL_API_TIMEOUT_RESERVATION_ERROR; ExternalApiTimeoutReservationError.new(hash)
              when Types::GENERIC_RESERVATION_ERROR; GenericReservationError.new(hash)
              else ReservationErrorUndefinedType.new(:code => discriminator)
            end
          end

        end

        class ReservationErrorUndefinedType < ReservationError

          attr_reader :name

          def initialize(incoming={})
            super(:code => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:code), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ServiceFee

          module Types
            FUEL_SURCHARGE_SERVICE_FEE = 'fuel_surcharge_service_fee' unless defined?(FUEL_SURCHARGE_SERVICE_FEE)
            REMOTE_AREA_SERVICE_FEE = 'remote_area_service_fee' unless defined?(REMOTE_AREA_SERVICE_FEE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ServiceFee')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of service_fee directly - must use one of the specific types: fuel_surcharge_service_fee, remote_area_service_fee'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ServiceFee.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[service_fee] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::FUEL_SURCHARGE_SERVICE_FEE; FuelSurchargeServiceFee.new(hash)
              when Types::REMOTE_AREA_SERVICE_FEE; RemoteAreaServiceFee.new(hash)
              else ServiceFeeUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ServiceFeeUndefinedType < ServiceFee

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Session

          module Types
            ORGANIZATION_SESSION = 'organization_session' unless defined?(ORGANIZATION_SESSION)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Session')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of session directly - must use one of the specific types: organization_session'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Session.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[session] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_SESSION; OrganizationSession.new(hash)
              else SessionUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class SessionUndefinedType < Session

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class SessionAuthorization

          module Types
            ORGANIZATION_SESSION_AUTHORIZATION = 'organization_session_authorization' unless defined?(ORGANIZATION_SESSION_AUTHORIZATION)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'SessionAuthorization')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of session_authorization directly - must use one of the specific types: organization_session_authorization'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def SessionAuthorization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[session_authorization] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_SESSION_AUTHORIZATION; OrganizationSessionAuthorization.new(hash)
              else SessionAuthorizationUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class SessionAuthorizationUndefinedType < SessionAuthorization

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Different models for forms to create shipping labels
        class ShippingLabelForm

          module Types
            DETAILED_SHIPPING_LABEL_FORM = 'detailed_shipping_label_form' unless defined?(DETAILED_SHIPPING_LABEL_FORM)
            SUMMARY_SHIPPING_LABEL_FORM = 'summary_shipping_label_form' unless defined?(SUMMARY_SHIPPING_LABEL_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'detailed_shipping_label_form', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of shipping_label_form directly - must use one of the specific types: detailed_shipping_label_form, summary_shipping_label_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ShippingLabelForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[shipping_label_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DETAILED_SHIPPING_LABEL_FORM; DetailedShippingLabelForm.new(hash)
              when Types::SUMMARY_SHIPPING_LABEL_FORM; SummaryShippingLabelForm.new(hash)
              else ShippingLabelFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ShippingLabelFormUndefinedType < ShippingLabelForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Form for information about a client-facilitated shipment where the shipping
        # label and fulfillment was not handled by Flow. For merchant-of-record and
        # tracking purposes, clients doing their own shipping will need to notify Flow
        # of shipped packages.
        class ShippingNotificationForm

          module Types
            DETAILED_SHIPPING_NOTIFICATION_FORM = 'detailed_shipping_notification_form' unless defined?(DETAILED_SHIPPING_NOTIFICATION_FORM)
            SINGLE_PACKAGE_SHIPPING_NOTIFICATION_FORM = 'single_package_shipping_notification_form' unless defined?(SINGLE_PACKAGE_SHIPPING_NOTIFICATION_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'detailed_shipping_notification_form', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of shipping_notification_form directly - must use one of the specific types: detailed_shipping_notification_form, single_package_shipping_notification_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ShippingNotificationForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[shipping_notification_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DETAILED_SHIPPING_NOTIFICATION_FORM; DetailedShippingNotificationForm.new(hash)
              when Types::SINGLE_PACKAGE_SHIPPING_NOTIFICATION_FORM; SinglePackageShippingNotificationForm.new(hash)
              else ShippingNotificationFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ShippingNotificationFormUndefinedType < ShippingNotificationForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ShopifyCartAddForm

          module Types
            SHOPIFY_CART_ADD_SINGLE_FORM = 'shopify_cart_add_single_form' unless defined?(SHOPIFY_CART_ADD_SINGLE_FORM)
            SHOPIFY_CART_ADD_MULTIPLE_FORM = 'shopify_cart_add_multiple_form' unless defined?(SHOPIFY_CART_ADD_MULTIPLE_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'shopify_cart_add_single_form', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of shopify_cart_add_form directly - must use one of the specific types: shopify_cart_add_single_form, shopify_cart_add_multiple_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ShopifyCartAddForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[shopify_cart_add_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::SHOPIFY_CART_ADD_SINGLE_FORM; ShopifyCartAddSingleForm.new(hash)
              when Types::SHOPIFY_CART_ADD_MULTIPLE_FORM; ShopifyCartAddMultipleForm.new(hash)
              else ShopifyCartAddFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ShopifyCartAddFormUndefinedType < ShopifyCartAddForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ShopifyEventBucket

          module Types
            SHOPIFY_ITEM_EVENT_BUCKET = 'shopify_item_event_bucket' unless defined?(SHOPIFY_ITEM_EVENT_BUCKET)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'shopify_item_event_bucket', String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of shopify_event_bucket directly - must use one of the specific types: shopify_item_event_bucket'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ShopifyEventBucket.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[shopify_event_bucket] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::SHOPIFY_ITEM_EVENT_BUCKET; ShopifyItemEventBucket.new(hash)
              else ShopifyEventBucketUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ShopifyEventBucketUndefinedType < ShopifyEventBucket

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class TaxSetting

          module Types
            AVALARA_TAX_SETTING = 'avalara_tax_setting' unless defined?(AVALARA_TAX_SETTING)
            AVALARA_TAX_CSV_SETTING = 'avalara_tax_csv_setting' unless defined?(AVALARA_TAX_CSV_SETTING)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TaxSetting')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of tax_setting directly - must use one of the specific types: avalara_tax_setting, avalara_tax_csv_setting'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TaxSetting.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[tax_setting] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AVALARA_TAX_SETTING; AvalaraTaxSetting.new(hash)
              when Types::AVALARA_TAX_CSV_SETTING; AvalaraTaxCsvSetting.new(hash)
              else TaxSettingUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TaxSettingUndefinedType < TaxSetting

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Possible outcome types from a tier rule
        class TierRuleOutcome

          module Types
            # Add a certain amount on the actual base cost
            AMOUNT_MARGIN = 'amount_margin' unless defined?(AMOUNT_MARGIN)
            AT_COST = 'at_cost' unless defined?(AT_COST)
            FLAT_RATE = 'flat_rate' unless defined?(FLAT_RATE)
            # Add a certain percentage of the actual base cost
            PERCENT_MARGIN = 'percent_margin' unless defined?(PERCENT_MARGIN)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TierRuleOutcome')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of tier_rule_outcome directly - must use one of the specific types: amount_margin, at_cost, flat_rate, percent_margin'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TierRuleOutcome.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[tier_rule_outcome] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AMOUNT_MARGIN; AmountMargin.new(hash)
              when Types::AT_COST; AtCost.new(hash)
              when Types::FLAT_RATE; FlatRate.new(hash)
              when Types::PERCENT_MARGIN; PercentMargin.new(hash)
              else TierRuleOutcomeUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TierRuleOutcomeUndefinedType < TierRuleOutcome

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class TierRuleOutcomeForm

          module Types
            AMOUNT_MARGIN_FORM = 'amount_margin_form' unless defined?(AMOUNT_MARGIN_FORM)
            FLAT_RATE_FORM = 'flat_rate_form' unless defined?(FLAT_RATE_FORM)
            AT_COST = 'at_cost' unless defined?(AT_COST)
            PERCENT_MARGIN = 'percent_margin' unless defined?(PERCENT_MARGIN)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TierRuleOutcomeForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of tier_rule_outcome_form directly - must use one of the specific types: amount_margin_form, flat_rate_form, at_cost, percent_margin'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TierRuleOutcomeForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[tier_rule_outcome_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AMOUNT_MARGIN_FORM; AmountMarginForm.new(hash)
              when Types::FLAT_RATE_FORM; FlatRateForm.new(hash)
              when Types::AT_COST; AtCost.new(hash)
              when Types::PERCENT_MARGIN; PercentMargin.new(hash)
              else TierRuleOutcomeFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TierRuleOutcomeFormUndefinedType < TierRuleOutcomeForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Token

          module Types
            ORGANIZATION_TOKEN = 'organization_token' unless defined?(ORGANIZATION_TOKEN)
            PARTNER_TOKEN = 'partner_token' unless defined?(PARTNER_TOKEN)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Token')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of token directly - must use one of the specific types: organization_token, partner_token'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Token.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[token] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_TOKEN; OrganizationToken.new(hash)
              when Types::PARTNER_TOKEN; PartnerToken.new(hash)
              else TokenUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TokenUndefinedType < Token

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class TokenReference

          module Types
            ORGANIZATION_TOKEN_REFERENCE = 'organization_token_reference' unless defined?(ORGANIZATION_TOKEN_REFERENCE)
            PARTNER_TOKEN_REFERENCE = 'partner_token_reference' unless defined?(PARTNER_TOKEN_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TokenReference')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of token_reference directly - must use one of the specific types: organization_token_reference, partner_token_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TokenReference.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[token_reference] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_TOKEN_REFERENCE; OrganizationTokenReference.new(hash)
              when Types::PARTNER_TOKEN_REFERENCE; PartnerTokenReference.new(hash)
              else TokenReferenceUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TokenReferenceUndefinedType < TokenReference

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AdjustmentReasonKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AdjustmentReasonKey for this value, creating a new instance for an unknown value
          def AdjustmentReasonKey.apply(value)
            if value.instance_of?(AdjustmentReasonKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AdjustmentReasonKey.new(value))
            end
          end

          # Returns the instance of AdjustmentReasonKey for this value, or nil if not found
          def AdjustmentReasonKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AdjustmentReasonKey.ALL.find { |v| v.value == value }
          end

          def AdjustmentReasonKey.ALL
            @@all ||= [AdjustmentReasonKey.duty_deminimis, AdjustmentReasonKey.vat_deminimis]
          end

          # If the duty de minimis value has not been met, an adjustment may be made to
          # offset any previously calculated duty.
          def AdjustmentReasonKey.duty_deminimis
            @@_duty_deminimis ||= AdjustmentReasonKey.new('duty_deminimis')
          end

          # If the VAT de minimis value has not been met, an adjustment may be made to
          # offset any previously calculated VAT.
          def AdjustmentReasonKey.vat_deminimis
            @@_vat_deminimis ||= AdjustmentReasonKey.new('vat_deminimis')
          end

          def to_hash
            value
          end

        end

        class Aggregate

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Aggregate for this value, creating a new instance for an unknown value
          def Aggregate.apply(value)
            if value.instance_of?(Aggregate)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Aggregate.new(value))
            end
          end

          # Returns the instance of Aggregate for this value, or nil if not found
          def Aggregate.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Aggregate.ALL.find { |v| v.value == value }
          end

          def Aggregate.ALL
            @@all ||= [Aggregate.maximum, Aggregate.minimum]
          end

          def Aggregate.maximum
            @@_maximum ||= Aggregate.new('maximum')
          end

          def Aggregate.minimum
            @@_minimum ||= Aggregate.new('minimum')
          end

          def to_hash
            value
          end

        end

        class AttributeDataType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AttributeDataType for this value, creating a new instance for an unknown value
          def AttributeDataType.apply(value)
            if value.instance_of?(AttributeDataType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AttributeDataType.new(value))
            end
          end

          # Returns the instance of AttributeDataType for this value, or nil if not found
          def AttributeDataType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AttributeDataType.ALL.find { |v| v.value == value }
          end

          def AttributeDataType.ALL
            @@all ||= [AttributeDataType.boolean, AttributeDataType.decimal, AttributeDataType.string, AttributeDataType.json_array]
          end

          # Boolean true/false data type
          def AttributeDataType.boolean
            @@_boolean ||= AttributeDataType.new('boolean')
          end

          # Decimal datatype without size or precision restrictions. Commonly used for
          # currency values.
          def AttributeDataType.decimal
            @@_decimal ||= AttributeDataType.new('decimal')
          end

          # Unvalidated string of characters.
          def AttributeDataType.string
            @@_string ||= AttributeDataType.new('string')
          end

          # An example ["Cotton", "Wool"]
          def AttributeDataType.json_array
            @@_json_array ||= AttributeDataType.new('json_array')
          end

          def to_hash
            value
          end

        end

        class AttributeIntent

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AttributeIntent for this value, creating a new instance for an unknown value
          def AttributeIntent.apply(value)
            if value.instance_of?(AttributeIntent)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AttributeIntent.new(value))
            end
          end

          # Returns the instance of AttributeIntent for this value, or nil if not found
          def AttributeIntent.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AttributeIntent.ALL.find { |v| v.value == value }
          end

          def AttributeIntent.ALL
            @@all ||= [AttributeIntent.brand, AttributeIntent.color, AttributeIntent.countries_of_origin, AttributeIntent.product_id, AttributeIntent.fulfillment_method, AttributeIntent.hazardous, AttributeIntent.price, AttributeIntent.size, AttributeIntent.sku, AttributeIntent.taxability, AttributeIntent.consumer_url, AttributeIntent.gtin, AttributeIntent.mpn, AttributeIntent.excluded_regions, AttributeIntent.facet]
          end

          # A brand name of the item (for retailers that sell multiple brands)
          def AttributeIntent.brand
            @@_brand ||= AttributeIntent.new('brand')
          end

          # The color of the item
          def AttributeIntent.color
            @@_color ||= AttributeIntent.new('color')
          end

          # A space separated list of the countries of origin for this item
          def AttributeIntent.countries_of_origin
            @@_countries_of_origin ||= AttributeIntent.new('countries_of_origin')
          end

          # An identifier used to group items that are variations of the same product,
          # such as different sizes or colors of the same shirt
          def AttributeIntent.product_id
            @@_product_id ||= AttributeIntent.new('product_id')
          end

          # Identifies whether the item is a physical or digital good
          def AttributeIntent.fulfillment_method
            @@_fulfillment_method ||= AttributeIntent.new('fulfillment_method')
          end

          # Identifies whether this item may contain hazardous materials
          def AttributeIntent.hazardous
            @@_hazardous ||= AttributeIntent.new('hazardous')
          end

          # A price for the item in the organization's base currency (will be localized
          # based on each Experience's pricing policy)
          def AttributeIntent.price
            @@_price ||= AttributeIntent.new('price')
          end

          # A size label of the item
          def AttributeIntent.size
            @@_size ||= AttributeIntent.new('size')
          end

          # An SKU for the item
          def AttributeIntent.sku
            @@_sku ||= AttributeIntent.new('sku')
          end

          # Identifies whether taxes are applicable to an item
          def AttributeIntent.taxability
            @@_taxability ||= AttributeIntent.new('taxability')
          end

          # A URL of the product detail page of the item
          def AttributeIntent.consumer_url
            @@_consumer_url ||= AttributeIntent.new('consumer_url')
          end

          # The Global Trade Item Number of this item.
          def AttributeIntent.gtin
            @@_gtin ||= AttributeIntent.new('gtin')
          end

          # The Manufacturer Part Number of this item.
          def AttributeIntent.mpn
            @@_mpn ||= AttributeIntent.new('mpn')
          end

          # A space separated list of the regions (as defined in
          # https://api.flow.io/reference/regions) where the item must be excluded.
          def AttributeIntent.excluded_regions
            @@_excluded_regions ||= AttributeIntent.new('excluded_regions')
          end

          # Identifies a facet.
          def AttributeIntent.facet
            @@_facet ||= AttributeIntent.new('facet')
          end

          def to_hash
            value
          end

        end

        class AuthenticationTechnique

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthenticationTechnique for this value, creating a new instance for an unknown value
          def AuthenticationTechnique.apply(value)
            if value.instance_of?(AuthenticationTechnique)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthenticationTechnique.new(value))
            end
          end

          # Returns the instance of AuthenticationTechnique for this value, or nil if not found
          def AuthenticationTechnique.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthenticationTechnique.ALL.find { |v| v.value == value }
          end

          def AuthenticationTechnique.ALL
            @@all ||= [AuthenticationTechnique.anonymous, AuthenticationTechnique.session, AuthenticationTechnique.token, AuthenticationTechnique.partner_token, AuthenticationTechnique.user]
          end

          # No authentication necessary.
          def AuthenticationTechnique.anonymous
            @@_anonymous ||= AuthenticationTechnique.new('anonymous')
          end

          # A browser has been assigned an identifier by Flow to track their use of our
          # service for an organization.
          def AuthenticationTechnique.session
            @@_session ||= AuthenticationTechnique.new('session')
          end

          # A token. Tokens carry the same permissions as the user who originally created
          # them.
          def AuthenticationTechnique.token
            @@_token ||= AuthenticationTechnique.new('token')
          end

          # A partner token. Partner Tokens can only access anonymous endpoints and the
          # endpoints of the partner api.
          def AuthenticationTechnique.partner_token
            @@_partner_token ||= AuthenticationTechnique.new('partner_token')
          end

          # A user logs into Flow.
          def AuthenticationTechnique.user
            @@_user ||= AuthenticationTechnique.new('user')
          end

          def to_hash
            value
          end

        end

        class AuthorizationDeclineCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationDeclineCode for this value, creating a new instance for an unknown value
          def AuthorizationDeclineCode.apply(value)
            if value.instance_of?(AuthorizationDeclineCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationDeclineCode.new(value))
            end
          end

          # Returns the instance of AuthorizationDeclineCode for this value, or nil if not found
          def AuthorizationDeclineCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationDeclineCode.ALL.find { |v| v.value == value }
          end

          def AuthorizationDeclineCode.ALL
            @@all ||= [AuthorizationDeclineCode.expired, AuthorizationDeclineCode.invalid_name, AuthorizationDeclineCode.invalid_number, AuthorizationDeclineCode.invalid_expiration, AuthorizationDeclineCode.invalid_address, AuthorizationDeclineCode.invalid_token_type, AuthorizationDeclineCode.invalid_token, AuthorizationDeclineCode.no_account, AuthorizationDeclineCode.avs, AuthorizationDeclineCode.cvv, AuthorizationDeclineCode.fraud, AuthorizationDeclineCode.duplicate, AuthorizationDeclineCode.not_supported, AuthorizationDeclineCode.unknown]
          end

          # Payment method has expired
          def AuthorizationDeclineCode.expired
            @@_expired ||= AuthorizationDeclineCode.new('expired')
          end

          # Invalid card holder name
          def AuthorizationDeclineCode.invalid_name
            @@_invalid_name ||= AuthorizationDeclineCode.new('invalid_name')
          end

          # Invalid payment number
          def AuthorizationDeclineCode.invalid_number
            @@_invalid_number ||= AuthorizationDeclineCode.new('invalid_number')
          end

          # Invalid expiration date
          def AuthorizationDeclineCode.invalid_expiration
            @@_invalid_expiration ||= AuthorizationDeclineCode.new('invalid_expiration')
          end

          # Invalid billing address
          def AuthorizationDeclineCode.invalid_address
            @@_invalid_address ||= AuthorizationDeclineCode.new('invalid_address')
          end

          # Cannot create a permanent card via an unauthorized request
          def AuthorizationDeclineCode.invalid_token_type
            @@_invalid_token_type ||= AuthorizationDeclineCode.new('invalid_token_type')
          end

          # The provided card token is invalid or it does not exist.
          def AuthorizationDeclineCode.invalid_token
            @@_invalid_token ||= AuthorizationDeclineCode.new('invalid_token')
          end

          # The provided payment method is not known by the issuing bank (the account does
          # not exist)
          def AuthorizationDeclineCode.no_account
            @@_no_account ||= AuthorizationDeclineCode.new('no_account')
          end

          # Declined due to avs mismatch)
          def AuthorizationDeclineCode.avs
            @@_avs ||= AuthorizationDeclineCode.new('avs')
          end

          # Declined due to cvv mismatch)
          def AuthorizationDeclineCode.cvv
            @@_cvv ||= AuthorizationDeclineCode.new('cvv')
          end

          # Declined due to suspected fraud
          def AuthorizationDeclineCode.fraud
            @@_fraud ||= AuthorizationDeclineCode.new('fraud')
          end

          # Declined due to suspected duplicate transaction
          def AuthorizationDeclineCode.duplicate
            @@_duplicate ||= AuthorizationDeclineCode.new('duplicate')
          end

          # Declined as payment method is not supported
          def AuthorizationDeclineCode.not_supported
            @@_not_supported ||= AuthorizationDeclineCode.new('not_supported')
          end

          # Declined due to another reason (details not known)
          def AuthorizationDeclineCode.unknown
            @@_unknown ||= AuthorizationDeclineCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class AuthorizationOption

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationOption for this value, creating a new instance for an unknown value
          def AuthorizationOption.apply(value)
            if value.instance_of?(AuthorizationOption)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationOption.new(value))
            end
          end

          # Returns the instance of AuthorizationOption for this value, or nil if not found
          def AuthorizationOption.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationOption.ALL.find { |v| v.value == value }
          end

          def AuthorizationOption.ALL
            @@all ||= [AuthorizationOption.store_card]
          end

          # If set, and the authorization is created using a one time nonce, we
          # automatically tokenize and store the card. In these cases you will want to
          # store the new card token in the authorization response (card object)
          def AuthorizationOption.store_card
            @@_store_card ||= AuthorizationOption.new('store_card')
          end

          def to_hash
            value
          end

        end

        class AuthorizationResultActionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationResultActionType for this value, creating a new instance for an unknown value
          def AuthorizationResultActionType.apply(value)
            if value.instance_of?(AuthorizationResultActionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationResultActionType.new(value))
            end
          end

          # Returns the instance of AuthorizationResultActionType for this value, or nil if not found
          def AuthorizationResultActionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationResultActionType.ALL.find { |v| v.value == value }
          end

          def AuthorizationResultActionType.ALL
            @@all ||= [AuthorizationResultActionType.native, AuthorizationResultActionType.redirect, AuthorizationResultActionType.wait]
          end

          # Indicates an authorization action should be presented to the user natively in
          # the browser.
          def AuthorizationResultActionType.native
            @@_native ||= AuthorizationResultActionType.new('native')
          end

          # Indicates that the user should be redirected to the provided URL.
          def AuthorizationResultActionType.redirect
            @@_redirect ||= AuthorizationResultActionType.new('redirect')
          end

          # Indicates that more time is needed before the authorization result is known.
          # In the case of 3D Secure, this means the authorization status should be polled
          # until it is no longer pending.
          def AuthorizationResultActionType.wait
            @@_wait ||= AuthorizationResultActionType.new('wait')
          end

          def to_hash
            value
          end

        end

        class AuthorizationStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationStatus for this value, creating a new instance for an unknown value
          def AuthorizationStatus.apply(value)
            if value.instance_of?(AuthorizationStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationStatus.new(value))
            end
          end

          # Returns the instance of AuthorizationStatus for this value, or nil if not found
          def AuthorizationStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationStatus.ALL.find { |v| v.value == value }
          end

          def AuthorizationStatus.ALL
            @@all ||= [AuthorizationStatus.pending, AuthorizationStatus.expired, AuthorizationStatus.authorized, AuthorizationStatus.review, AuthorizationStatus.declined, AuthorizationStatus.reversed]
          end

          # If an immediate response is not available, the state will be 'pending'. For
          # example, online payment methods like AliPay or PayPal will have a status of
          # 'pending' until the user completes the payment. Pending authorizations expire
          # if the user does not complete the payment in a timely fashion.
          def AuthorizationStatus.pending
            @@_pending ||= AuthorizationStatus.new('pending')
          end

          # Authorization has expired.
          def AuthorizationStatus.expired
            @@_expired ||= AuthorizationStatus.new('expired')
          end

          # Authorization was successful
          def AuthorizationStatus.authorized
            @@_authorized ||= AuthorizationStatus.new('authorized')
          end

          # If an immediate response is not available, the state will be 'review' - this
          # usually indicates fraud review requires additional time / verification (or a
          # potential network issue with the issuing bank)
          def AuthorizationStatus.review
            @@_review ||= AuthorizationStatus.new('review')
          end

          # Indicates the authorization has been declined by the issuing bank. See the
          # authorization decline code for more details as to the reason for decline.
          def AuthorizationStatus.declined
            @@_declined ||= AuthorizationStatus.new('declined')
          end

          # Indicates the authorization has been fully reversed. You can fully reverse an
          # authorization up until the moment you capture funds; once you have captured
          # funds you must create refunds.
          def AuthorizationStatus.reversed
            @@_reversed ||= AuthorizationStatus.new('reversed')
          end

          def to_hash
            value
          end

        end

        class AvailabilityStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AvailabilityStatus for this value, creating a new instance for an unknown value
          def AvailabilityStatus.apply(value)
            if value.instance_of?(AvailabilityStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AvailabilityStatus.new(value))
            end
          end

          # Returns the instance of AvailabilityStatus for this value, or nil if not found
          def AvailabilityStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AvailabilityStatus.ALL.find { |v| v.value == value }
          end

          def AvailabilityStatus.ALL
            @@all ||= [AvailabilityStatus.enabled, AvailabilityStatus.disabled]
          end

          def AvailabilityStatus.enabled
            @@_enabled ||= AvailabilityStatus.new('enabled')
          end

          def AvailabilityStatus.disabled
            @@_disabled ||= AvailabilityStatus.new('disabled')
          end

          def to_hash
            value
          end

        end

        class AvailableFilterFormat

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AvailableFilterFormat for this value, creating a new instance for an unknown value
          def AvailableFilterFormat.apply(value)
            if value.instance_of?(AvailableFilterFormat)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AvailableFilterFormat.new(value))
            end
          end

          # Returns the instance of AvailableFilterFormat for this value, or nil if not found
          def AvailableFilterFormat.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AvailableFilterFormat.ALL.find { |v| v.value == value }
          end

          def AvailableFilterFormat.ALL
            @@all ||= [AvailableFilterFormat.boolean, AvailableFilterFormat.date, AvailableFilterFormat.money, AvailableFilterFormat.decimal, AvailableFilterFormat.string, AvailableFilterFormat.unit_of_length, AvailableFilterFormat.unit_of_mass]
          end

          def AvailableFilterFormat.boolean
            @@_boolean ||= AvailableFilterFormat.new('boolean')
          end

          # Expects date in format YYYY-MM-DD
          def AvailableFilterFormat.date
            @@_date ||= AvailableFilterFormat.new('date')
          end

          def AvailableFilterFormat.money
            @@_money ||= AvailableFilterFormat.new('money')
          end

          def AvailableFilterFormat.decimal
            @@_decimal ||= AvailableFilterFormat.new('decimal')
          end

          def AvailableFilterFormat.string
            @@_string ||= AvailableFilterFormat.new('string')
          end

          def AvailableFilterFormat.unit_of_length
            @@_unit_of_length ||= AvailableFilterFormat.new('unit_of_length')
          end

          def AvailableFilterFormat.unit_of_mass
            @@_unit_of_mass ||= AvailableFilterFormat.new('unit_of_mass')
          end

          def to_hash
            value
          end

        end

        class AvsCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AvsCode for this value, creating a new instance for an unknown value
          def AvsCode.apply(value)
            if value.instance_of?(AvsCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AvsCode.new(value))
            end
          end

          # Returns the instance of AvsCode for this value, or nil if not found
          def AvsCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AvsCode.ALL.find { |v| v.value == value }
          end

          def AvsCode.ALL
            @@all ||= [AvsCode.match, AvsCode.partial, AvsCode.unsupported, AvsCode.no_match]
          end

          # Full match
          def AvsCode.match
            @@_match ||= AvsCode.new('match')
          end

          # Partial match; see details in 'avs' model to understand which components
          # matched
          def AvsCode.partial
            @@_partial ||= AvsCode.new('partial')
          end

          # Issuer does not support address verification
          def AvsCode.unsupported
            @@_unsupported ||= AvsCode.new('unsupported')
          end

          # Address does not match expected card values
          def AvsCode.no_match
            @@_no_match ||= AvsCode.new('no_match')
          end

          def to_hash
            value
          end

        end

        class Calendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Calendar for this value, creating a new instance for an unknown value
          def Calendar.apply(value)
            if value.instance_of?(Calendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Calendar.new(value))
            end
          end

          # Returns the instance of Calendar for this value, or nil if not found
          def Calendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Calendar.ALL.find { |v| v.value == value }
          end

          def Calendar.ALL
            @@all ||= [Calendar.weekdays, Calendar.everyday]
          end

          # Mon - Fri
          def Calendar.weekdays
            @@_weekdays ||= Calendar.new('weekdays')
          end

          # 7 days per week
          def Calendar.everyday
            @@_everyday ||= Calendar.new('everyday')
          end

          def to_hash
            value
          end

        end

        class CancelReason

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CancelReason for this value, creating a new instance for an unknown value
          def CancelReason.apply(value)
            if value.instance_of?(CancelReason)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CancelReason.new(value))
            end
          end

          # Returns the instance of CancelReason for this value, or nil if not found
          def CancelReason.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CancelReason.ALL.find { |v| v.value == value }
          end

          def CancelReason.ALL
            @@all ||= [CancelReason.out_of_stock, CancelReason.consumer_requested, CancelReason.flow_cancel]
          end

          # Out of stock is a permanent cancel of the fulfillment of an item qty. If no
          # other fulfillment parties exist, this will cancel the ordered quantity and
          # reduce or refund the consumer's payment.
          def CancelReason.out_of_stock
            @@_out_of_stock ||= CancelReason.new('out_of_stock')
          end

          # A consumer requested cancellation of an item qty and the fulfillment party has
          # acknowledged that the qty will not be shipped. This is a cancel of the ordered
          # quantity and will reduce or refund the consumer's payment
          def CancelReason.consumer_requested
            @@_consumer_requested ||= CancelReason.new('consumer_requested')
          end

          # Flow has had to cancel an order, possibly due to fraud activity or inability
          # to collect payment. This will cancel the ordered quantity. All known parties
          # will be notified.
          def CancelReason.flow_cancel
            @@_flow_cancel ||= CancelReason.new('flow_cancel')
          end

          def to_hash
            value
          end

        end

        class Capability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Capability for this value, creating a new instance for an unknown value
          def Capability.apply(value)
            if value.instance_of?(Capability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Capability.new(value))
            end
          end

          # Returns the instance of Capability for this value, or nil if not found
          def Capability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Capability.ALL.find { |v| v.value == value }
          end

          def Capability.ALL
            @@all ||= [Capability.crossdock]
          end

          def Capability.crossdock
            @@_crossdock ||= Capability.new('crossdock')
          end

          def to_hash
            value
          end

        end

        class CaptureDeclineCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CaptureDeclineCode for this value, creating a new instance for an unknown value
          def CaptureDeclineCode.apply(value)
            if value.instance_of?(CaptureDeclineCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CaptureDeclineCode.new(value))
            end
          end

          # Returns the instance of CaptureDeclineCode for this value, or nil if not found
          def CaptureDeclineCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CaptureDeclineCode.ALL.find { |v| v.value == value }
          end

          def CaptureDeclineCode.ALL
            @@all ||= [CaptureDeclineCode.expired, CaptureDeclineCode.insufficient_funds, CaptureDeclineCode.unknown]
          end

          # Payment authorization has expired
          def CaptureDeclineCode.expired
            @@_expired ||= CaptureDeclineCode.new('expired')
          end

          # The amount to capture exceeded the amount authorized and not yet captured
          def CaptureDeclineCode.insufficient_funds
            @@_insufficient_funds ||= CaptureDeclineCode.new('insufficient_funds')
          end

          # Failed due to another reason (details not known)
          def CaptureDeclineCode.unknown
            @@_unknown ||= CaptureDeclineCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class CaptureStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CaptureStatus for this value, creating a new instance for an unknown value
          def CaptureStatus.apply(value)
            if value.instance_of?(CaptureStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CaptureStatus.new(value))
            end
          end

          # Returns the instance of CaptureStatus for this value, or nil if not found
          def CaptureStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CaptureStatus.ALL.find { |v| v.value == value }
          end

          def CaptureStatus.ALL
            @@all ||= [CaptureStatus.pending, CaptureStatus.succeeded, CaptureStatus.failed, CaptureStatus.canceled]
          end

          # The capture has been initiated and requires time to complete.
          def CaptureStatus.pending
            @@_pending ||= CaptureStatus.new('pending')
          end

          # The capture has been processed successfully.
          def CaptureStatus.succeeded
            @@_succeeded ||= CaptureStatus.new('succeeded')
          end

          # The capture failed to process.
          def CaptureStatus.failed
            @@_failed ||= CaptureStatus.new('failed')
          end

          # The capture was canceled.
          def CaptureStatus.canceled
            @@_canceled ||= CaptureStatus.new('canceled')
          end

          def to_hash
            value
          end

        end

        class CardErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CardErrorCode for this value, creating a new instance for an unknown value
          def CardErrorCode.apply(value)
            if value.instance_of?(CardErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CardErrorCode.new(value))
            end
          end

          # Returns the instance of CardErrorCode for this value, or nil if not found
          def CardErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CardErrorCode.ALL.find { |v| v.value == value }
          end

          def CardErrorCode.ALL
            @@all ||= [CardErrorCode.invalid_address, CardErrorCode.invalid_name, CardErrorCode.invalid_number, CardErrorCode.invalid_expiration, CardErrorCode.invalid_token_type, CardErrorCode.avs, CardErrorCode.cvv, CardErrorCode.fraud, CardErrorCode.unknown]
          end

          # Invalid billing address
          def CardErrorCode.invalid_address
            @@_invalid_address ||= CardErrorCode.new('invalid_address')
          end

          # Invalid cardholder name
          def CardErrorCode.invalid_name
            @@_invalid_name ||= CardErrorCode.new('invalid_name')
          end

          # Invalid payment number
          def CardErrorCode.invalid_number
            @@_invalid_number ||= CardErrorCode.new('invalid_number')
          end

          # Invalid expiration date
          def CardErrorCode.invalid_expiration
            @@_invalid_expiration ||= CardErrorCode.new('invalid_expiration')
          end

          # Cannot create a permanent card via an unauthorized request
          def CardErrorCode.invalid_token_type
            @@_invalid_token_type ||= CardErrorCode.new('invalid_token_type')
          end

          # Declined due to avs mismatch
          def CardErrorCode.avs
            @@_avs ||= CardErrorCode.new('avs')
          end

          # Declined due to cvv mismatch
          def CardErrorCode.cvv
            @@_cvv ||= CardErrorCode.new('cvv')
          end

          # Declined due to suspected fraud
          def CardErrorCode.fraud
            @@_fraud ||= CardErrorCode.new('fraud')
          end

          # Declined due to another reason (details not known)
          def CardErrorCode.unknown
            @@_unknown ||= CardErrorCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class CardType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CardType for this value, creating a new instance for an unknown value
          def CardType.apply(value)
            if value.instance_of?(CardType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CardType.new(value))
            end
          end

          # Returns the instance of CardType for this value, or nil if not found
          def CardType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CardType.ALL.find { |v| v.value == value }
          end

          def CardType.ALL
            @@all ||= [CardType.american_express, CardType.cartes_bancaires, CardType.china_union_pay, CardType.dankort, CardType.diners_club, CardType.discover, CardType.jcb, CardType.maestro, CardType.mastercard, CardType.visa]
          end

          def CardType.american_express
            @@_american_express ||= CardType.new('american_express')
          end

          def CardType.cartes_bancaires
            @@_cartes_bancaires ||= CardType.new('cartes_bancaires')
          end

          def CardType.china_union_pay
            @@_china_union_pay ||= CardType.new('china_union_pay')
          end

          def CardType.dankort
            @@_dankort ||= CardType.new('dankort')
          end

          def CardType.diners_club
            @@_diners_club ||= CardType.new('diners_club')
          end

          def CardType.discover
            @@_discover ||= CardType.new('discover')
          end

          def CardType.jcb
            @@_jcb ||= CardType.new('jcb')
          end

          def CardType.maestro
            @@_maestro ||= CardType.new('maestro')
          end

          def CardType.mastercard
            @@_mastercard ||= CardType.new('mastercard')
          end

          def CardType.visa
            @@_visa ||= CardType.new('visa')
          end

          def to_hash
            value
          end

        end

        class CenterCapability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CenterCapability for this value, creating a new instance for an unknown value
          def CenterCapability.apply(value)
            if value.instance_of?(CenterCapability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CenterCapability.new(value))
            end
          end

          # Returns the instance of CenterCapability for this value, or nil if not found
          def CenterCapability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CenterCapability.ALL.find { |v| v.value == value }
          end

          def CenterCapability.ALL
            @@all ||= [CenterCapability.international, CenterCapability.domestic, CenterCapability.crossdock, CenterCapability.commercial_invoice]
          end

          def CenterCapability.international
            @@_international ||= CenterCapability.new('international')
          end

          def CenterCapability.domestic
            @@_domestic ||= CenterCapability.new('domestic')
          end

          def CenterCapability.crossdock
            @@_crossdock ||= CenterCapability.new('crossdock')
          end

          def CenterCapability.commercial_invoice
            @@_commercial_invoice ||= CenterCapability.new('commercial_invoice')
          end

          def to_hash
            value
          end

        end

        class ChangeType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ChangeType for this value, creating a new instance for an unknown value
          def ChangeType.apply(value)
            if value.instance_of?(ChangeType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ChangeType.new(value))
            end
          end

          # Returns the instance of ChangeType for this value, or nil if not found
          def ChangeType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ChangeType.ALL.find { |v| v.value == value }
          end

          def ChangeType.ALL
            @@all ||= [ChangeType.insert, ChangeType.update, ChangeType.delete]
          end

          def ChangeType.insert
            @@_insert ||= ChangeType.new('insert')
          end

          def ChangeType.update
            @@_update ||= ChangeType.new('update')
          end

          def ChangeType.delete
            @@_delete ||= ChangeType.new('delete')
          end

          def to_hash
            value
          end

        end

        class ConsumerInvoiceCustomerType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ConsumerInvoiceCustomerType for this value, creating a new instance for an unknown value
          def ConsumerInvoiceCustomerType.apply(value)
            if value.instance_of?(ConsumerInvoiceCustomerType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ConsumerInvoiceCustomerType.new(value))
            end
          end

          # Returns the instance of ConsumerInvoiceCustomerType for this value, or nil if not found
          def ConsumerInvoiceCustomerType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ConsumerInvoiceCustomerType.ALL.find { |v| v.value == value }
          end

          def ConsumerInvoiceCustomerType.ALL
            @@all ||= [ConsumerInvoiceCustomerType.business_eu_verified, ConsumerInvoiceCustomerType.business_non_verified, ConsumerInvoiceCustomerType.individual]
          end

          # A business that have been verified in the European Union
          def ConsumerInvoiceCustomerType.business_eu_verified
            @@_business_eu_verified ||= ConsumerInvoiceCustomerType.new('business_eu_verified')
          end

          # A business, but with no additional verification
          def ConsumerInvoiceCustomerType.business_non_verified
            @@_business_non_verified ||= ConsumerInvoiceCustomerType.new('business_non_verified')
          end

          def ConsumerInvoiceCustomerType.individual
            @@_individual ||= ConsumerInvoiceCustomerType.new('individual')
          end

          def to_hash
            value
          end

        end

        class ConsumerInvoiceDocumentType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ConsumerInvoiceDocumentType for this value, creating a new instance for an unknown value
          def ConsumerInvoiceDocumentType.apply(value)
            if value.instance_of?(ConsumerInvoiceDocumentType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ConsumerInvoiceDocumentType.new(value))
            end
          end

          # Returns the instance of ConsumerInvoiceDocumentType for this value, or nil if not found
          def ConsumerInvoiceDocumentType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ConsumerInvoiceDocumentType.ALL.find { |v| v.value == value }
          end

          def ConsumerInvoiceDocumentType.ALL
            @@all ||= [ConsumerInvoiceDocumentType.pdf]
          end

          def ConsumerInvoiceDocumentType.pdf
            @@_pdf ||= ConsumerInvoiceDocumentType.new('pdf')
          end

          def to_hash
            value
          end

        end

        class ConsumerInvoiceStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ConsumerInvoiceStatus for this value, creating a new instance for an unknown value
          def ConsumerInvoiceStatus.apply(value)
            if value.instance_of?(ConsumerInvoiceStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ConsumerInvoiceStatus.new(value))
            end
          end

          # Returns the instance of ConsumerInvoiceStatus for this value, or nil if not found
          def ConsumerInvoiceStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ConsumerInvoiceStatus.ALL.find { |v| v.value == value }
          end

          def ConsumerInvoiceStatus.ALL
            @@all ||= [ConsumerInvoiceStatus.pending, ConsumerInvoiceStatus.available, ConsumerInvoiceStatus.invalid]
          end

          # Indicates that the credit memo has been created but validation is pending
          # (e.g. waiting for the associated refund to be confirmed)
          def ConsumerInvoiceStatus.pending
            @@_pending ||= ConsumerInvoiceStatus.new('pending')
          end

          # Indicates that the credit memo is fully validated and available for the end
          # consumer
          def ConsumerInvoiceStatus.available
            @@_available ||= ConsumerInvoiceStatus.new('available')
          end

          # Indicates that the credit memo failed to validate after multiple attempts and
          # time
          def ConsumerInvoiceStatus.invalid
            @@_invalid ||= ConsumerInvoiceStatus.new('invalid')
          end

          def to_hash
            value
          end

        end

        class CreditPaymentErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CreditPaymentErrorCode for this value, creating a new instance for an unknown value
          def CreditPaymentErrorCode.apply(value)
            if value.instance_of?(CreditPaymentErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CreditPaymentErrorCode.new(value))
            end
          end

          # Returns the instance of CreditPaymentErrorCode for this value, or nil if not found
          def CreditPaymentErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CreditPaymentErrorCode.ALL.find { |v| v.value == value }
          end

          def CreditPaymentErrorCode.ALL
            @@all ||= [CreditPaymentErrorCode.generic_error, CreditPaymentErrorCode.invalid_order_number, CreditPaymentErrorCode.invalid_currency, CreditPaymentErrorCode.invalid_description, CreditPaymentErrorCode.duplicate, CreditPaymentErrorCode.amount_must_be_positive, CreditPaymentErrorCode.amount_exceeds_balance, CreditPaymentErrorCode.insufficient_amount]
          end

          def CreditPaymentErrorCode.generic_error
            @@_generic_error ||= CreditPaymentErrorCode.new('generic_error')
          end

          # Indicates the specified order does not exist
          def CreditPaymentErrorCode.invalid_order_number
            @@_invalid_order_number ||= CreditPaymentErrorCode.new('invalid_order_number')
          end

          # Indicates that the specified currency code is not valid
          def CreditPaymentErrorCode.invalid_currency
            @@_invalid_currency ||= CreditPaymentErrorCode.new('invalid_currency')
          end

          # Indicates that the description is invalid (must be non-empty)
          def CreditPaymentErrorCode.invalid_description
            @@_invalid_description ||= CreditPaymentErrorCode.new('invalid_description')
          end

          # Indicates that a credit payment with the specified key already exists
          def CreditPaymentErrorCode.duplicate
            @@_duplicate ||= CreditPaymentErrorCode.new('duplicate')
          end

          # Indicates the provided credit amount was <= 0
          def CreditPaymentErrorCode.amount_must_be_positive
            @@_amount_must_be_positive ||= CreditPaymentErrorCode.new('amount_must_be_positive')
          end

          # Indicates the provided credit amount exceeds the remaining balance on the
          # order
          def CreditPaymentErrorCode.amount_exceeds_balance
            @@_amount_exceeds_balance ||= CreditPaymentErrorCode.new('amount_exceeds_balance')
          end

          # Indicates the provided credit amount exceeds the maximum amount of applicable
          # credit
          def CreditPaymentErrorCode.insufficient_amount
            @@_insufficient_amount ||= CreditPaymentErrorCode.new('insufficient_amount')
          end

          def to_hash
            value
          end

        end

        class CurrencyLabelFormatter

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CurrencyLabelFormatter for this value, creating a new instance for an unknown value
          def CurrencyLabelFormatter.apply(value)
            if value.instance_of?(CurrencyLabelFormatter)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CurrencyLabelFormatter.new(value))
            end
          end

          # Returns the instance of CurrencyLabelFormatter for this value, or nil if not found
          def CurrencyLabelFormatter.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CurrencyLabelFormatter.ALL.find { |v| v.value == value }
          end

          def CurrencyLabelFormatter.ALL
            @@all ||= [CurrencyLabelFormatter.strip_trailing_zeros]
          end

          # If a price ends in '.00' or ',00', we remove the cents and just display the
          # price as a whole number. e.g. 'A$100.00' becomes 'A$100'
          def CurrencyLabelFormatter.strip_trailing_zeros
            @@_strip_trailing_zeros ||= CurrencyLabelFormatter.new('strip_trailing_zeros')
          end

          def to_hash
            value
          end

        end

        class CurrencySymbolFormat

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CurrencySymbolFormat for this value, creating a new instance for an unknown value
          def CurrencySymbolFormat.apply(value)
            if value.instance_of?(CurrencySymbolFormat)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CurrencySymbolFormat.new(value))
            end
          end

          # Returns the instance of CurrencySymbolFormat for this value, or nil if not found
          def CurrencySymbolFormat.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CurrencySymbolFormat.ALL.find { |v| v.value == value }
          end

          def CurrencySymbolFormat.ALL
            @@all ||= [CurrencySymbolFormat.narrow, CurrencySymbolFormat.primary]
          end

          # The narrow format refers to the Unicode Common Locale Data Repository (CLDR)
          # 'narrow' symbols (e.g. '$' for CAD and AUD)
          def CurrencySymbolFormat.narrow
            @@_narrow ||= CurrencySymbolFormat.new('narrow')
          end

          # The primary format refers to the Unicode Common Locale Data Repository (CLDR)
          # 'primary' symbols (e.g. 'CA$' for CAD and 'A$' for AUD)
          def CurrencySymbolFormat.primary
            @@_primary ||= CurrencySymbolFormat.new('primary')
          end

          def to_hash
            value
          end

        end

        class CustomerAddressType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CustomerAddressType for this value, creating a new instance for an unknown value
          def CustomerAddressType.apply(value)
            if value.instance_of?(CustomerAddressType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CustomerAddressType.new(value))
            end
          end

          # Returns the instance of CustomerAddressType for this value, or nil if not found
          def CustomerAddressType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CustomerAddressType.ALL.find { |v| v.value == value }
          end

          def CustomerAddressType.ALL
            @@all ||= [CustomerAddressType.billing, CustomerAddressType.invoice, CustomerAddressType.shipping]
          end

          def CustomerAddressType.billing
            @@_billing ||= CustomerAddressType.new('billing')
          end

          def CustomerAddressType.invoice
            @@_invoice ||= CustomerAddressType.new('invoice')
          end

          def CustomerAddressType.shipping
            @@_shipping ||= CustomerAddressType.new('shipping')
          end

          def to_hash
            value
          end

        end

        class CvvCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CvvCode for this value, creating a new instance for an unknown value
          def CvvCode.apply(value)
            if value.instance_of?(CvvCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CvvCode.new(value))
            end
          end

          # Returns the instance of CvvCode for this value, or nil if not found
          def CvvCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CvvCode.ALL.find { |v| v.value == value }
          end

          def CvvCode.ALL
            @@all ||= [CvvCode.match, CvvCode.suspicious, CvvCode.unsupported, CvvCode.no_match]
          end

          # CVV matches
          def CvvCode.match
            @@_match ||= CvvCode.new('match')
          end

          # CVV did not match; Transaction is possibly fraudulent
          def CvvCode.suspicious
            @@_suspicious ||= CvvCode.new('suspicious')
          end

          # CVV did not match; Issuer does not support card verification numbers
          def CvvCode.unsupported
            @@_unsupported ||= CvvCode.new('unsupported')
          end

          # CVV did not match; Specific reason not available
          def CvvCode.no_match
            @@_no_match ||= CvvCode.new('no_match')
          end

          def to_hash
            value
          end

        end

        class DayOfWeek

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DayOfWeek for this value, creating a new instance for an unknown value
          def DayOfWeek.apply(value)
            if value.instance_of?(DayOfWeek)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DayOfWeek.new(value))
            end
          end

          # Returns the instance of DayOfWeek for this value, or nil if not found
          def DayOfWeek.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DayOfWeek.ALL.find { |v| v.value == value }
          end

          def DayOfWeek.ALL
            @@all ||= [DayOfWeek.sunday, DayOfWeek.monday, DayOfWeek.tuesday, DayOfWeek.wednesday, DayOfWeek.thursday, DayOfWeek.friday, DayOfWeek.saturday]
          end

          def DayOfWeek.sunday
            @@_sunday ||= DayOfWeek.new('sunday')
          end

          def DayOfWeek.monday
            @@_monday ||= DayOfWeek.new('monday')
          end

          def DayOfWeek.tuesday
            @@_tuesday ||= DayOfWeek.new('tuesday')
          end

          def DayOfWeek.wednesday
            @@_wednesday ||= DayOfWeek.new('wednesday')
          end

          def DayOfWeek.thursday
            @@_thursday ||= DayOfWeek.new('thursday')
          end

          def DayOfWeek.friday
            @@_friday ||= DayOfWeek.new('friday')
          end

          def DayOfWeek.saturday
            @@_saturday ||= DayOfWeek.new('saturday')
          end

          def to_hash
            value
          end

        end

        class DeliveredDuty

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveredDuty for this value, creating a new instance for an unknown value
          def DeliveredDuty.apply(value)
            if value.instance_of?(DeliveredDuty)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveredDuty.new(value))
            end
          end

          # Returns the instance of DeliveredDuty for this value, or nil if not found
          def DeliveredDuty.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveredDuty.ALL.find { |v| v.value == value }
          end

          def DeliveredDuty.ALL
            @@all ||= [DeliveredDuty.paid, DeliveredDuty.unpaid]
          end

          # Delivered Duty Paid (DDP). See https://en.wikipedia.org/wiki/Incoterms for
          # more information
          def DeliveredDuty.paid
            @@_paid ||= DeliveredDuty.new('paid')
          end

          # Delivered Duty Unpaid (DDU). See https://en.wikipedia.org/wiki/Incoterms for
          # more information
          def DeliveredDuty.unpaid
            @@_unpaid ||= DeliveredDuty.new('unpaid')
          end

          def to_hash
            value
          end

        end

        class DeliveredDutyDisplayType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveredDutyDisplayType for this value, creating a new instance for an unknown value
          def DeliveredDutyDisplayType.apply(value)
            if value.instance_of?(DeliveredDutyDisplayType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveredDutyDisplayType.new(value))
            end
          end

          # Returns the instance of DeliveredDutyDisplayType for this value, or nil if not found
          def DeliveredDutyDisplayType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveredDutyDisplayType.ALL.find { |v| v.value == value }
          end

          def DeliveredDutyDisplayType.ALL
            @@all ||= [DeliveredDutyDisplayType.all, DeliveredDutyDisplayType.single]
          end

          # Displays all available options to the customer.
          def DeliveredDutyDisplayType.all
            @@_all ||= DeliveredDutyDisplayType.new('all')
          end

          # Displays a single option (either DDU or DDP), while the other can be displayed
          # by changing duties and tax preferences at checkout.
          def DeliveredDutyDisplayType.single
            @@_single ||= DeliveredDutyDisplayType.new('single')
          end

          def to_hash
            value
          end

        end

        class DeliveryOptionCostDetailComponentKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveryOptionCostDetailComponentKey for this value, creating a new instance for an unknown value
          def DeliveryOptionCostDetailComponentKey.apply(value)
            if value.instance_of?(DeliveryOptionCostDetailComponentKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveryOptionCostDetailComponentKey.new(value))
            end
          end

          # Returns the instance of DeliveryOptionCostDetailComponentKey for this value, or nil if not found
          def DeliveryOptionCostDetailComponentKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveryOptionCostDetailComponentKey.ALL.find { |v| v.value == value }
          end

          def DeliveryOptionCostDetailComponentKey.ALL
            @@all ||= [DeliveryOptionCostDetailComponentKey.ratecard_base_cost, DeliveryOptionCostDetailComponentKey.ratecard_ddp_fee, DeliveryOptionCostDetailComponentKey.ratecard_fuel_surcharge, DeliveryOptionCostDetailComponentKey.ratecard_oversized_shipment_fee, DeliveryOptionCostDetailComponentKey.ratecard_rural_shipment_fee, DeliveryOptionCostDetailComponentKey.center_commercial_invoice_fee, DeliveryOptionCostDetailComponentKey.center_inbound_carton_fee, DeliveryOptionCostDetailComponentKey.center_outbound_carton_fee]
          end

          def DeliveryOptionCostDetailComponentKey.ratecard_base_cost
            @@_ratecard_base_cost ||= DeliveryOptionCostDetailComponentKey.new('ratecard_base_cost')
          end

          def DeliveryOptionCostDetailComponentKey.ratecard_ddp_fee
            @@_ratecard_ddp_fee ||= DeliveryOptionCostDetailComponentKey.new('ratecard_ddp_fee')
          end

          def DeliveryOptionCostDetailComponentKey.ratecard_fuel_surcharge
            @@_ratecard_fuel_surcharge ||= DeliveryOptionCostDetailComponentKey.new('ratecard_fuel_surcharge')
          end

          def DeliveryOptionCostDetailComponentKey.ratecard_oversized_shipment_fee
            @@_ratecard_oversized_shipment_fee ||= DeliveryOptionCostDetailComponentKey.new('ratecard_oversized_shipment_fee')
          end

          def DeliveryOptionCostDetailComponentKey.ratecard_rural_shipment_fee
            @@_ratecard_rural_shipment_fee ||= DeliveryOptionCostDetailComponentKey.new('ratecard_rural_shipment_fee')
          end

          def DeliveryOptionCostDetailComponentKey.center_commercial_invoice_fee
            @@_center_commercial_invoice_fee ||= DeliveryOptionCostDetailComponentKey.new('center_commercial_invoice_fee')
          end

          def DeliveryOptionCostDetailComponentKey.center_inbound_carton_fee
            @@_center_inbound_carton_fee ||= DeliveryOptionCostDetailComponentKey.new('center_inbound_carton_fee')
          end

          def DeliveryOptionCostDetailComponentKey.center_outbound_carton_fee
            @@_center_outbound_carton_fee ||= DeliveryOptionCostDetailComponentKey.new('center_outbound_carton_fee')
          end

          def to_hash
            value
          end

        end

        class DeliveryOptionCostDetailSource

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveryOptionCostDetailSource for this value, creating a new instance for an unknown value
          def DeliveryOptionCostDetailSource.apply(value)
            if value.instance_of?(DeliveryOptionCostDetailSource)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveryOptionCostDetailSource.new(value))
            end
          end

          # Returns the instance of DeliveryOptionCostDetailSource for this value, or nil if not found
          def DeliveryOptionCostDetailSource.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveryOptionCostDetailSource.ALL.find { |v| v.value == value }
          end

          def DeliveryOptionCostDetailSource.ALL
            @@all ||= [DeliveryOptionCostDetailSource.center, DeliveryOptionCostDetailSource.ratecard]
          end

          def DeliveryOptionCostDetailSource.center
            @@_center ||= DeliveryOptionCostDetailSource.new('center')
          end

          def DeliveryOptionCostDetailSource.ratecard
            @@_ratecard ||= DeliveryOptionCostDetailSource.new('ratecard')
          end

          def to_hash
            value
          end

        end

        class DeliveryWindowComponentSource

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveryWindowComponentSource for this value, creating a new instance for an unknown value
          def DeliveryWindowComponentSource.apply(value)
            if value.instance_of?(DeliveryWindowComponentSource)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveryWindowComponentSource.new(value))
            end
          end

          # Returns the instance of DeliveryWindowComponentSource for this value, or nil if not found
          def DeliveryWindowComponentSource.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveryWindowComponentSource.ALL.find { |v| v.value == value }
          end

          def DeliveryWindowComponentSource.ALL
            @@all ||= [DeliveryWindowComponentSource.flow, DeliveryWindowComponentSource.organization, DeliveryWindowComponentSource.carrier, DeliveryWindowComponentSource.center, DeliveryWindowComponentSource.mixed]
          end

          def DeliveryWindowComponentSource.flow
            @@_flow ||= DeliveryWindowComponentSource.new('flow')
          end

          def DeliveryWindowComponentSource.organization
            @@_organization ||= DeliveryWindowComponentSource.new('organization')
          end

          def DeliveryWindowComponentSource.carrier
            @@_carrier ||= DeliveryWindowComponentSource.new('carrier')
          end

          def DeliveryWindowComponentSource.center
            @@_center ||= DeliveryWindowComponentSource.new('center')
          end

          # A delivery estimate may be a combination of multiple sources
          def DeliveryWindowComponentSource.mixed
            @@_mixed ||= DeliveryWindowComponentSource.new('mixed')
          end

          def to_hash
            value
          end

        end

        class DeliveryWindowLocation

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveryWindowLocation for this value, creating a new instance for an unknown value
          def DeliveryWindowLocation.apply(value)
            if value.instance_of?(DeliveryWindowLocation)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveryWindowLocation.new(value))
            end
          end

          # Returns the instance of DeliveryWindowLocation for this value, or nil if not found
          def DeliveryWindowLocation.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveryWindowLocation.ALL.find { |v| v.value == value }
          end

          def DeliveryWindowLocation.ALL
            @@all ||= [DeliveryWindowLocation.center, DeliveryWindowLocation.crossdock, DeliveryWindowLocation.customer]
          end

          def DeliveryWindowLocation.center
            @@_center ||= DeliveryWindowLocation.new('center')
          end

          def DeliveryWindowLocation.crossdock
            @@_crossdock ||= DeliveryWindowLocation.new('crossdock')
          end

          def DeliveryWindowLocation.customer
            @@_customer ||= DeliveryWindowLocation.new('customer')
          end

          def to_hash
            value
          end

        end

        class Direction

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Direction for this value, creating a new instance for an unknown value
          def Direction.apply(value)
            if value.instance_of?(Direction)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Direction.new(value))
            end
          end

          # Returns the instance of Direction for this value, or nil if not found
          def Direction.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Direction.ALL.find { |v| v.value == value }
          end

          def Direction.ALL
            @@all ||= [Direction.outbound, Direction.return]
          end

          # Outbound shipment to typically fulfill a customer order
          def Direction.outbound
            @@_outbound ||= Direction.new('outbound')
          end

          # Inbound or return shipment
          def Direction.return
            @@_return ||= Direction.new('return')
          end

          def to_hash
            value
          end

        end

        class DiscountTarget

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DiscountTarget for this value, creating a new instance for an unknown value
          def DiscountTarget.apply(value)
            if value.instance_of?(DiscountTarget)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DiscountTarget.new(value))
            end
          end

          # Returns the instance of DiscountTarget for this value, or nil if not found
          def DiscountTarget.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DiscountTarget.ALL.find { |v| v.value == value }
          end

          def DiscountTarget.ALL
            @@all ||= [DiscountTarget.item, DiscountTarget.shipping]
          end

          # Discount is targeted to an item.
          def DiscountTarget.item
            @@_item ||= DiscountTarget.new('item')
          end

          # Discount is targeting to shipping. Only applicable if the discount is provided
          # at the order level.
          def DiscountTarget.shipping
            @@_shipping ||= DiscountTarget.new('shipping')
          end

          def to_hash
            value
          end

        end

        class EcommercePlatformType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of EcommercePlatformType for this value, creating a new instance for an unknown value
          def EcommercePlatformType.apply(value)
            if value.instance_of?(EcommercePlatformType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || EcommercePlatformType.new(value))
            end
          end

          # Returns the instance of EcommercePlatformType for this value, or nil if not found
          def EcommercePlatformType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            EcommercePlatformType.ALL.find { |v| v.value == value }
          end

          def EcommercePlatformType.ALL
            @@all ||= [EcommercePlatformType.commercetools, EcommercePlatformType.custom, EcommercePlatformType.magento, EcommercePlatformType.shopify, EcommercePlatformType.sfcc, EcommercePlatformType.solidus, EcommercePlatformType.workarea]
          end

          def EcommercePlatformType.commercetools
            @@_commercetools ||= EcommercePlatformType.new('commercetools')
          end

          def EcommercePlatformType.custom
            @@_custom ||= EcommercePlatformType.new('custom')
          end

          def EcommercePlatformType.magento
            @@_magento ||= EcommercePlatformType.new('magento')
          end

          def EcommercePlatformType.shopify
            @@_shopify ||= EcommercePlatformType.new('shopify')
          end

          def EcommercePlatformType.sfcc
            @@_sfcc ||= EcommercePlatformType.new('sfcc')
          end

          def EcommercePlatformType.solidus
            @@_solidus ||= EcommercePlatformType.new('solidus')
          end

          def EcommercePlatformType.workarea
            @@_workarea ||= EcommercePlatformType.new('workarea')
          end

          def to_hash
            value
          end

        end

        class EconomicTitleLocation

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of EconomicTitleLocation for this value, creating a new instance for an unknown value
          def EconomicTitleLocation.apply(value)
            if value.instance_of?(EconomicTitleLocation)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || EconomicTitleLocation.new(value))
            end
          end

          # Returns the instance of EconomicTitleLocation for this value, or nil if not found
          def EconomicTitleLocation.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            EconomicTitleLocation.ALL.find { |v| v.value == value }
          end

          def EconomicTitleLocation.ALL
            @@all ||= [EconomicTitleLocation.high_seas, EconomicTitleLocation.origination, EconomicTitleLocation.destination]
          end

          # Indicates title transferred on the high seas
          def EconomicTitleLocation.high_seas
            @@_high_seas ||= EconomicTitleLocation.new('high_seas')
          end

          # Indicates title transferred at the originating fulfillment center
          def EconomicTitleLocation.origination
            @@_origination ||= EconomicTitleLocation.new('origination')
          end

          # Indicates title transferred at the destination
          def EconomicTitleLocation.destination
            @@_destination ||= EconomicTitleLocation.new('destination')
          end

          def to_hash
            value
          end

        end

        class Environment

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Environment for this value, creating a new instance for an unknown value
          def Environment.apply(value)
            if value.instance_of?(Environment)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Environment.new(value))
            end
          end

          # Returns the instance of Environment for this value, or nil if not found
          def Environment.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Environment.ALL.find { |v| v.value == value }
          end

          def Environment.ALL
            @@all ||= [Environment.sandbox, Environment.production]
          end

          # In sandbox, no external services (e.g. orders, payments, logistics) will
          # generate real transactions
          def Environment.sandbox
            @@_sandbox ||= Environment.new('sandbox')
          end

          # In production, all external services are live and will generate real
          # transactions
          def Environment.production
            @@_production ||= Environment.new('production')
          end

          def to_hash
            value
          end

        end

        class EventType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of EventType for this value, creating a new instance for an unknown value
          def EventType.apply(value)
            if value.instance_of?(EventType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || EventType.new(value))
            end
          end

          # Returns the instance of EventType for this value, or nil if not found
          def EventType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            EventType.ALL.find { |v| v.value == value }
          end

          def EventType.ALL
            @@all ||= [EventType.attribute_upserted, EventType.attribute_deleted, EventType.attribute_upserted_v2, EventType.attribute_deleted_v2, EventType.catalog_upserted, EventType.catalog_deleted, EventType.subcatalog_upserted, EventType.subcatalog_deleted, EventType.catalog_item_upserted, EventType.catalog_item_deleted, EventType.catalog_item_upserted_v2, EventType.catalog_item_deleted_v2, EventType.subcatalog_item_upserted, EventType.subcatalog_item_deleted, EventType.b2b_invoice_upserted, EventType.b2b_invoice_deleted, EventType.b2b_credit_memo_upserted, EventType.b2b_credit_memo_deleted, EventType.consumer_invoice_upserted, EventType.consumer_invoice_deleted, EventType.credit_memo_upserted, EventType.credit_memo_deleted, EventType.crossdock_shipment_upserted, EventType.rate_deleted, EventType.rate_upserted, EventType.rate_deleted_v3, EventType.rate_upserted_v3, EventType.customer_upserted, EventType.customer_deleted, EventType.customer_address_book_contact_upserted, EventType.customer_address_book_contact_deleted, EventType.email_notification_upserted, EventType.email_notification_deleted, EventType.available_promotions_upserted, EventType.available_promotions_deleted, EventType.available_promotions_upserted_v2, EventType.available_promotions_deleted_v2, EventType.allocation_deleted_v2, EventType.allocation_upserted_v2, EventType.currency_format_deleted, EventType.currency_format_upserted, EventType.experience_deleted, EventType.experience_upserted, EventType.experience_deleted_v2, EventType.experience_upserted_v2, EventType.experience_price_book_mapping_deleted, EventType.experience_price_book_mapping_upserted, EventType.experience_logistics_settings_upserted, EventType.experience_logistics_settings_deleted, EventType.item_margin_deleted, EventType.item_margin_upserted, EventType.item_sales_margin_deleted, EventType.item_sales_margin_upserted, EventType.label_format_deleted, EventType.label_format_upserted, EventType.order_deleted, EventType.order_upserted, EventType.order_deleted_v2, EventType.order_upserted_v2, EventType.order_identifier_deleted, EventType.order_identifier_upserted, EventType.order_identifier_deleted_v2, EventType.order_identifier_upserted_v2, EventType.order_identifier_upserted_v3, EventType.pricing_deleted, EventType.pricing_upserted, EventType.order_service_change_request, EventType.fraud_status_changed, EventType.center_upserted, EventType.center_deleted, EventType.shipping_configuration_upserted, EventType.shipping_configuration_deleted, EventType.tier_upserted_v2, EventType.tier_deleted_v2, EventType.shipping_lane_upserted, EventType.shipping_lane_deleted, EventType.shipping_configuration_item_availability_upserted, EventType.shipping_configuration_item_availability_deleted, EventType.shipping_configuration_item_shipping_pricing_upserted, EventType.shipping_configuration_item_shipping_pricing_deleted, EventType.hs6_code_upserted, EventType.hs6_code_deleted, EventType.hs10_code_upserted, EventType.hs10_code_deleted, EventType.item_origin_upserted, EventType.item_origin_deleted, EventType.harmonized_landed_cost_upserted, EventType.fully_harmonized_item_upserted, EventType.rule_upserted, EventType.rule_deleted, EventType.serial_upserted, EventType.serial_deleted, EventType.snapshot_upserted, EventType.snapshot_deleted, EventType.label_upserted, EventType.notification_upserted, EventType.notification_deleted, EventType.manifested_label_upserted, EventType.manifested_label_deleted, EventType.local_item_upserted, EventType.local_item_deleted, EventType.checkout_optin_responses_upserted, EventType.checkout_optin_responses_deleted, EventType.browse_optin_responses_upserted, EventType.browse_optin_responses_deleted, EventType.order_placed, EventType.order_placed_v2, EventType.ready_to_fulfill, EventType.membership_upserted_v2, EventType.membership_deleted_v2, EventType.organization_upserted, EventType.organization_deleted, EventType.organization_upserted_v2, EventType.organization_deleted_v2, EventType.organization_short_id_upserted, EventType.organization_short_id_deleted, EventType.organization_default_configurations_upserted, EventType.organization_default_configurations_deleted, EventType.ecommerce_platform_upserted, EventType.ecommerce_platform_deleted, EventType.authorization_deleted_v2, EventType.authorization_status_changed, EventType.card_authorization_upserted_v2, EventType.card_authorization_deleted_v2, EventType.online_authorization_upserted_v2, EventType.online_authorization_deleted_v2, EventType.capture_upserted_v2, EventType.capture_deleted, EventType.card_upserted_v2, EventType.card_deleted, EventType.payment_upserted, EventType.payment_deleted, EventType.refund_upserted_v2, EventType.refund_deleted_v2, EventType.refund_capture_upserted_v2, EventType.reversal_upserted, EventType.reversal_deleted, EventType.capture_identifier_upserted, EventType.capture_identifier_deleted, EventType.refund_identifier_upserted, EventType.refund_identifier_deleted, EventType.virtual_card_capture_upserted, EventType.virtual_card_capture_deleted, EventType.virtual_card_refund_upserted, EventType.virtual_card_refund_deleted, EventType.price_book_upserted, EventType.price_book_deleted, EventType.price_book_item_upserted, EventType.price_book_item_deleted, EventType.organization_rates_published, EventType.ratecard_lane_upserted, EventType.ratecard_lane_deleted, EventType.ratecard_upserted, EventType.ratecard_deleted, EventType.return_upserted, EventType.return_deleted, EventType.shopify_localization_setting_upserted, EventType.shopify_localization_setting_deleted, EventType.targeting_item_upserted, EventType.targeting_item_upserted_v2, EventType.targeting_item_deleted, EventType.targeting_item_deleted_v3, EventType.tracking_label_event_upserted]
          end

          def EventType.attribute_upserted
            @@_attribute_upserted ||= EventType.new('attribute_upserted')
          end

          def EventType.attribute_deleted
            @@_attribute_deleted ||= EventType.new('attribute_deleted')
          end

          def EventType.attribute_upserted_v2
            @@_attribute_upserted_v2 ||= EventType.new('attribute_upserted_v2')
          end

          def EventType.attribute_deleted_v2
            @@_attribute_deleted_v2 ||= EventType.new('attribute_deleted_v2')
          end

          def EventType.catalog_upserted
            @@_catalog_upserted ||= EventType.new('catalog_upserted')
          end

          def EventType.catalog_deleted
            @@_catalog_deleted ||= EventType.new('catalog_deleted')
          end

          def EventType.subcatalog_upserted
            @@_subcatalog_upserted ||= EventType.new('subcatalog_upserted')
          end

          def EventType.subcatalog_deleted
            @@_subcatalog_deleted ||= EventType.new('subcatalog_deleted')
          end

          def EventType.catalog_item_upserted
            @@_catalog_item_upserted ||= EventType.new('catalog_item_upserted')
          end

          def EventType.catalog_item_deleted
            @@_catalog_item_deleted ||= EventType.new('catalog_item_deleted')
          end

          def EventType.catalog_item_upserted_v2
            @@_catalog_item_upserted_v2 ||= EventType.new('catalog_item_upserted_v2')
          end

          def EventType.catalog_item_deleted_v2
            @@_catalog_item_deleted_v2 ||= EventType.new('catalog_item_deleted_v2')
          end

          def EventType.subcatalog_item_upserted
            @@_subcatalog_item_upserted ||= EventType.new('subcatalog_item_upserted')
          end

          def EventType.subcatalog_item_deleted
            @@_subcatalog_item_deleted ||= EventType.new('subcatalog_item_deleted')
          end

          def EventType.b2b_invoice_upserted
            @@_b2b_invoice_upserted ||= EventType.new('b2b_invoice_upserted')
          end

          def EventType.b2b_invoice_deleted
            @@_b2b_invoice_deleted ||= EventType.new('b2b_invoice_deleted')
          end

          def EventType.b2b_credit_memo_upserted
            @@_b2b_credit_memo_upserted ||= EventType.new('b2b_credit_memo_upserted')
          end

          def EventType.b2b_credit_memo_deleted
            @@_b2b_credit_memo_deleted ||= EventType.new('b2b_credit_memo_deleted')
          end

          def EventType.consumer_invoice_upserted
            @@_consumer_invoice_upserted ||= EventType.new('consumer_invoice_upserted')
          end

          def EventType.consumer_invoice_deleted
            @@_consumer_invoice_deleted ||= EventType.new('consumer_invoice_deleted')
          end

          def EventType.credit_memo_upserted
            @@_credit_memo_upserted ||= EventType.new('credit_memo_upserted')
          end

          def EventType.credit_memo_deleted
            @@_credit_memo_deleted ||= EventType.new('credit_memo_deleted')
          end

          def EventType.crossdock_shipment_upserted
            @@_crossdock_shipment_upserted ||= EventType.new('crossdock_shipment_upserted')
          end

          def EventType.rate_deleted
            @@_rate_deleted ||= EventType.new('rate_deleted')
          end

          def EventType.rate_upserted
            @@_rate_upserted ||= EventType.new('rate_upserted')
          end

          def EventType.rate_deleted_v3
            @@_rate_deleted_v3 ||= EventType.new('rate_deleted_v3')
          end

          def EventType.rate_upserted_v3
            @@_rate_upserted_v3 ||= EventType.new('rate_upserted_v3')
          end

          def EventType.customer_upserted
            @@_customer_upserted ||= EventType.new('customer_upserted')
          end

          def EventType.customer_deleted
            @@_customer_deleted ||= EventType.new('customer_deleted')
          end

          def EventType.customer_address_book_contact_upserted
            @@_customer_address_book_contact_upserted ||= EventType.new('customer_address_book_contact_upserted')
          end

          def EventType.customer_address_book_contact_deleted
            @@_customer_address_book_contact_deleted ||= EventType.new('customer_address_book_contact_deleted')
          end

          def EventType.email_notification_upserted
            @@_email_notification_upserted ||= EventType.new('email_notification_upserted')
          end

          def EventType.email_notification_deleted
            @@_email_notification_deleted ||= EventType.new('email_notification_deleted')
          end

          def EventType.available_promotions_upserted
            @@_available_promotions_upserted ||= EventType.new('available_promotions_upserted')
          end

          def EventType.available_promotions_deleted
            @@_available_promotions_deleted ||= EventType.new('available_promotions_deleted')
          end

          def EventType.available_promotions_upserted_v2
            @@_available_promotions_upserted_v2 ||= EventType.new('available_promotions_upserted_v2')
          end

          def EventType.available_promotions_deleted_v2
            @@_available_promotions_deleted_v2 ||= EventType.new('available_promotions_deleted_v2')
          end

          def EventType.allocation_deleted_v2
            @@_allocation_deleted_v2 ||= EventType.new('allocation_deleted_v2')
          end

          def EventType.allocation_upserted_v2
            @@_allocation_upserted_v2 ||= EventType.new('allocation_upserted_v2')
          end

          def EventType.currency_format_deleted
            @@_currency_format_deleted ||= EventType.new('currency_format_deleted')
          end

          def EventType.currency_format_upserted
            @@_currency_format_upserted ||= EventType.new('currency_format_upserted')
          end

          def EventType.experience_deleted
            @@_experience_deleted ||= EventType.new('experience_deleted')
          end

          def EventType.experience_upserted
            @@_experience_upserted ||= EventType.new('experience_upserted')
          end

          def EventType.experience_deleted_v2
            @@_experience_deleted_v2 ||= EventType.new('experience_deleted_v2')
          end

          def EventType.experience_upserted_v2
            @@_experience_upserted_v2 ||= EventType.new('experience_upserted_v2')
          end

          def EventType.experience_price_book_mapping_deleted
            @@_experience_price_book_mapping_deleted ||= EventType.new('experience_price_book_mapping_deleted')
          end

          def EventType.experience_price_book_mapping_upserted
            @@_experience_price_book_mapping_upserted ||= EventType.new('experience_price_book_mapping_upserted')
          end

          def EventType.experience_logistics_settings_upserted
            @@_experience_logistics_settings_upserted ||= EventType.new('experience_logistics_settings_upserted')
          end

          def EventType.experience_logistics_settings_deleted
            @@_experience_logistics_settings_deleted ||= EventType.new('experience_logistics_settings_deleted')
          end

          def EventType.item_margin_deleted
            @@_item_margin_deleted ||= EventType.new('item_margin_deleted')
          end

          def EventType.item_margin_upserted
            @@_item_margin_upserted ||= EventType.new('item_margin_upserted')
          end

          def EventType.item_sales_margin_deleted
            @@_item_sales_margin_deleted ||= EventType.new('item_sales_margin_deleted')
          end

          def EventType.item_sales_margin_upserted
            @@_item_sales_margin_upserted ||= EventType.new('item_sales_margin_upserted')
          end

          def EventType.label_format_deleted
            @@_label_format_deleted ||= EventType.new('label_format_deleted')
          end

          def EventType.label_format_upserted
            @@_label_format_upserted ||= EventType.new('label_format_upserted')
          end

          def EventType.order_deleted
            @@_order_deleted ||= EventType.new('order_deleted')
          end

          def EventType.order_upserted
            @@_order_upserted ||= EventType.new('order_upserted')
          end

          def EventType.order_deleted_v2
            @@_order_deleted_v2 ||= EventType.new('order_deleted_v2')
          end

          def EventType.order_upserted_v2
            @@_order_upserted_v2 ||= EventType.new('order_upserted_v2')
          end

          def EventType.order_identifier_deleted
            @@_order_identifier_deleted ||= EventType.new('order_identifier_deleted')
          end

          def EventType.order_identifier_upserted
            @@_order_identifier_upserted ||= EventType.new('order_identifier_upserted')
          end

          def EventType.order_identifier_deleted_v2
            @@_order_identifier_deleted_v2 ||= EventType.new('order_identifier_deleted_v2')
          end

          def EventType.order_identifier_upserted_v2
            @@_order_identifier_upserted_v2 ||= EventType.new('order_identifier_upserted_v2')
          end

          def EventType.order_identifier_upserted_v3
            @@_order_identifier_upserted_v3 ||= EventType.new('order_identifier_upserted_v3')
          end

          def EventType.pricing_deleted
            @@_pricing_deleted ||= EventType.new('pricing_deleted')
          end

          def EventType.pricing_upserted
            @@_pricing_upserted ||= EventType.new('pricing_upserted')
          end

          def EventType.order_service_change_request
            @@_order_service_change_request ||= EventType.new('order_service_change_request')
          end

          def EventType.fraud_status_changed
            @@_fraud_status_changed ||= EventType.new('fraud_status_changed')
          end

          def EventType.center_upserted
            @@_center_upserted ||= EventType.new('center_upserted')
          end

          def EventType.center_deleted
            @@_center_deleted ||= EventType.new('center_deleted')
          end

          def EventType.shipping_configuration_upserted
            @@_shipping_configuration_upserted ||= EventType.new('shipping_configuration_upserted')
          end

          def EventType.shipping_configuration_deleted
            @@_shipping_configuration_deleted ||= EventType.new('shipping_configuration_deleted')
          end

          def EventType.tier_upserted_v2
            @@_tier_upserted_v2 ||= EventType.new('tier_upserted_v2')
          end

          def EventType.tier_deleted_v2
            @@_tier_deleted_v2 ||= EventType.new('tier_deleted_v2')
          end

          def EventType.shipping_lane_upserted
            @@_shipping_lane_upserted ||= EventType.new('shipping_lane_upserted')
          end

          def EventType.shipping_lane_deleted
            @@_shipping_lane_deleted ||= EventType.new('shipping_lane_deleted')
          end

          def EventType.shipping_configuration_item_availability_upserted
            @@_shipping_configuration_item_availability_upserted ||= EventType.new('shipping_configuration_item_availability_upserted')
          end

          def EventType.shipping_configuration_item_availability_deleted
            @@_shipping_configuration_item_availability_deleted ||= EventType.new('shipping_configuration_item_availability_deleted')
          end

          def EventType.shipping_configuration_item_shipping_pricing_upserted
            @@_shipping_configuration_item_shipping_pricing_upserted ||= EventType.new('shipping_configuration_item_shipping_pricing_upserted')
          end

          def EventType.shipping_configuration_item_shipping_pricing_deleted
            @@_shipping_configuration_item_shipping_pricing_deleted ||= EventType.new('shipping_configuration_item_shipping_pricing_deleted')
          end

          def EventType.hs6_code_upserted
            @@_hs6_code_upserted ||= EventType.new('hs6_code_upserted')
          end

          def EventType.hs6_code_deleted
            @@_hs6_code_deleted ||= EventType.new('hs6_code_deleted')
          end

          def EventType.hs10_code_upserted
            @@_hs10_code_upserted ||= EventType.new('hs10_code_upserted')
          end

          def EventType.hs10_code_deleted
            @@_hs10_code_deleted ||= EventType.new('hs10_code_deleted')
          end

          def EventType.item_origin_upserted
            @@_item_origin_upserted ||= EventType.new('item_origin_upserted')
          end

          def EventType.item_origin_deleted
            @@_item_origin_deleted ||= EventType.new('item_origin_deleted')
          end

          def EventType.harmonized_landed_cost_upserted
            @@_harmonized_landed_cost_upserted ||= EventType.new('harmonized_landed_cost_upserted')
          end

          def EventType.fully_harmonized_item_upserted
            @@_fully_harmonized_item_upserted ||= EventType.new('fully_harmonized_item_upserted')
          end

          def EventType.rule_upserted
            @@_rule_upserted ||= EventType.new('rule_upserted')
          end

          def EventType.rule_deleted
            @@_rule_deleted ||= EventType.new('rule_deleted')
          end

          def EventType.serial_upserted
            @@_serial_upserted ||= EventType.new('serial_upserted')
          end

          def EventType.serial_deleted
            @@_serial_deleted ||= EventType.new('serial_deleted')
          end

          def EventType.snapshot_upserted
            @@_snapshot_upserted ||= EventType.new('snapshot_upserted')
          end

          def EventType.snapshot_deleted
            @@_snapshot_deleted ||= EventType.new('snapshot_deleted')
          end

          def EventType.label_upserted
            @@_label_upserted ||= EventType.new('label_upserted')
          end

          def EventType.notification_upserted
            @@_notification_upserted ||= EventType.new('notification_upserted')
          end

          def EventType.notification_deleted
            @@_notification_deleted ||= EventType.new('notification_deleted')
          end

          def EventType.manifested_label_upserted
            @@_manifested_label_upserted ||= EventType.new('manifested_label_upserted')
          end

          def EventType.manifested_label_deleted
            @@_manifested_label_deleted ||= EventType.new('manifested_label_deleted')
          end

          def EventType.local_item_upserted
            @@_local_item_upserted ||= EventType.new('local_item_upserted')
          end

          def EventType.local_item_deleted
            @@_local_item_deleted ||= EventType.new('local_item_deleted')
          end

          def EventType.checkout_optin_responses_upserted
            @@_checkout_optin_responses_upserted ||= EventType.new('checkout_optin_responses_upserted')
          end

          def EventType.checkout_optin_responses_deleted
            @@_checkout_optin_responses_deleted ||= EventType.new('checkout_optin_responses_deleted')
          end

          def EventType.browse_optin_responses_upserted
            @@_browse_optin_responses_upserted ||= EventType.new('browse_optin_responses_upserted')
          end

          def EventType.browse_optin_responses_deleted
            @@_browse_optin_responses_deleted ||= EventType.new('browse_optin_responses_deleted')
          end

          def EventType.order_placed
            @@_order_placed ||= EventType.new('order_placed')
          end

          def EventType.order_placed_v2
            @@_order_placed_v2 ||= EventType.new('order_placed_v2')
          end

          def EventType.ready_to_fulfill
            @@_ready_to_fulfill ||= EventType.new('ready_to_fulfill')
          end

          def EventType.membership_upserted_v2
            @@_membership_upserted_v2 ||= EventType.new('membership_upserted_v2')
          end

          def EventType.membership_deleted_v2
            @@_membership_deleted_v2 ||= EventType.new('membership_deleted_v2')
          end

          def EventType.organization_upserted
            @@_organization_upserted ||= EventType.new('organization_upserted')
          end

          def EventType.organization_deleted
            @@_organization_deleted ||= EventType.new('organization_deleted')
          end

          def EventType.organization_upserted_v2
            @@_organization_upserted_v2 ||= EventType.new('organization_upserted_v2')
          end

          def EventType.organization_deleted_v2
            @@_organization_deleted_v2 ||= EventType.new('organization_deleted_v2')
          end

          def EventType.organization_short_id_upserted
            @@_organization_short_id_upserted ||= EventType.new('organization_short_id_upserted')
          end

          def EventType.organization_short_id_deleted
            @@_organization_short_id_deleted ||= EventType.new('organization_short_id_deleted')
          end

          def EventType.organization_default_configurations_upserted
            @@_organization_default_configurations_upserted ||= EventType.new('organization_default_configurations_upserted')
          end

          def EventType.organization_default_configurations_deleted
            @@_organization_default_configurations_deleted ||= EventType.new('organization_default_configurations_deleted')
          end

          def EventType.ecommerce_platform_upserted
            @@_ecommerce_platform_upserted ||= EventType.new('ecommerce_platform_upserted')
          end

          def EventType.ecommerce_platform_deleted
            @@_ecommerce_platform_deleted ||= EventType.new('ecommerce_platform_deleted')
          end

          def EventType.authorization_deleted_v2
            @@_authorization_deleted_v2 ||= EventType.new('authorization_deleted_v2')
          end

          def EventType.authorization_status_changed
            @@_authorization_status_changed ||= EventType.new('authorization_status_changed')
          end

          def EventType.card_authorization_upserted_v2
            @@_card_authorization_upserted_v2 ||= EventType.new('card_authorization_upserted_v2')
          end

          def EventType.card_authorization_deleted_v2
            @@_card_authorization_deleted_v2 ||= EventType.new('card_authorization_deleted_v2')
          end

          def EventType.online_authorization_upserted_v2
            @@_online_authorization_upserted_v2 ||= EventType.new('online_authorization_upserted_v2')
          end

          def EventType.online_authorization_deleted_v2
            @@_online_authorization_deleted_v2 ||= EventType.new('online_authorization_deleted_v2')
          end

          def EventType.capture_upserted_v2
            @@_capture_upserted_v2 ||= EventType.new('capture_upserted_v2')
          end

          def EventType.capture_deleted
            @@_capture_deleted ||= EventType.new('capture_deleted')
          end

          def EventType.card_upserted_v2
            @@_card_upserted_v2 ||= EventType.new('card_upserted_v2')
          end

          def EventType.card_deleted
            @@_card_deleted ||= EventType.new('card_deleted')
          end

          def EventType.payment_upserted
            @@_payment_upserted ||= EventType.new('payment_upserted')
          end

          def EventType.payment_deleted
            @@_payment_deleted ||= EventType.new('payment_deleted')
          end

          def EventType.refund_upserted_v2
            @@_refund_upserted_v2 ||= EventType.new('refund_upserted_v2')
          end

          def EventType.refund_deleted_v2
            @@_refund_deleted_v2 ||= EventType.new('refund_deleted_v2')
          end

          def EventType.refund_capture_upserted_v2
            @@_refund_capture_upserted_v2 ||= EventType.new('refund_capture_upserted_v2')
          end

          def EventType.reversal_upserted
            @@_reversal_upserted ||= EventType.new('reversal_upserted')
          end

          def EventType.reversal_deleted
            @@_reversal_deleted ||= EventType.new('reversal_deleted')
          end

          def EventType.capture_identifier_upserted
            @@_capture_identifier_upserted ||= EventType.new('capture_identifier_upserted')
          end

          def EventType.capture_identifier_deleted
            @@_capture_identifier_deleted ||= EventType.new('capture_identifier_deleted')
          end

          def EventType.refund_identifier_upserted
            @@_refund_identifier_upserted ||= EventType.new('refund_identifier_upserted')
          end

          def EventType.refund_identifier_deleted
            @@_refund_identifier_deleted ||= EventType.new('refund_identifier_deleted')
          end

          def EventType.virtual_card_capture_upserted
            @@_virtual_card_capture_upserted ||= EventType.new('virtual_card_capture_upserted')
          end

          def EventType.virtual_card_capture_deleted
            @@_virtual_card_capture_deleted ||= EventType.new('virtual_card_capture_deleted')
          end

          def EventType.virtual_card_refund_upserted
            @@_virtual_card_refund_upserted ||= EventType.new('virtual_card_refund_upserted')
          end

          def EventType.virtual_card_refund_deleted
            @@_virtual_card_refund_deleted ||= EventType.new('virtual_card_refund_deleted')
          end

          def EventType.price_book_upserted
            @@_price_book_upserted ||= EventType.new('price_book_upserted')
          end

          def EventType.price_book_deleted
            @@_price_book_deleted ||= EventType.new('price_book_deleted')
          end

          def EventType.price_book_item_upserted
            @@_price_book_item_upserted ||= EventType.new('price_book_item_upserted')
          end

          def EventType.price_book_item_deleted
            @@_price_book_item_deleted ||= EventType.new('price_book_item_deleted')
          end

          def EventType.organization_rates_published
            @@_organization_rates_published ||= EventType.new('organization_rates_published')
          end

          def EventType.ratecard_lane_upserted
            @@_ratecard_lane_upserted ||= EventType.new('ratecard_lane_upserted')
          end

          def EventType.ratecard_lane_deleted
            @@_ratecard_lane_deleted ||= EventType.new('ratecard_lane_deleted')
          end

          def EventType.ratecard_upserted
            @@_ratecard_upserted ||= EventType.new('ratecard_upserted')
          end

          def EventType.ratecard_deleted
            @@_ratecard_deleted ||= EventType.new('ratecard_deleted')
          end

          def EventType.return_upserted
            @@_return_upserted ||= EventType.new('return_upserted')
          end

          def EventType.return_deleted
            @@_return_deleted ||= EventType.new('return_deleted')
          end

          def EventType.shopify_localization_setting_upserted
            @@_shopify_localization_setting_upserted ||= EventType.new('shopify_localization_setting_upserted')
          end

          def EventType.shopify_localization_setting_deleted
            @@_shopify_localization_setting_deleted ||= EventType.new('shopify_localization_setting_deleted')
          end

          def EventType.targeting_item_upserted
            @@_targeting_item_upserted ||= EventType.new('targeting_item_upserted')
          end

          def EventType.targeting_item_upserted_v2
            @@_targeting_item_upserted_v2 ||= EventType.new('targeting_item_upserted_v2')
          end

          def EventType.targeting_item_deleted
            @@_targeting_item_deleted ||= EventType.new('targeting_item_deleted')
          end

          def EventType.targeting_item_deleted_v3
            @@_targeting_item_deleted_v3 ||= EventType.new('targeting_item_deleted_v3')
          end

          def EventType.tracking_label_event_upserted
            @@_tracking_label_event_upserted ||= EventType.new('tracking_label_event_upserted')
          end

          def to_hash
            value
          end

        end

        class ExceptionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExceptionType for this value, creating a new instance for an unknown value
          def ExceptionType.apply(value)
            if value.instance_of?(ExceptionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExceptionType.new(value))
            end
          end

          # Returns the instance of ExceptionType for this value, or nil if not found
          def ExceptionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExceptionType.ALL.find { |v| v.value == value }
          end

          def ExceptionType.ALL
            @@all ||= [ExceptionType.open, ExceptionType.closed]
          end

          def ExceptionType.open
            @@_open ||= ExceptionType.new('open')
          end

          def ExceptionType.closed
            @@_closed ||= ExceptionType.new('closed')
          end

          def to_hash
            value
          end

        end

        class ExclusionRuleState

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExclusionRuleState for this value, creating a new instance for an unknown value
          def ExclusionRuleState.apply(value)
            if value.instance_of?(ExclusionRuleState)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExclusionRuleState.new(value))
            end
          end

          # Returns the instance of ExclusionRuleState for this value, or nil if not found
          def ExclusionRuleState.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExclusionRuleState.ALL.find { |v| v.value == value }
          end

          def ExclusionRuleState.ALL
            @@all ||= [ExclusionRuleState.current, ExclusionRuleState.deleting, ExclusionRuleState.updating]
          end

          def ExclusionRuleState.current
            @@_current ||= ExclusionRuleState.new('current')
          end

          def ExclusionRuleState.deleting
            @@_deleting ||= ExclusionRuleState.new('deleting')
          end

          def ExclusionRuleState.updating
            @@_updating ||= ExclusionRuleState.new('updating')
          end

          def to_hash
            value
          end

        end

        class ExperienceCloneStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExperienceCloneStatus for this value, creating a new instance for an unknown value
          def ExperienceCloneStatus.apply(value)
            if value.instance_of?(ExperienceCloneStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExperienceCloneStatus.new(value))
            end
          end

          # Returns the instance of ExperienceCloneStatus for this value, or nil if not found
          def ExperienceCloneStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExperienceCloneStatus.ALL.find { |v| v.value == value }
          end

          def ExperienceCloneStatus.ALL
            @@all ||= [ExperienceCloneStatus.pending, ExperienceCloneStatus.updating, ExperienceCloneStatus.completed, ExperienceCloneStatus.failed]
          end

          def ExperienceCloneStatus.pending
            @@_pending ||= ExperienceCloneStatus.new('pending')
          end

          def ExperienceCloneStatus.updating
            @@_updating ||= ExperienceCloneStatus.new('updating')
          end

          def ExperienceCloneStatus.completed
            @@_completed ||= ExperienceCloneStatus.new('completed')
          end

          def ExperienceCloneStatus.failed
            @@_failed ||= ExperienceCloneStatus.new('failed')
          end

          def to_hash
            value
          end

        end

        class ExperiencePaymentMethodTag < PaymentMethodTag

          attr_reader :value

          def initialize(value)
            super(:name => PaymentMethodTag::Types::EXPERIENCE_PAYMENT_METHOD_TAG, :discriminator => 'experience_payment_method_tag')
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExperiencePaymentMethodTag for this value, creating a new instance for an unknown value
          def ExperiencePaymentMethodTag.apply(value)
            if value.instance_of?(ExperiencePaymentMethodTag)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExperiencePaymentMethodTag.new(value))
            end
          end

          # Returns the instance of ExperiencePaymentMethodTag for this value, or nil if not found
          def ExperiencePaymentMethodTag.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExperiencePaymentMethodTag.ALL.find { |v| v.value == value }
          end

          def ExperiencePaymentMethodTag.ALL
            @@all ||= [ExperiencePaymentMethodTag.display]
          end

          # A displayed payment method will be highlighted during the checkout process for
          # an experience.
          def ExperiencePaymentMethodTag.display
            @@_display ||= ExperiencePaymentMethodTag.new('display')
          end

          def subtype_to_hash
            value
          end

        end

        class ExperienceStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExperienceStatus for this value, creating a new instance for an unknown value
          def ExperienceStatus.apply(value)
            if value.instance_of?(ExperienceStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExperienceStatus.new(value))
            end
          end

          # Returns the instance of ExperienceStatus for this value, or nil if not found
          def ExperienceStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExperienceStatus.ALL.find { |v| v.value == value }
          end

          def ExperienceStatus.ALL
            @@all ||= [ExperienceStatus.draft, ExperienceStatus.active, ExperienceStatus.archiving, ExperienceStatus.archived]
          end

          def ExperienceStatus.draft
            @@_draft ||= ExperienceStatus.new('draft')
          end

          def ExperienceStatus.active
            @@_active ||= ExperienceStatus.new('active')
          end

          # Archiving indicates an experience has been archived. We allow some time for
          # sessions to expire before fully marking the experience archived.
          def ExperienceStatus.archiving
            @@_archiving ||= ExperienceStatus.new('archiving')
          end

          def ExperienceStatus.archived
            @@_archived ||= ExperienceStatus.new('archived')
          end

          def to_hash
            value
          end

        end

        class ExportStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExportStatus for this value, creating a new instance for an unknown value
          def ExportStatus.apply(value)
            if value.instance_of?(ExportStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExportStatus.new(value))
            end
          end

          # Returns the instance of ExportStatus for this value, or nil if not found
          def ExportStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExportStatus.ALL.find { |v| v.value == value }
          end

          def ExportStatus.ALL
            @@all ||= [ExportStatus.created, ExportStatus.processing, ExportStatus.completed, ExportStatus.failed]
          end

          def ExportStatus.created
            @@_created ||= ExportStatus.new('created')
          end

          def ExportStatus.processing
            @@_processing ||= ExportStatus.new('processing')
          end

          def ExportStatus.completed
            @@_completed ||= ExportStatus.new('completed')
          end

          def ExportStatus.failed
            @@_failed ||= ExportStatus.new('failed')
          end

          def to_hash
            value
          end

        end

        class FlowAddonRole < FlowRole

          attr_reader :value

          def initialize(value)
            super(:name => FlowRole::Types::FLOW_ADDON_ROLE, :__discriminator__ => 'flow_addon_role')
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FlowAddonRole for this value, creating a new instance for an unknown value
          def FlowAddonRole.apply(value)
            if value.instance_of?(FlowAddonRole)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FlowAddonRole.new(value))
            end
          end

          # Returns the instance of FlowAddonRole for this value, or nil if not found
          def FlowAddonRole.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FlowAddonRole.ALL.find { |v| v.value == value }
          end

          def FlowAddonRole.ALL
            @@all ||= [FlowAddonRole.consumer_data_viewer, FlowAddonRole.membership_manager]
          end

          # Can view consumer's private data
          def FlowAddonRole.consumer_data_viewer
            @@_consumer_data_viewer ||= FlowAddonRole.new('consumer_data_viewer')
          end

          # Can invite new users to the org.
          def FlowAddonRole.membership_manager
            @@_membership_manager ||= FlowAddonRole.new('membership_manager')
          end

          def subtype_to_hash
            value
          end

        end

        class FlowBehavior

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FlowBehavior for this value, creating a new instance for an unknown value
          def FlowBehavior.apply(value)
            if value.instance_of?(FlowBehavior)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FlowBehavior.new(value))
            end
          end

          # Returns the instance of FlowBehavior for this value, or nil if not found
          def FlowBehavior.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FlowBehavior.ALL.find { |v| v.value == value }
          end

          def FlowBehavior.ALL
            @@all ||= [FlowBehavior.view_consumer_data]
          end

          # Allows user to view consumers' personal data.
          def FlowBehavior.view_consumer_data
            @@_view_consumer_data ||= FlowBehavior.new('view_consumer_data')
          end

          def to_hash
            value
          end

        end

        class FlowUserRole < FlowRole

          attr_reader :value

          def initialize(value)
            super(:name => FlowRole::Types::FLOW_USER_ROLE, :__discriminator__ => 'flow_user_role')
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FlowUserRole for this value, creating a new instance for an unknown value
          def FlowUserRole.apply(value)
            if value.instance_of?(FlowUserRole)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FlowUserRole.new(value))
            end
          end

          # Returns the instance of FlowUserRole for this value, or nil if not found
          def FlowUserRole.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FlowUserRole.ALL.find { |v| v.value == value }
          end

          def FlowUserRole.ALL
            @@all ||= [FlowUserRole.organization_admin, FlowUserRole.organization_merchant, FlowUserRole.organization_operations, FlowUserRole.organization_fulfillment, FlowUserRole.organization_marketing, FlowUserRole.organization_finance, FlowUserRole.flow_operations]
          end

          # Can fully administrate a merchant organization.
          def FlowUserRole.organization_admin
            @@_organization_admin ||= FlowUserRole.new('organization_admin')
          end

          # Can access merchant functions such as analytics, billing, experiences.
          def FlowUserRole.organization_merchant
            @@_organization_merchant ||= FlowUserRole.new('organization_merchant')
          end

          # Can access customer service functions and retreive relevant data.
          def FlowUserRole.organization_operations
            @@_organization_operations ||= FlowUserRole.new('organization_operations')
          end

          # Can access fulfillment functions and retreive relevant data.
          def FlowUserRole.organization_fulfillment
            @@_organization_fulfillment ||= FlowUserRole.new('organization_fulfillment')
          end

          # Can access marketing functions and retreive relevant data.
          def FlowUserRole.organization_marketing
            @@_organization_marketing ||= FlowUserRole.new('organization_marketing')
          end

          # Can access billing and reconcilliation functions and retreive relevant data.
          def FlowUserRole.organization_finance
            @@_organization_finance ||= FlowUserRole.new('organization_finance')
          end

          # Can access Flow internal functions.
          def FlowUserRole.flow_operations
            @@_flow_operations ||= FlowUserRole.new('flow_operations')
          end

          def subtype_to_hash
            value
          end

        end

        class FraudEmailRuleDecision

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FraudEmailRuleDecision for this value, creating a new instance for an unknown value
          def FraudEmailRuleDecision.apply(value)
            if value.instance_of?(FraudEmailRuleDecision)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FraudEmailRuleDecision.new(value))
            end
          end

          # Returns the instance of FraudEmailRuleDecision for this value, or nil if not found
          def FraudEmailRuleDecision.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FraudEmailRuleDecision.ALL.find { |v| v.value == value }
          end

          def FraudEmailRuleDecision.ALL
            @@all ||= [FraudEmailRuleDecision.approved, FraudEmailRuleDecision.declined]
          end

          # Approve all orders matching the customers email address.
          def FraudEmailRuleDecision.approved
            @@_approved ||= FraudEmailRuleDecision.new('approved')
          end

          # Decline all orders matching the customers email address.
          def FraudEmailRuleDecision.declined
            @@_declined ||= FraudEmailRuleDecision.new('declined')
          end

          def to_hash
            value
          end

        end

        class FraudLiability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FraudLiability for this value, creating a new instance for an unknown value
          def FraudLiability.apply(value)
            if value.instance_of?(FraudLiability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FraudLiability.new(value))
            end
          end

          # Returns the instance of FraudLiability for this value, or nil if not found
          def FraudLiability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FraudLiability.ALL.find { |v| v.value == value }
          end

          def FraudLiability.ALL
            @@all ||= [FraudLiability.flow, FraudLiability.organization]
          end

          # Flow takes any fraud liability for the order.
          def FraudLiability.flow
            @@_flow ||= FraudLiability.new('flow')
          end

          # The merchant takes any fraud liability for the order.
          def FraudLiability.organization
            @@_organization ||= FraudLiability.new('organization')
          end

          def to_hash
            value
          end

        end

        class FraudStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FraudStatus for this value, creating a new instance for an unknown value
          def FraudStatus.apply(value)
            if value.instance_of?(FraudStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FraudStatus.new(value))
            end
          end

          # Returns the instance of FraudStatus for this value, or nil if not found
          def FraudStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FraudStatus.ALL.find { |v| v.value == value }
          end

          def FraudStatus.ALL
            @@all ||= [FraudStatus.pending, FraudStatus.approved, FraudStatus.declined, FraudStatus.review]
          end

          # If an immediate response is not available, the state will be 'pending'.
          def FraudStatus.pending
            @@_pending ||= FraudStatus.new('pending')
          end

          # Fraud check has passed and the order is approved.
          def FraudStatus.approved
            @@_approved ||= FraudStatus.new('approved')
          end

          # Indicates the fraud check has been declined by the fraud providing service.
          def FraudStatus.declined
            @@_declined ||= FraudStatus.new('declined')
          end

          # Indicates the fraud check decision from the fraud providing service is being
          # reviewed.
          def FraudStatus.review
            @@_review ||= FraudStatus.new('review')
          end

          def to_hash
            value
          end

        end

        class FtpFileSource

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FtpFileSource for this value, creating a new instance for an unknown value
          def FtpFileSource.apply(value)
            if value.instance_of?(FtpFileSource)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FtpFileSource.new(value))
            end
          end

          # Returns the instance of FtpFileSource for this value, or nil if not found
          def FtpFileSource.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FtpFileSource.ALL.find { |v| v.value == value }
          end

          def FtpFileSource.ALL
            @@all ||= [FtpFileSource.flow, FtpFileSource.organization]
          end

          # Indicates flow created this file
          def FtpFileSource.flow
            @@_flow ||= FtpFileSource.new('flow')
          end

          # Indicates the organization created this file
          def FtpFileSource.organization
            @@_organization ||= FtpFileSource.new('organization')
          end

          def to_hash
            value
          end

        end

        class FulfillmentItemQuantityStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FulfillmentItemQuantityStatus for this value, creating a new instance for an unknown value
          def FulfillmentItemQuantityStatus.apply(value)
            if value.instance_of?(FulfillmentItemQuantityStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FulfillmentItemQuantityStatus.new(value))
            end
          end

          # Returns the instance of FulfillmentItemQuantityStatus for this value, or nil if not found
          def FulfillmentItemQuantityStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FulfillmentItemQuantityStatus.ALL.find { |v| v.value == value }
          end

          def FulfillmentItemQuantityStatus.ALL
            @@all ||= [FulfillmentItemQuantityStatus.new, FulfillmentItemQuantityStatus.shipped, FulfillmentItemQuantityStatus.cancelled]
          end

          # Item may be shipped or cancelled
          def FulfillmentItemQuantityStatus.new
            @@_new ||= FulfillmentItemQuantityStatus.new('new')
          end

          # Item has been packaged for shipment; can no longer be cancelled.
          def FulfillmentItemQuantityStatus.shipped
            @@_shipped ||= FulfillmentItemQuantityStatus.new('shipped')
          end

          # Item will not be fulfilled.
          def FulfillmentItemQuantityStatus.cancelled
            @@_cancelled ||= FulfillmentItemQuantityStatus.new('cancelled')
          end

          def to_hash
            value
          end

        end

        class FulfillmentMethodType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FulfillmentMethodType for this value, creating a new instance for an unknown value
          def FulfillmentMethodType.apply(value)
            if value.instance_of?(FulfillmentMethodType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FulfillmentMethodType.new(value))
            end
          end

          # Returns the instance of FulfillmentMethodType for this value, or nil if not found
          def FulfillmentMethodType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FulfillmentMethodType.ALL.find { |v| v.value == value }
          end

          def FulfillmentMethodType.ALL
            @@all ||= [FulfillmentMethodType.fulfillment_method]
          end

          # Indicates how an item will be shipped or fulfilled.  Acceptable values are
          # defined by the 'fulfillment_method_value' enum.
          def FulfillmentMethodType.fulfillment_method
            @@_fulfillment_method ||= FulfillmentMethodType.new('fulfillment_method')
          end

          def to_hash
            value
          end

        end

        class FulfillmentMethodValue

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FulfillmentMethodValue for this value, creating a new instance for an unknown value
          def FulfillmentMethodValue.apply(value)
            if value.instance_of?(FulfillmentMethodValue)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FulfillmentMethodValue.new(value))
            end
          end

          # Returns the instance of FulfillmentMethodValue for this value, or nil if not found
          def FulfillmentMethodValue.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FulfillmentMethodValue.ALL.find { |v| v.value == value }
          end

          def FulfillmentMethodValue.ALL
            @@all ||= [FulfillmentMethodValue.digital, FulfillmentMethodValue.physical]
          end

          # Indicates item will be fulfilled digitally and no shipment is required (e.g.
          # Gift Card).
          def FulfillmentMethodValue.digital
            @@_digital ||= FulfillmentMethodValue.new('digital')
          end

          # Indicates item will be shipped in a physical package.
          def FulfillmentMethodValue.physical
            @@_physical ||= FulfillmentMethodValue.new('physical')
          end

          def to_hash
            value
          end

        end

        class GenericErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of GenericErrorCode for this value, creating a new instance for an unknown value
          def GenericErrorCode.apply(value)
            if value.instance_of?(GenericErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || GenericErrorCode.new(value))
            end
          end

          # Returns the instance of GenericErrorCode for this value, or nil if not found
          def GenericErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            GenericErrorCode.ALL.find { |v| v.value == value }
          end

          def GenericErrorCode.ALL
            @@all ||= [GenericErrorCode.generic_error, GenericErrorCode.client_error, GenericErrorCode.server_error]
          end

          # Generic errors are the default type. The accompanying message will provide
          # details on the failure.
          def GenericErrorCode.generic_error
            @@_generic_error ||= GenericErrorCode.new('generic_error')
          end

          # A client error has occurred. This represents a misconfiguration of the client
          def GenericErrorCode.client_error
            @@_client_error ||= GenericErrorCode.new('client_error')
          end

          # A server error has occurred. The Flow tech team is automatically notified of
          # all server errors
          def GenericErrorCode.server_error
            @@_server_error ||= GenericErrorCode.new('server_error')
          end

          def to_hash
            value
          end

        end

        class GoodsSupply

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of GoodsSupply for this value, creating a new instance for an unknown value
          def GoodsSupply.apply(value)
            if value.instance_of?(GoodsSupply)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || GoodsSupply.new(value))
            end
          end

          # Returns the instance of GoodsSupply for this value, or nil if not found
          def GoodsSupply.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            GoodsSupply.ALL.find { |v| v.value == value }
          end

          def GoodsSupply.ALL
            @@all ||= [GoodsSupply.export, GoodsSupply.intra_community, GoodsSupply.local]
          end

          # Goods will be supplied from a DC from outside the national and customs
          # boundaries of the destination.
          def GoodsSupply.export
            @@_export ||= GoodsSupply.new('export')
          end

          # Goods will be supplied from a DC outside the national boundries of the
          # destination, but within the same customs union.
          def GoodsSupply.intra_community
            @@_intra_community ||= GoodsSupply.new('intra_community')
          end

          # Goods will be supplied from a DC within the same country as the destination.
          def GoodsSupply.local
            @@_local ||= GoodsSupply.new('local')
          end

          def to_hash
            value
          end

        end

        class HolidayCalendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of HolidayCalendar for this value, creating a new instance for an unknown value
          def HolidayCalendar.apply(value)
            if value.instance_of?(HolidayCalendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || HolidayCalendar.new(value))
            end
          end

          # Returns the instance of HolidayCalendar for this value, or nil if not found
          def HolidayCalendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            HolidayCalendar.ALL.find { |v| v.value == value }
          end

          def HolidayCalendar.ALL
            @@all ||= [HolidayCalendar.us_bank_holidays, HolidayCalendar.jewish_holidays]
          end

          def HolidayCalendar.us_bank_holidays
            @@_us_bank_holidays ||= HolidayCalendar.new('us_bank_holidays')
          end

          def HolidayCalendar.jewish_holidays
            @@_jewish_holidays ||= HolidayCalendar.new('jewish_holidays')
          end

          def to_hash
            value
          end

        end

        class ImageTag

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ImageTag for this value, creating a new instance for an unknown value
          def ImageTag.apply(value)
            if value.instance_of?(ImageTag)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ImageTag.new(value))
            end
          end

          # Returns the instance of ImageTag for this value, or nil if not found
          def ImageTag.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ImageTag.ALL.find { |v| v.value == value }
          end

          def ImageTag.ALL
            @@all ||= [ImageTag.thumbnail, ImageTag.checkout]
          end

          # Thumbnail images identify the image to use when displaying products in the
          # Flow Console.
          def ImageTag.thumbnail
            @@_thumbnail ||= ImageTag.new('thumbnail')
          end

          # Checkout images identify the item image to use when displaying the item in the
          # context of a consumer checkout (e.g. cart, checkout page).
          def ImageTag.checkout
            @@_checkout ||= ImageTag.new('checkout')
          end

          def to_hash
            value
          end

        end

        class ImportType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ImportType for this value, creating a new instance for an unknown value
          def ImportType.apply(value)
            if value.instance_of?(ImportType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ImportType.new(value))
            end
          end

          # Returns the instance of ImportType for this value, or nil if not found
          def ImportType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ImportType.ALL.find { |v| v.value == value }
          end

          def ImportType.ALL
            @@all ||= [ImportType.catalog_items, ImportType.customs_descriptions, ImportType.customs_description_tariffs, ImportType.experiences_with_settings, ImportType.harmonization_codes, ImportType.item_form_overlays, ImportType.price_book_items, ImportType.price_book_items_query, ImportType.ratecard_lanes, ImportType.order_service_changes]
          end

          # Provides bulk upsert of items into an organization's catalog.
          def ImportType.catalog_items
            @@_catalog_items ||= ImportType.new('catalog_items')
          end

          # Provides upload of customs descriptions for the products in a catalog.
          def ImportType.customs_descriptions
            @@_customs_descriptions ||= ImportType.new('customs_descriptions')
          end

          # Provides upload of customs descriptions and corresponding tariffs. These are
          # independent of any catalog, product, or item.
          def ImportType.customs_description_tariffs
            @@_customs_description_tariffs ||= ImportType.new('customs_description_tariffs')
          end

          # Provides bulk upsert of experiences with associated settings.
          def ImportType.experiences_with_settings
            @@_experiences_with_settings ||= ImportType.new('experiences_with_settings')
          end

          # Provides upload of HS-6 and HS-10 codes for the items in a catalog
          def ImportType.harmonization_codes
            @@_harmonization_codes ||= ImportType.new('harmonization_codes')
          end

          # Item form overlays allow you to upload additional catalog item information
          # that will be applied to each catalog item, even if you later modify the item.
          # You can think of this import as providing catalog item data that will be
          # overlaid on top of the content in your core catalog.
          def ImportType.item_form_overlays
            @@_item_form_overlays ||= ImportType.new('item_form_overlays')
          end

          # Provides bulk upsert of price book items based on item number.
          def ImportType.price_book_items
            @@_price_book_items ||= ImportType.new('price_book_items')
          end

          # Provides bulk upsert of price book items based on a query (e.g. update all
          # items by sku or product id).
          def ImportType.price_book_items_query
            @@_price_book_items_query ||= ImportType.new('price_book_items_query')
          end

          # Provides way to upload a new ratecard with lanes and rates for a service
          # level.
          def ImportType.ratecard_lanes
            @@_ratecard_lanes ||= ImportType.new('ratecard_lanes')
          end

          # Provides way to upload service level changes for orders that require updated
          # shipping methods.
          def ImportType.order_service_changes
            @@_order_service_changes ||= ImportType.new('order_service_changes')
          end

          def to_hash
            value
          end

        end

        class IncludedLevyKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of IncludedLevyKey for this value, creating a new instance for an unknown value
          def IncludedLevyKey.apply(value)
            if value.instance_of?(IncludedLevyKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || IncludedLevyKey.new(value))
            end
          end

          # Returns the instance of IncludedLevyKey for this value, or nil if not found
          def IncludedLevyKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            IncludedLevyKey.ALL.find { |v| v.value == value }
          end

          def IncludedLevyKey.ALL
            @@all ||= [IncludedLevyKey.duty, IncludedLevyKey.vat, IncludedLevyKey.vat_and_duty, IncludedLevyKey.none]
          end

          def IncludedLevyKey.duty
            @@_duty ||= IncludedLevyKey.new('duty')
          end

          def IncludedLevyKey.vat
            @@_vat ||= IncludedLevyKey.new('vat')
          end

          def IncludedLevyKey.vat_and_duty
            @@_vat_and_duty ||= IncludedLevyKey.new('vat_and_duty')
          end

          def IncludedLevyKey.none
            @@_none ||= IncludedLevyKey.new('none')
          end

          def to_hash
            value
          end

        end

        class Incoterm

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Incoterm for this value, creating a new instance for an unknown value
          def Incoterm.apply(value)
            if value.instance_of?(Incoterm)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Incoterm.new(value))
            end
          end

          # Returns the instance of Incoterm for this value, or nil if not found
          def Incoterm.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Incoterm.ALL.find { |v| v.value == value }
          end

          def Incoterm.ALL
            @@all ||= [Incoterm.exw, Incoterm.fca, Incoterm.cpt, Incoterm.cip, Incoterm.dat, Incoterm.dap, Incoterm.ddp, Incoterm.fas, Incoterm.fob, Incoterm.cfr, Incoterm.cif, Incoterm.daf, Incoterm.des, Incoterm.deq, Incoterm.ddu]
          end

          # Ex Works (named place of delivery)
          def Incoterm.exw
            @@_exw ||= Incoterm.new('EXW')
          end

          # Free Carrier (named place of delivery)
          def Incoterm.fca
            @@_fca ||= Incoterm.new('FCA')
          end

          # Carriage Paid To (named place of destination)
          def Incoterm.cpt
            @@_cpt ||= Incoterm.new('CPT')
          end

          # Carriage and Insurance Paid to (named place of destination)
          def Incoterm.cip
            @@_cip ||= Incoterm.new('CIP')
          end

          # Delivered At Terminal (named terminal at port or place of destination)
          def Incoterm.dat
            @@_dat ||= Incoterm.new('DAT')
          end

          # Delivered At Place (named place of destination)
          def Incoterm.dap
            @@_dap ||= Incoterm.new('DAP')
          end

          # Delivered Duty Paid (named place of destination)
          def Incoterm.ddp
            @@_ddp ||= Incoterm.new('DDP')
          end

          # Free Alongside Ship (named port of shipment)
          def Incoterm.fas
            @@_fas ||= Incoterm.new('FAS')
          end

          # Free on Board (named port of shipment)
          def Incoterm.fob
            @@_fob ||= Incoterm.new('FOB')
          end

          # Cost and Freight (named port of destination)
          def Incoterm.cfr
            @@_cfr ||= Incoterm.new('CFR')
          end

          # Cost, Insurance & Freight (named port of destination)
          def Incoterm.cif
            @@_cif ||= Incoterm.new('CIF')
          end

          # Delivered at Frontier (named place of delivery)
          def Incoterm.daf
            @@_daf ||= Incoterm.new('DAF')
          end

          # Delivered Ex Ship
          def Incoterm.des
            @@_des ||= Incoterm.new('DES')
          end

          # Delivered Ex Quay (named port of delivery)
          def Incoterm.deq
            @@_deq ||= Incoterm.new('DEQ')
          end

          # Delivered Duty Unpaid (named place of destination)
          def Incoterm.ddu
            @@_ddu ||= Incoterm.new('DDU')
          end

          def to_hash
            value
          end

        end

        class InputSpecificationType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of InputSpecificationType for this value, creating a new instance for an unknown value
          def InputSpecificationType.apply(value)
            if value.instance_of?(InputSpecificationType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || InputSpecificationType.new(value))
            end
          end

          # Returns the instance of InputSpecificationType for this value, or nil if not found
          def InputSpecificationType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            InputSpecificationType.ALL.find { |v| v.value == value }
          end

          def InputSpecificationType.ALL
            @@all ||= [InputSpecificationType.text, InputSpecificationType.number]
          end

          def InputSpecificationType.text
            @@_text ||= InputSpecificationType.new('text')
          end

          def InputSpecificationType.number
            @@_number ||= InputSpecificationType.new('number')
          end

          def to_hash
            value
          end

        end

        class InstallmentPlanPaymentErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of InstallmentPlanPaymentErrorCode for this value, creating a new instance for an unknown value
          def InstallmentPlanPaymentErrorCode.apply(value)
            if value.instance_of?(InstallmentPlanPaymentErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || InstallmentPlanPaymentErrorCode.new(value))
            end
          end

          # Returns the instance of InstallmentPlanPaymentErrorCode for this value, or nil if not found
          def InstallmentPlanPaymentErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            InstallmentPlanPaymentErrorCode.ALL.find { |v| v.value == value }
          end

          def InstallmentPlanPaymentErrorCode.ALL
            @@all ||= [InstallmentPlanPaymentErrorCode.invalid_authorization, InstallmentPlanPaymentErrorCode.invalid_authorization_amount, InstallmentPlanPaymentErrorCode.invalid_installment_plan]
          end

          # Indicates the specified authorization key does not exist
          def InstallmentPlanPaymentErrorCode.invalid_authorization
            @@_invalid_authorization ||= InstallmentPlanPaymentErrorCode.new('invalid_authorization')
          end

          # Indicates the specified authorization amount does not match the first
          # installment in the plan
          def InstallmentPlanPaymentErrorCode.invalid_authorization_amount
            @@_invalid_authorization_amount ||= InstallmentPlanPaymentErrorCode.new('invalid_authorization_amount')
          end

          # Indicates the specified installment plan does not exist
          def InstallmentPlanPaymentErrorCode.invalid_installment_plan
            @@_invalid_installment_plan ||= InstallmentPlanPaymentErrorCode.new('invalid_installment_plan')
          end

          def to_hash
            value
          end

        end

        class InventoryStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of InventoryStatus for this value, creating a new instance for an unknown value
          def InventoryStatus.apply(value)
            if value.instance_of?(InventoryStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || InventoryStatus.new(value))
            end
          end

          # Returns the instance of InventoryStatus for this value, or nil if not found
          def InventoryStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            InventoryStatus.ALL.find { |v| v.value == value }
          end

          def InventoryStatus.ALL
            @@all ||= [InventoryStatus.has_inventory, InventoryStatus.no_inventory]
          end

          def InventoryStatus.has_inventory
            @@_has_inventory ||= InventoryStatus.new('has_inventory')
          end

          def InventoryStatus.no_inventory
            @@_no_inventory ||= InventoryStatus.new('no_inventory')
          end

          def to_hash
            value
          end

        end

        class InvitationErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of InvitationErrorCode for this value, creating a new instance for an unknown value
          def InvitationErrorCode.apply(value)
            if value.instance_of?(InvitationErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || InvitationErrorCode.new(value))
            end
          end

          # Returns the instance of InvitationErrorCode for this value, or nil if not found
          def InvitationErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            InvitationErrorCode.ALL.find { |v| v.value == value }
          end

          def InvitationErrorCode.ALL
            @@all ||= [InvitationErrorCode.expired, InvitationErrorCode.invalid_email]
          end

          def InvitationErrorCode.expired
            @@_expired ||= InvitationErrorCode.new('expired')
          end

          def InvitationErrorCode.invalid_email
            @@_invalid_email ||= InvitationErrorCode.new('invalid_email')
          end

          def to_hash
            value
          end

        end

        class ItemAvailabilityStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ItemAvailabilityStatus for this value, creating a new instance for an unknown value
          def ItemAvailabilityStatus.apply(value)
            if value.instance_of?(ItemAvailabilityStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ItemAvailabilityStatus.new(value))
            end
          end

          # Returns the instance of ItemAvailabilityStatus for this value, or nil if not found
          def ItemAvailabilityStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ItemAvailabilityStatus.ALL.find { |v| v.value == value }
          end

          def ItemAvailabilityStatus.ALL
            @@all ||= [ItemAvailabilityStatus.available, ItemAvailabilityStatus.low, ItemAvailabilityStatus.out_of_stock]
          end

          # Inventory is generally available for purchase
          def ItemAvailabilityStatus.available
            @@_available ||= ItemAvailabilityStatus.new('available')
          end

          # Inventory is low and may soon become unavailable for purchase (# inventory
          # items <= 5). Unless there is a specific use case for low inventory, it can be
          # treated the same as 'available'
          def ItemAvailabilityStatus.low
            @@_low ||= ItemAvailabilityStatus.new('low')
          end

          # There is no inventory available and is not available for purchase. Sample
          # actions that can be taken are hiding the item or marking as `sold out` on the
          # frontend
          def ItemAvailabilityStatus.out_of_stock
            @@_out_of_stock ||= ItemAvailabilityStatus.new('out_of_stock')
          end

          def to_hash
            value
          end

        end

        class LaneDirection

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LaneDirection for this value, creating a new instance for an unknown value
          def LaneDirection.apply(value)
            if value.instance_of?(LaneDirection)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LaneDirection.new(value))
            end
          end

          # Returns the instance of LaneDirection for this value, or nil if not found
          def LaneDirection.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LaneDirection.ALL.find { |v| v.value == value }
          end

          def LaneDirection.ALL
            @@all ||= [LaneDirection.outbound, LaneDirection.return]
          end

          def LaneDirection.outbound
            @@_outbound ||= LaneDirection.new('outbound')
          end

          def LaneDirection.return
            @@_return ||= LaneDirection.new('return')
          end

          def to_hash
            value
          end

        end

        class LanePreselectPreference

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LanePreselectPreference for this value, creating a new instance for an unknown value
          def LanePreselectPreference.apply(value)
            if value.instance_of?(LanePreselectPreference)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LanePreselectPreference.new(value))
            end
          end

          # Returns the instance of LanePreselectPreference for this value, or nil if not found
          def LanePreselectPreference.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LanePreselectPreference.ALL.find { |v| v.value == value }
          end

          def LanePreselectPreference.ALL
            @@all ||= [LanePreselectPreference.lowest_cost, LanePreselectPreference.default_tier]
          end

          # Preselect the lowest cost tier in the shipping lane
          def LanePreselectPreference.lowest_cost
            @@_lowest_cost ||= LanePreselectPreference.new('lowest_cost')
          end

          # Manually designate a tier in the shipping lane as the default
          def LanePreselectPreference.default_tier
            @@_default_tier ||= LanePreselectPreference.new('default_tier')
          end

          def to_hash
            value
          end

        end

        class LaneStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LaneStrategy for this value, creating a new instance for an unknown value
          def LaneStrategy.apply(value)
            if value.instance_of?(LaneStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LaneStrategy.new(value))
            end
          end

          # Returns the instance of LaneStrategy for this value, or nil if not found
          def LaneStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LaneStrategy.ALL.find { |v| v.value == value }
          end

          def LaneStrategy.ALL
            @@all ||= [LaneStrategy.oldest, LaneStrategy.fastest, LaneStrategy.lowest_cost, LaneStrategy.highest_priority]
          end

          # Use the oldest center by creation date.
          def LaneStrategy.oldest
            @@_oldest ||= LaneStrategy.new('oldest')
          end

          # Optimize for fastest average time in transit across all tiers from the center
          # on the lane
          def LaneStrategy.fastest
            @@_fastest ||= LaneStrategy.new('fastest')
          end

          # Optimize for lowest average cost across all tiers from the center on the lane
          def LaneStrategy.lowest_cost
            @@_lowest_cost ||= LaneStrategy.new('lowest_cost')
          end

          # Get the highest priority center for the shipping lane
          def LaneStrategy.highest_priority
            @@_highest_priority ||= LaneStrategy.new('highest_priority')
          end

          def to_hash
            value
          end

        end

        class LevyComponent

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyComponent for this value, creating a new instance for an unknown value
          def LevyComponent.apply(value)
            if value.instance_of?(LevyComponent)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyComponent.new(value))
            end
          end

          # Returns the instance of LevyComponent for this value, or nil if not found
          def LevyComponent.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyComponent.ALL.find { |v| v.value == value }
          end

          def LevyComponent.ALL
            @@all ||= [LevyComponent.goods, LevyComponent.duty, LevyComponent.insurance, LevyComponent.freight, LevyComponent.vat]
          end

          # The value of goods
          def LevyComponent.goods
            @@_goods ||= LevyComponent.new('goods')
          end

          def LevyComponent.duty
            @@_duty ||= LevyComponent.new('duty')
          end

          def LevyComponent.insurance
            @@_insurance ||= LevyComponent.new('insurance')
          end

          def LevyComponent.freight
            @@_freight ||= LevyComponent.new('freight')
          end

          # Value-Added Tax
          def LevyComponent.vat
            @@_vat ||= LevyComponent.new('vat')
          end

          def to_hash
            value
          end

        end

        class LevyStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyStrategy for this value, creating a new instance for an unknown value
          def LevyStrategy.apply(value)
            if value.instance_of?(LevyStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyStrategy.new(value))
            end
          end

          # Returns the instance of LevyStrategy for this value, or nil if not found
          def LevyStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyStrategy.ALL.find { |v| v.value == value }
          end

          def LevyStrategy.ALL
            @@all ||= [LevyStrategy.minimum, LevyStrategy.average, LevyStrategy.maximum]
          end

          def LevyStrategy.minimum
            @@_minimum ||= LevyStrategy.new('minimum')
          end

          def LevyStrategy.average
            @@_average ||= LevyStrategy.new('average')
          end

          def LevyStrategy.maximum
            @@_maximum ||= LevyStrategy.new('maximum')
          end

          def to_hash
            value
          end

        end

        class LocationErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LocationErrorCode for this value, creating a new instance for an unknown value
          def LocationErrorCode.apply(value)
            if value.instance_of?(LocationErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LocationErrorCode.new(value))
            end
          end

          # Returns the instance of LocationErrorCode for this value, or nil if not found
          def LocationErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LocationErrorCode.ALL.find { |v| v.value == value }
          end

          def LocationErrorCode.ALL
            @@all ||= [LocationErrorCode.address_required, LocationErrorCode.ip_invalid, LocationErrorCode.ip_required, LocationErrorCode.timezone_unavailable]
          end

          # Indicates that a non empty address was not specified when required
          def LocationErrorCode.address_required
            @@_address_required ||= LocationErrorCode.new('address_required')
          end

          # Indicates the specified IP Address is invalid
          def LocationErrorCode.ip_invalid
            @@_ip_invalid ||= LocationErrorCode.new('ip_invalid')
          end

          # Indicates that a non empty IP Address was not specified when required
          def LocationErrorCode.ip_required
            @@_ip_required ||= LocationErrorCode.new('ip_required')
          end

          # Indicates that there is no timezone information available for the specified IP
          # Address
          def LocationErrorCode.timezone_unavailable
            @@_timezone_unavailable ||= LocationErrorCode.new('timezone_unavailable')
          end

          def to_hash
            value
          end

        end

        class MarginType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MarginType for this value, creating a new instance for an unknown value
          def MarginType.apply(value)
            if value.instance_of?(MarginType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MarginType.new(value))
            end
          end

          # Returns the instance of MarginType for this value, or nil if not found
          def MarginType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MarginType.ALL.find { |v| v.value == value }
          end

          def MarginType.ALL
            @@all ||= [MarginType.fixed, MarginType.percent]
          end

          # A fixed amount to add, e.g 2.5 would add an absolute margin of 2.5 in the base
          # currency of your item.
          def MarginType.fixed
            @@_fixed ||= MarginType.new('fixed')
          end

          # A percent of the base cost to add, e.g. 1.2 would represent a 1.2% increase.
          def MarginType.percent
            @@_percent ||= MarginType.new('percent')
          end

          def to_hash
            value
          end

        end

        class MeasurementSystem

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MeasurementSystem for this value, creating a new instance for an unknown value
          def MeasurementSystem.apply(value)
            if value.instance_of?(MeasurementSystem)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MeasurementSystem.new(value))
            end
          end

          # Returns the instance of MeasurementSystem for this value, or nil if not found
          def MeasurementSystem.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MeasurementSystem.ALL.find { |v| v.value == value }
          end

          def MeasurementSystem.ALL
            @@all ||= [MeasurementSystem.imperial, MeasurementSystem.metric]
          end

          def MeasurementSystem.imperial
            @@_imperial ||= MeasurementSystem.new('imperial')
          end

          def MeasurementSystem.metric
            @@_metric ||= MeasurementSystem.new('metric')
          end

          def to_hash
            value
          end

        end

        class MerchantGiftCardErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MerchantGiftCardErrorCode for this value, creating a new instance for an unknown value
          def MerchantGiftCardErrorCode.apply(value)
            if value.instance_of?(MerchantGiftCardErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MerchantGiftCardErrorCode.new(value))
            end
          end

          # Returns the instance of MerchantGiftCardErrorCode for this value, or nil if not found
          def MerchantGiftCardErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MerchantGiftCardErrorCode.ALL.find { |v| v.value == value }
          end

          def MerchantGiftCardErrorCode.ALL
            @@all ||= [MerchantGiftCardErrorCode.invalid, MerchantGiftCardErrorCode.expired, MerchantGiftCardErrorCode.empty, MerchantGiftCardErrorCode.insufficient_funds, MerchantGiftCardErrorCode.unsupported_currency]
          end

          # Generic error type
          def MerchantGiftCardErrorCode.invalid
            @@_invalid ||= MerchantGiftCardErrorCode.new('invalid')
          end

          def MerchantGiftCardErrorCode.expired
            @@_expired ||= MerchantGiftCardErrorCode.new('expired')
          end

          # Balance is 0
          def MerchantGiftCardErrorCode.empty
            @@_empty ||= MerchantGiftCardErrorCode.new('empty')
          end

          # Redemption amount greater than balance
          def MerchantGiftCardErrorCode.insufficient_funds
            @@_insufficient_funds ||= MerchantGiftCardErrorCode.new('insufficient_funds')
          end

          # Redemption or reversal currency is not supported
          def MerchantGiftCardErrorCode.unsupported_currency
            @@_unsupported_currency ||= MerchantGiftCardErrorCode.new('unsupported_currency')
          end

          def to_hash
            value
          end

        end

        class MerchantOfRecord

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MerchantOfRecord for this value, creating a new instance for an unknown value
          def MerchantOfRecord.apply(value)
            if value.instance_of?(MerchantOfRecord)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MerchantOfRecord.new(value))
            end
          end

          # Returns the instance of MerchantOfRecord for this value, or nil if not found
          def MerchantOfRecord.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MerchantOfRecord.ALL.find { |v| v.value == value }
          end

          def MerchantOfRecord.ALL
            @@all ||= [MerchantOfRecord.flow, MerchantOfRecord.organization]
          end

          def MerchantOfRecord.flow
            @@_flow ||= MerchantOfRecord.new('flow')
          end

          def MerchantOfRecord.organization
            @@_organization ||= MerchantOfRecord.new('organization')
          end

          def to_hash
            value
          end

        end

        class Method

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Method for this value, creating a new instance for an unknown value
          def Method.apply(value)
            if value.instance_of?(Method)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Method.new(value))
            end
          end

          # Returns the instance of Method for this value, or nil if not found
          def Method.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Method.ALL.find { |v| v.value == value }
          end

          def Method.ALL
            @@all ||= [Method.post]
          end

          def Method.post
            @@_post ||= Method.new('post')
          end

          def to_hash
            value
          end

        end

        class OptinResponseType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OptinResponseType for this value, creating a new instance for an unknown value
          def OptinResponseType.apply(value)
            if value.instance_of?(OptinResponseType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OptinResponseType.new(value))
            end
          end

          # Returns the instance of OptinResponseType for this value, or nil if not found
          def OptinResponseType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OptinResponseType.ALL.find { |v| v.value == value }
          end

          def OptinResponseType.ALL
            @@all ||= [OptinResponseType.not_shown, OptinResponseType.opted_in, OptinResponseType.opted_out]
          end

          def OptinResponseType.not_shown
            @@_not_shown ||= OptinResponseType.new('not_shown')
          end

          def OptinResponseType.opted_in
            @@_opted_in ||= OptinResponseType.new('opted_in')
          end

          def OptinResponseType.opted_out
            @@_opted_out ||= OptinResponseType.new('opted_out')
          end

          def to_hash
            value
          end

        end

        class OrderChangeSource

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderChangeSource for this value, creating a new instance for an unknown value
          def OrderChangeSource.apply(value)
            if value.instance_of?(OrderChangeSource)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderChangeSource.new(value))
            end
          end

          # Returns the instance of OrderChangeSource for this value, or nil if not found
          def OrderChangeSource.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderChangeSource.ALL.find { |v| v.value == value }
          end

          def OrderChangeSource.ALL
            @@all ||= [OrderChangeSource.consumer, OrderChangeSource.retailer, OrderChangeSource.fulfillment, OrderChangeSource.flow, OrderChangeSource.carrier]
          end

          # The party that placed an order
          def OrderChangeSource.consumer
            @@_consumer ||= OrderChangeSource.new('consumer')
          end

          # The party that owns the processing of the order
          def OrderChangeSource.retailer
            @@_retailer ||= OrderChangeSource.new('retailer')
          end

          # A party providing fulfillment for an order
          def OrderChangeSource.fulfillment
            @@_fulfillment ||= OrderChangeSource.new('fulfillment')
          end

          # Flow may provide anti-fraud or payment services for an order
          def OrderChangeSource.flow
            @@_flow ||= OrderChangeSource.new('flow')
          end

          # A party providing carriage for an order
          def OrderChangeSource.carrier
            @@_carrier ||= OrderChangeSource.new('carrier')
          end

          def to_hash
            value
          end

        end

        class OrderErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderErrorCode for this value, creating a new instance for an unknown value
          def OrderErrorCode.apply(value)
            if value.instance_of?(OrderErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderErrorCode.new(value))
            end
          end

          # Returns the instance of OrderErrorCode for this value, or nil if not found
          def OrderErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderErrorCode.ALL.find { |v| v.value == value }
          end

          def OrderErrorCode.ALL
            @@all ||= [OrderErrorCode.generic_error, OrderErrorCode.order_item_not_available, OrderErrorCode.order_identifier_error, OrderErrorCode.authorization_invalid, OrderErrorCode.domestic_shipping_unavailable, OrderErrorCode.shipping_unavailable, OrderErrorCode.value_threshold_exceeded, OrderErrorCode.invalid_currency, OrderErrorCode.invalid_country, OrderErrorCode.invalid_region, OrderErrorCode.invalid_language, OrderErrorCode.item_out_of_stock, OrderErrorCode.gift_card_not_accepted, OrderErrorCode.total_changed]
          end

          def OrderErrorCode.generic_error
            @@_generic_error ||= OrderErrorCode.new('generic_error')
          end

          # When creating an order, if a particular item is not available in the country /
          # destination (either because it was restricted or excluded from that country),
          # we return this error code and list the specific item numbers which are not
          # available in the 'numbers' field.
          def OrderErrorCode.order_item_not_available
            @@_order_item_not_available ||= OrderErrorCode.new('order_item_not_available')
          end

          # Indicates that there is no order with the specified number (nor an order for
          # which an order identifier with that number has been created)
          def OrderErrorCode.order_identifier_error
            @@_order_identifier_error ||= OrderErrorCode.new('order_identifier_error')
          end

          # The authorization key specified is invalid - either because it does not exist
          # or is not associated with this order
          def OrderErrorCode.authorization_invalid
            @@_authorization_invalid ||= OrderErrorCode.new('authorization_invalid')
          end

          # Indicates that an order was created for a country for one of your domicile
          # countries and you have asked Flow not to accept orders for this country.
          def OrderErrorCode.domestic_shipping_unavailable
            @@_domestic_shipping_unavailable ||= OrderErrorCode.new('domestic_shipping_unavailable')
          end

          # Indicates that an order was created for a country to which you have asked Flow
          # not to ship.
          def OrderErrorCode.shipping_unavailable
            @@_shipping_unavailable ||= OrderErrorCode.new('shipping_unavailable')
          end

          # Indicates the order value exceeds the value threshold for destination and
          # cannot be shipped. When specified, the order will also populate the threshold
          # attribute.
          def OrderErrorCode.value_threshold_exceeded
            @@_value_threshold_exceeded ||= OrderErrorCode.new('value_threshold_exceeded')
          end

          # Indicates that the specified currency code is not valid
          def OrderErrorCode.invalid_currency
            @@_invalid_currency ||= OrderErrorCode.new('invalid_currency')
          end

          # Indicates that the specified country code is not valid
          def OrderErrorCode.invalid_country
            @@_invalid_country ||= OrderErrorCode.new('invalid_country')
          end

          # Indicates that the specified region code is not valid
          def OrderErrorCode.invalid_region
            @@_invalid_region ||= OrderErrorCode.new('invalid_region')
          end

          # Indicates that the specified language code is not valid
          def OrderErrorCode.invalid_language
            @@_invalid_language ||= OrderErrorCode.new('invalid_language')
          end

          # Indicates that one or more ordered items is marked as out-of-stock or
          # otherwise cannot be reserved. We will list the specific out-of-stock items in
          # the numbers field
          def OrderErrorCode.item_out_of_stock
            @@_item_out_of_stock ||= OrderErrorCode.new('item_out_of_stock')
          end

          # Indicates a failure to charge a gift card. Error message will indicate when
          # retries are possible.
          def OrderErrorCode.gift_card_not_accepted
            @@_gift_card_not_accepted ||= OrderErrorCode.new('gift_card_not_accepted')
          end

          # Indicates that the order total has changed, likely due to pricebook update or
          # rate change. This is not an error but the consumer should be shown the new
          # price before continuing checkout.
          def OrderErrorCode.total_changed
            @@_total_changed ||= OrderErrorCode.new('total_changed')
          end

          def to_hash
            value
          end

        end

        class OrderMerchantOfRecord

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderMerchantOfRecord for this value, creating a new instance for an unknown value
          def OrderMerchantOfRecord.apply(value)
            if value.instance_of?(OrderMerchantOfRecord)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderMerchantOfRecord.new(value))
            end
          end

          # Returns the instance of OrderMerchantOfRecord for this value, or nil if not found
          def OrderMerchantOfRecord.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderMerchantOfRecord.ALL.find { |v| v.value == value }
          end

          def OrderMerchantOfRecord.ALL
            @@all ||= [OrderMerchantOfRecord.flow, OrderMerchantOfRecord.organization, OrderMerchantOfRecord.mixed]
          end

          def OrderMerchantOfRecord.flow
            @@_flow ||= OrderMerchantOfRecord.new('flow')
          end

          def OrderMerchantOfRecord.organization
            @@_organization ||= OrderMerchantOfRecord.new('organization')
          end

          def OrderMerchantOfRecord.mixed
            @@_mixed ||= OrderMerchantOfRecord.new('mixed')
          end

          def to_hash
            value
          end

        end

        class OrderPaymentType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderPaymentType for this value, creating a new instance for an unknown value
          def OrderPaymentType.apply(value)
            if value.instance_of?(OrderPaymentType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderPaymentType.new(value))
            end
          end

          # Returns the instance of OrderPaymentType for this value, or nil if not found
          def OrderPaymentType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderPaymentType.ALL.find { |v| v.value == value }
          end

          def OrderPaymentType.ALL
            @@all ||= [OrderPaymentType.card, OrderPaymentType.online, OrderPaymentType.credit, OrderPaymentType.installment_plan, OrderPaymentType.cash_on_delivery]
          end

          # Represents a payment in the form of a credit or debit card
          def OrderPaymentType.card
            @@_card ||= OrderPaymentType.new('card')
          end

          # Represents an online payment (e.g. paypal, alipay, etc)
          def OrderPaymentType.online
            @@_online ||= OrderPaymentType.new('online')
          end

          # A payment in the form of a credit of some type (e.g. a store credit, gift
          # card) applied to an order
          def OrderPaymentType.credit
            @@_credit ||= OrderPaymentType.new('credit')
          end

          # An installment plan payment represents that the user has elected an
          # installment plan to pay for this order. For the purposes of the order, the
          # balance will reflect fully paid for the total value of the installment plan,
          # even though individual installments may be created in the future.
          def OrderPaymentType.installment_plan
            @@_installment_plan ||= OrderPaymentType.new('installment_plan')
          end

          # Request to pay the balance with cash on delivery. Offered only when the final
          # mile carriers support cash on delivery.
          def OrderPaymentType.cash_on_delivery
            @@_cash_on_delivery ||= OrderPaymentType.new('cash_on_delivery')
          end

          def to_hash
            value
          end

        end

        class OrderPriceDetailComponentKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderPriceDetailComponentKey for this value, creating a new instance for an unknown value
          def OrderPriceDetailComponentKey.apply(value)
            if value.instance_of?(OrderPriceDetailComponentKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderPriceDetailComponentKey.new(value))
            end
          end

          # Returns the instance of OrderPriceDetailComponentKey for this value, or nil if not found
          def OrderPriceDetailComponentKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderPriceDetailComponentKey.ALL.find { |v| v.value == value }
          end

          def OrderPriceDetailComponentKey.ALL
            @@all ||= [OrderPriceDetailComponentKey.adjustment, OrderPriceDetailComponentKey.vat_deminimis, OrderPriceDetailComponentKey.duty_deminimis, OrderPriceDetailComponentKey.duties_item_price, OrderPriceDetailComponentKey.duties_freight, OrderPriceDetailComponentKey.duties_insurance, OrderPriceDetailComponentKey.vat_item_price, OrderPriceDetailComponentKey.vat_freight, OrderPriceDetailComponentKey.vat_insurance, OrderPriceDetailComponentKey.vat_duties_item_price, OrderPriceDetailComponentKey.vat_duties_freight, OrderPriceDetailComponentKey.vat_duties_insurance, OrderPriceDetailComponentKey.item_price, OrderPriceDetailComponentKey.item_discount, OrderPriceDetailComponentKey.rounding, OrderPriceDetailComponentKey.insurance, OrderPriceDetailComponentKey.shipping, OrderPriceDetailComponentKey.order_discount, OrderPriceDetailComponentKey.subtotal_percent_sales_margin, OrderPriceDetailComponentKey.subtotal_vat_percent_sales_margin, OrderPriceDetailComponentKey.subtotal_duty_percent_sales_margin, OrderPriceDetailComponentKey.vat_subsidy, OrderPriceDetailComponentKey.duty_subsidy, OrderPriceDetailComponentKey.remote_area_surcharge, OrderPriceDetailComponentKey.fuel_surcharge]
          end

          # A general purpose adjustment applied to the order.
          def OrderPriceDetailComponentKey.adjustment
            @@_adjustment ||= OrderPriceDetailComponentKey.new('adjustment')
          end

          # An adjustment based on whether the VAT de minimis applies to the order.
          def OrderPriceDetailComponentKey.vat_deminimis
            @@_vat_deminimis ||= OrderPriceDetailComponentKey.new('vat_deminimis')
          end

          # An adjustment based on whether the duty de minimis applies to the order.
          def OrderPriceDetailComponentKey.duty_deminimis
            @@_duty_deminimis ||= OrderPriceDetailComponentKey.new('duty_deminimis')
          end

          # The duty owed on the price of the order's items, including any added margins
          # and rounding.
          def OrderPriceDetailComponentKey.duties_item_price
            @@_duties_item_price ||= OrderPriceDetailComponentKey.new('duties_item_price')
          end

          # The duty owed on the freight cost of the order.
          def OrderPriceDetailComponentKey.duties_freight
            @@_duties_freight ||= OrderPriceDetailComponentKey.new('duties_freight')
          end

          # The duty owed on the insurance cost of the order.
          def OrderPriceDetailComponentKey.duties_insurance
            @@_duties_insurance ||= OrderPriceDetailComponentKey.new('duties_insurance')
          end

          # The VAT owed on the price of the order's items, including any added margins
          # and rounding.
          def OrderPriceDetailComponentKey.vat_item_price
            @@_vat_item_price ||= OrderPriceDetailComponentKey.new('vat_item_price')
          end

          # The VAT owed on the freight cost of the order.
          def OrderPriceDetailComponentKey.vat_freight
            @@_vat_freight ||= OrderPriceDetailComponentKey.new('vat_freight')
          end

          # The VAT owed on the insurance cost of the order.
          def OrderPriceDetailComponentKey.vat_insurance
            @@_vat_insurance ||= OrderPriceDetailComponentKey.new('vat_insurance')
          end

          # The VAT owed on the duties on the price of the order's items, including any
          # added margins and rounding.
          def OrderPriceDetailComponentKey.vat_duties_item_price
            @@_vat_duties_item_price ||= OrderPriceDetailComponentKey.new('vat_duties_item_price')
          end

          # The VAT owed on the duties on the freight cost of the order.
          def OrderPriceDetailComponentKey.vat_duties_freight
            @@_vat_duties_freight ||= OrderPriceDetailComponentKey.new('vat_duties_freight')
          end

          # The VAT owed on the duties on the insurance cost of the order.
          def OrderPriceDetailComponentKey.vat_duties_insurance
            @@_vat_duties_insurance ||= OrderPriceDetailComponentKey.new('vat_duties_insurance')
          end

          # The sum of the price of the order's items with their currency margins, percent
          # margins, and fixed margins included.
          def OrderPriceDetailComponentKey.item_price
            @@_item_price ||= OrderPriceDetailComponentKey.new('item_price')
          end

          # The sum of all discounts applied to the order's items.
          def OrderPriceDetailComponentKey.item_discount
            @@_item_discount ||= OrderPriceDetailComponentKey.new('item_discount')
          end

          # The sum of any rounding applied to the order's items.
          def OrderPriceDetailComponentKey.rounding
            @@_rounding ||= OrderPriceDetailComponentKey.new('rounding')
          end

          # The insurance cost for the order.
          def OrderPriceDetailComponentKey.insurance
            @@_insurance ||= OrderPriceDetailComponentKey.new('insurance')
          end

          # The shipping cost for the order.
          def OrderPriceDetailComponentKey.shipping
            @@_shipping ||= OrderPriceDetailComponentKey.new('shipping')
          end

          # A discount applied to the entire order.
          def OrderPriceDetailComponentKey.order_discount
            @@_order_discount ||= OrderPriceDetailComponentKey.new('order_discount')
          end

          # The sum of adjustments to item price, margin and rounding made due to
          # percentage sales margins.
          def OrderPriceDetailComponentKey.subtotal_percent_sales_margin
            @@_subtotal_percent_sales_margin ||= OrderPriceDetailComponentKey.new('subtotal_percent_sales_margin')
          end

          # The sum of adjustments to VAT owed made due to percentage sales margins.
          def OrderPriceDetailComponentKey.subtotal_vat_percent_sales_margin
            @@_subtotal_vat_percent_sales_margin ||= OrderPriceDetailComponentKey.new('subtotal_vat_percent_sales_margin')
          end

          # The sum of adjustments to duty owed made due to percentage sales margins.
          def OrderPriceDetailComponentKey.subtotal_duty_percent_sales_margin
            @@_subtotal_duty_percent_sales_margin ||= OrderPriceDetailComponentKey.new('subtotal_duty_percent_sales_margin')
          end

          # An offset to account for any VAT subsidized by the organization. For example,
          # if VAT is included in an item price and changes at the order level (due to
          # passing de minimis threshold, or the destination having a more specific VAT
          # rate), the difference will be represented here.
          def OrderPriceDetailComponentKey.vat_subsidy
            @@_vat_subsidy ||= OrderPriceDetailComponentKey.new('vat_subsidy')
          end

          # An offset to account for any duty subsidized by the organization. For example,
          # if duty is included in an item price and changes at the order level (due to
          # passing de minimis threshold, or the destination having a more specific duty
          # rate), the difference will be represented here.
          def OrderPriceDetailComponentKey.duty_subsidy
            @@_duty_subsidy ||= OrderPriceDetailComponentKey.new('duty_subsidy')
          end

          # Surcharge applied to a shipment for delivery to a remote area determined by
          # the carrier.
          def OrderPriceDetailComponentKey.remote_area_surcharge
            @@_remote_area_surcharge ||= OrderPriceDetailComponentKey.new('remote_area_surcharge')
          end

          # Surcharge applied to a shipment for fuel consumption by the carrier.
          def OrderPriceDetailComponentKey.fuel_surcharge
            @@_fuel_surcharge ||= OrderPriceDetailComponentKey.new('fuel_surcharge')
          end

          def to_hash
            value
          end

        end

        class OrderPriceDetailKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderPriceDetailKey for this value, creating a new instance for an unknown value
          def OrderPriceDetailKey.apply(value)
            if value.instance_of?(OrderPriceDetailKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderPriceDetailKey.new(value))
            end
          end

          # Returns the instance of OrderPriceDetailKey for this value, or nil if not found
          def OrderPriceDetailKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderPriceDetailKey.ALL.find { |v| v.value == value }
          end

          def OrderPriceDetailKey.ALL
            @@all ||= [OrderPriceDetailKey.adjustment, OrderPriceDetailKey.subtotal, OrderPriceDetailKey.vat, OrderPriceDetailKey.duty, OrderPriceDetailKey.shipping, OrderPriceDetailKey.insurance, OrderPriceDetailKey.discount, OrderPriceDetailKey.surcharges]
          end

          # The details of any adjustments made to the order.
          def OrderPriceDetailKey.adjustment
            @@_adjustment ||= OrderPriceDetailKey.new('adjustment')
          end

          # The details of the subtotal for the order, including item prices, margins, and
          # rounding.
          def OrderPriceDetailKey.subtotal
            @@_subtotal ||= OrderPriceDetailKey.new('subtotal')
          end

          # The details of any VAT owed on the order.
          def OrderPriceDetailKey.vat
            @@_vat ||= OrderPriceDetailKey.new('vat')
          end

          # The details of any duties owed on the order.
          def OrderPriceDetailKey.duty
            @@_duty ||= OrderPriceDetailKey.new('duty')
          end

          # The details of shipping costs for the order.
          def OrderPriceDetailKey.shipping
            @@_shipping ||= OrderPriceDetailKey.new('shipping')
          end

          # The details of insurance costs for the order.
          def OrderPriceDetailKey.insurance
            @@_insurance ||= OrderPriceDetailKey.new('insurance')
          end

          # The details of any discount applied to the order.
          def OrderPriceDetailKey.discount
            @@_discount ||= OrderPriceDetailKey.new('discount')
          end

          # Additional fees and levies applied to the order
          def OrderPriceDetailKey.surcharges
            @@_surcharges ||= OrderPriceDetailKey.new('surcharges')
          end

          def to_hash
            value
          end

        end

        class OrderStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderStatus for this value, creating a new instance for an unknown value
          def OrderStatus.apply(value)
            if value.instance_of?(OrderStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderStatus.new(value))
            end
          end

          # Returns the instance of OrderStatus for this value, or nil if not found
          def OrderStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderStatus.ALL.find { |v| v.value == value }
          end

          def OrderStatus.ALL
            @@all ||= [OrderStatus.open, OrderStatus.submitted]
          end

          def OrderStatus.open
            @@_open ||= OrderStatus.new('open')
          end

          def OrderStatus.submitted
            @@_submitted ||= OrderStatus.new('submitted')
          end

          def to_hash
            value
          end

        end

        class OrganizationPaymentMethodTag < PaymentMethodTag

          attr_reader :value

          def initialize(value)
            super(:name => PaymentMethodTag::Types::ORGANIZATION_PAYMENT_METHOD_TAG, :discriminator => 'organization_payment_method_tag')
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrganizationPaymentMethodTag for this value, creating a new instance for an unknown value
          def OrganizationPaymentMethodTag.apply(value)
            if value.instance_of?(OrganizationPaymentMethodTag)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrganizationPaymentMethodTag.new(value))
            end
          end

          # Returns the instance of OrganizationPaymentMethodTag for this value, or nil if not found
          def OrganizationPaymentMethodTag.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrganizationPaymentMethodTag.ALL.find { |v| v.value == value }
          end

          def OrganizationPaymentMethodTag.ALL
            @@all ||= [OrganizationPaymentMethodTag.deny]
          end

          # A denied payment method cannot be used for an organization in any experience.
          def OrganizationPaymentMethodTag.deny
            @@_deny ||= OrganizationPaymentMethodTag.new('deny')
          end

          def subtype_to_hash
            value
          end

        end

        class PaymentErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PaymentErrorCode for this value, creating a new instance for an unknown value
          def PaymentErrorCode.apply(value)
            if value.instance_of?(PaymentErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PaymentErrorCode.new(value))
            end
          end

          # Returns the instance of PaymentErrorCode for this value, or nil if not found
          def PaymentErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PaymentErrorCode.ALL.find { |v| v.value == value }
          end

          def PaymentErrorCode.ALL
            @@all ||= [PaymentErrorCode.duplicate, PaymentErrorCode.invalid_amount, PaymentErrorCode.invalid_currency, PaymentErrorCode.invalid_method, PaymentErrorCode.invalid_order, PaymentErrorCode.invalid_customer, PaymentErrorCode.invalid_destination, PaymentErrorCode.unknown]
          end

          def PaymentErrorCode.duplicate
            @@_duplicate ||= PaymentErrorCode.new('duplicate')
          end

          # Amount is not valid (e.g. for merchant of record payments, the amount
          # specified must match the order). This typically is handled by refreshing the
          # order amount and reconfirming with the user as something has changed.
          def PaymentErrorCode.invalid_amount
            @@_invalid_amount ||= PaymentErrorCode.new('invalid_amount')
          end

          # Currency is either not known or invalid (e.g. for merchant of record payments,
          # the currency specified must match the order).
          def PaymentErrorCode.invalid_currency
            @@_invalid_currency ||= PaymentErrorCode.new('invalid_currency')
          end

          # Invalid payment method
          def PaymentErrorCode.invalid_method
            @@_invalid_method ||= PaymentErrorCode.new('invalid_method')
          end

          # The specified order number was not found
          def PaymentErrorCode.invalid_order
            @@_invalid_order ||= PaymentErrorCode.new('invalid_order')
          end

          # Customer information is invalid (e.g. email specified but not a valid email)
          def PaymentErrorCode.invalid_customer
            @@_invalid_customer ||= PaymentErrorCode.new('invalid_customer')
          end

          # Destination/shipping address is not valid
          def PaymentErrorCode.invalid_destination
            @@_invalid_destination ||= PaymentErrorCode.new('invalid_destination')
          end

          # Failed due to another reason (details not known)
          def PaymentErrorCode.unknown
            @@_unknown ||= PaymentErrorCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class PaymentMethodRuleContentKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PaymentMethodRuleContentKey for this value, creating a new instance for an unknown value
          def PaymentMethodRuleContentKey.apply(value)
            if value.instance_of?(PaymentMethodRuleContentKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PaymentMethodRuleContentKey.new(value))
            end
          end

          # Returns the instance of PaymentMethodRuleContentKey for this value, or nil if not found
          def PaymentMethodRuleContentKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PaymentMethodRuleContentKey.ALL.find { |v| v.value == value }
          end

          def PaymentMethodRuleContentKey.ALL
            @@all ||= [PaymentMethodRuleContentKey.description]
          end

          def PaymentMethodRuleContentKey.description
            @@_description ||= PaymentMethodRuleContentKey.new('description')
          end

          def to_hash
            value
          end

        end

        class PaymentMethodType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PaymentMethodType for this value, creating a new instance for an unknown value
          def PaymentMethodType.apply(value)
            if value.instance_of?(PaymentMethodType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PaymentMethodType.new(value))
            end
          end

          # Returns the instance of PaymentMethodType for this value, or nil if not found
          def PaymentMethodType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PaymentMethodType.ALL.find { |v| v.value == value }
          end

          def PaymentMethodType.ALL
            @@all ||= [PaymentMethodType.card, PaymentMethodType.online, PaymentMethodType.offline]
          end

          # Represents all form of card payment (e.g. credit, debit, etc.)
          def PaymentMethodType.card
            @@_card ||= PaymentMethodType.new('card')
          end

          # Represents the most common form of alternative payment methods which require
          # some degree of integration online (e.g. a redirect) to complete payment.
          def PaymentMethodType.online
            @@_online ||= PaymentMethodType.new('online')
          end

          # Offline payment method types represent payments like Cash On Delivery which
          # require offline collection
          def PaymentMethodType.offline
            @@_offline ||= PaymentMethodType.new('offline')
          end

          def to_hash
            value
          end

        end

        class PaymentSourceConfirmationActionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PaymentSourceConfirmationActionType for this value, creating a new instance for an unknown value
          def PaymentSourceConfirmationActionType.apply(value)
            if value.instance_of?(PaymentSourceConfirmationActionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PaymentSourceConfirmationActionType.new(value))
            end
          end

          # Returns the instance of PaymentSourceConfirmationActionType for this value, or nil if not found
          def PaymentSourceConfirmationActionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PaymentSourceConfirmationActionType.ALL.find { |v| v.value == value }
          end

          def PaymentSourceConfirmationActionType.ALL
            @@all ||= [PaymentSourceConfirmationActionType.cvv, PaymentSourceConfirmationActionType.billing_address, PaymentSourceConfirmationActionType.number]
          end

          def PaymentSourceConfirmationActionType.cvv
            @@_cvv ||= PaymentSourceConfirmationActionType.new('cvv')
          end

          def PaymentSourceConfirmationActionType.billing_address
            @@_billing_address ||= PaymentSourceConfirmationActionType.new('billing_address')
          end

          def PaymentSourceConfirmationActionType.number
            @@_number ||= PaymentSourceConfirmationActionType.new('number')
          end

          def to_hash
            value
          end

        end

        class PermittedHttpMethod

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PermittedHttpMethod for this value, creating a new instance for an unknown value
          def PermittedHttpMethod.apply(value)
            if value.instance_of?(PermittedHttpMethod)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PermittedHttpMethod.new(value))
            end
          end

          # Returns the instance of PermittedHttpMethod for this value, or nil if not found
          def PermittedHttpMethod.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PermittedHttpMethod.ALL.find { |v| v.value == value }
          end

          def PermittedHttpMethod.ALL
            @@all ||= [PermittedHttpMethod.get, PermittedHttpMethod.post, PermittedHttpMethod.put, PermittedHttpMethod.delete, PermittedHttpMethod.patch]
          end

          def PermittedHttpMethod.get
            @@_get ||= PermittedHttpMethod.new('GET')
          end

          def PermittedHttpMethod.post
            @@_post ||= PermittedHttpMethod.new('POST')
          end

          def PermittedHttpMethod.put
            @@_put ||= PermittedHttpMethod.new('PUT')
          end

          def PermittedHttpMethod.delete
            @@_delete ||= PermittedHttpMethod.new('DELETE')
          end

          def PermittedHttpMethod.patch
            @@_patch ||= PermittedHttpMethod.new('PATCH')
          end

          def to_hash
            value
          end

        end

        class PhysicalDeliverySpecialSerivce

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PhysicalDeliverySpecialSerivce for this value, creating a new instance for an unknown value
          def PhysicalDeliverySpecialSerivce.apply(value)
            if value.instance_of?(PhysicalDeliverySpecialSerivce)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PhysicalDeliverySpecialSerivce.new(value))
            end
          end

          # Returns the instance of PhysicalDeliverySpecialSerivce for this value, or nil if not found
          def PhysicalDeliverySpecialSerivce.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PhysicalDeliverySpecialSerivce.ALL.find { |v| v.value == value }
          end

          def PhysicalDeliverySpecialSerivce.ALL
            @@all ||= [PhysicalDeliverySpecialSerivce.cold_storage, PhysicalDeliverySpecialSerivce.hazardous, PhysicalDeliverySpecialSerivce.perishable]
          end

          def PhysicalDeliverySpecialSerivce.cold_storage
            @@_cold_storage ||= PhysicalDeliverySpecialSerivce.new('cold_storage')
          end

          def PhysicalDeliverySpecialSerivce.hazardous
            @@_hazardous ||= PhysicalDeliverySpecialSerivce.new('hazardous')
          end

          def PhysicalDeliverySpecialSerivce.perishable
            @@_perishable ||= PhysicalDeliverySpecialSerivce.new('perishable')
          end

          def to_hash
            value
          end

        end

        class PriceAccuracy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PriceAccuracy for this value, creating a new instance for an unknown value
          def PriceAccuracy.apply(value)
            if value.instance_of?(PriceAccuracy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PriceAccuracy.new(value))
            end
          end

          # Returns the instance of PriceAccuracy for this value, or nil if not found
          def PriceAccuracy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PriceAccuracy.ALL.find { |v| v.value == value }
          end

          def PriceAccuracy.ALL
            @@all ||= [PriceAccuracy.calculated, PriceAccuracy.estimated_from_partial_destination]
          end

          # The price shown is accurate and will not change unless information already
          # provided also changes.
          def PriceAccuracy.calculated
            @@_calculated ||= PriceAccuracy.new('calculated')
          end

          # The price shown is based on the best information provided; given a more
          # precise address, the price may change.
          def PriceAccuracy.estimated_from_partial_destination
            @@_estimated_from_partial_destination ||= PriceAccuracy.new('estimated_from_partial_destination')
          end

          def to_hash
            value
          end

        end

        class PriceBookStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PriceBookStatus for this value, creating a new instance for an unknown value
          def PriceBookStatus.apply(value)
            if value.instance_of?(PriceBookStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PriceBookStatus.new(value))
            end
          end

          # Returns the instance of PriceBookStatus for this value, or nil if not found
          def PriceBookStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PriceBookStatus.ALL.find { |v| v.value == value }
          end

          def PriceBookStatus.ALL
            @@all ||= [PriceBookStatus.draft, PriceBookStatus.published, PriceBookStatus.archived]
          end

          def PriceBookStatus.draft
            @@_draft ||= PriceBookStatus.new('draft')
          end

          def PriceBookStatus.published
            @@_published ||= PriceBookStatus.new('published')
          end

          def PriceBookStatus.archived
            @@_archived ||= PriceBookStatus.new('archived')
          end

          def to_hash
            value
          end

        end

        class PriceDetailComponentKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PriceDetailComponentKey for this value, creating a new instance for an unknown value
          def PriceDetailComponentKey.apply(value)
            if value.instance_of?(PriceDetailComponentKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PriceDetailComponentKey.new(value))
            end
          end

          # Returns the instance of PriceDetailComponentKey for this value, or nil if not found
          def PriceDetailComponentKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PriceDetailComponentKey.ALL.find { |v| v.value == value }
          end

          def PriceDetailComponentKey.ALL
            @@all ||= [PriceDetailComponentKey.base_price, PriceDetailComponentKey.discount, PriceDetailComponentKey.currency_margin, PriceDetailComponentKey.percent_item_margin, PriceDetailComponentKey.fixed_item_margin, PriceDetailComponentKey.duties_item_price, PriceDetailComponentKey.duties_added_margin, PriceDetailComponentKey.duties_rounding, PriceDetailComponentKey.duties_deminimis, PriceDetailComponentKey.vat_item_price, PriceDetailComponentKey.vat_added_margin, PriceDetailComponentKey.vat_rounding, PriceDetailComponentKey.vat_duties_item_price, PriceDetailComponentKey.vat_duties_added_margin, PriceDetailComponentKey.vat_duties_rounding, PriceDetailComponentKey.vat_deminimis, PriceDetailComponentKey.item_price_percent_sales_margin, PriceDetailComponentKey.margins_percent_sales_margin, PriceDetailComponentKey.rounding_percent_sales_margin, PriceDetailComponentKey.vat_percent_sales_margin, PriceDetailComponentKey.vat_duty_percent_sales_margin, PriceDetailComponentKey.duty_percent_sales_margin]
          end

          # The base price of the item.
          def PriceDetailComponentKey.base_price
            @@_base_price ||= PriceDetailComponentKey.new('base_price')
          end

          # A discount applied to the base price of the item.
          def PriceDetailComponentKey.discount
            @@_discount ||= PriceDetailComponentKey.new('discount')
          end

          # The amount added to the post-discount item price due to FX markup, as
          # configured in the organization's currency settings.
          def PriceDetailComponentKey.currency_margin
            @@_currency_margin ||= PriceDetailComponentKey.new('currency_margin')
          end

          # The amount added to the post-discount item price from a percent item margin.
          # Negative amounts represent discounts.
          def PriceDetailComponentKey.percent_item_margin
            @@_percent_item_margin ||= PriceDetailComponentKey.new('percent_item_margin')
          end

          # The amount added to the post-discount item price from a fixed item margin.
          # Negative amounts represent discounts.
          def PriceDetailComponentKey.fixed_item_margin
            @@_fixed_item_margin ||= PriceDetailComponentKey.new('fixed_item_margin')
          end

          # The duty owed on the post-discount base item price.
          def PriceDetailComponentKey.duties_item_price
            @@_duties_item_price ||= PriceDetailComponentKey.new('duties_item_price')
          end

          # The duty owed on the sum of the currency margin, percent item margin, and
          # fixed item margin.
          def PriceDetailComponentKey.duties_added_margin
            @@_duties_added_margin ||= PriceDetailComponentKey.new('duties_added_margin')
          end

          # The duty owed on any rounding applied to the total item price.
          def PriceDetailComponentKey.duties_rounding
            @@_duties_rounding ||= PriceDetailComponentKey.new('duties_rounding')
          end

          # An adjustment made if the item does not meet the duty de minimis rule.
          def PriceDetailComponentKey.duties_deminimis
            @@_duties_deminimis ||= PriceDetailComponentKey.new('duties_deminimis')
          end

          # The VAT owed on the post-discount base item price.
          def PriceDetailComponentKey.vat_item_price
            @@_vat_item_price ||= PriceDetailComponentKey.new('vat_item_price')
          end

          # The VAT owed on the sum of the currency margin, percent item margin, and fixed
          # item margin.
          def PriceDetailComponentKey.vat_added_margin
            @@_vat_added_margin ||= PriceDetailComponentKey.new('vat_added_margin')
          end

          # The VAT owed on any rounding applied to the total item price.
          def PriceDetailComponentKey.vat_rounding
            @@_vat_rounding ||= PriceDetailComponentKey.new('vat_rounding')
          end

          # The VAT owed on the duty owed on the post-discount base item price.
          def PriceDetailComponentKey.vat_duties_item_price
            @@_vat_duties_item_price ||= PriceDetailComponentKey.new('vat_duties_item_price')
          end

          # The VAT owed on the duty owed on the sum of the currency margin, percent item
          # margin, and fixed item margin.
          def PriceDetailComponentKey.vat_duties_added_margin
            @@_vat_duties_added_margin ||= PriceDetailComponentKey.new('vat_duties_added_margin')
          end

          # The VAT owed on the duty owed on any rounding applied to the total item price.
          def PriceDetailComponentKey.vat_duties_rounding
            @@_vat_duties_rounding ||= PriceDetailComponentKey.new('vat_duties_rounding')
          end

          # An adjustment made if the item does not meet the VAT de minimis rule.
          def PriceDetailComponentKey.vat_deminimis
            @@_vat_deminimis ||= PriceDetailComponentKey.new('vat_deminimis')
          end

          # An adjustment made to the item price as a result of a percent sales margin.
          def PriceDetailComponentKey.item_price_percent_sales_margin
            @@_item_price_percent_sales_margin ||= PriceDetailComponentKey.new('item_price_percent_sales_margin')
          end

          # An adjustment made to the item margins as a result of a percent sales margin.
          def PriceDetailComponentKey.margins_percent_sales_margin
            @@_margins_percent_sales_margin ||= PriceDetailComponentKey.new('margins_percent_sales_margin')
          end

          # An adjustment made to rounding as a result of a percent sales margin.
          def PriceDetailComponentKey.rounding_percent_sales_margin
            @@_rounding_percent_sales_margin ||= PriceDetailComponentKey.new('rounding_percent_sales_margin')
          end

          # An adjustment made to VAT owed as a result of a percent sales margin.
          def PriceDetailComponentKey.vat_percent_sales_margin
            @@_vat_percent_sales_margin ||= PriceDetailComponentKey.new('vat_percent_sales_margin')
          end

          # An adjustment made to VAT on duties (e.g. VAT on duties on item price) owed as
          # a result of a percent sales margin.
          def PriceDetailComponentKey.vat_duty_percent_sales_margin
            @@_vat_duty_percent_sales_margin ||= PriceDetailComponentKey.new('vat_duty_percent_sales_margin')
          end

          # An adjustment made to duty owed as a result of a percent sales margin.
          def PriceDetailComponentKey.duty_percent_sales_margin
            @@_duty_percent_sales_margin ||= PriceDetailComponentKey.new('duty_percent_sales_margin')
          end

          def to_hash
            value
          end

        end

        class PriceDetailKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PriceDetailKey for this value, creating a new instance for an unknown value
          def PriceDetailKey.apply(value)
            if value.instance_of?(PriceDetailKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PriceDetailKey.new(value))
            end
          end

          # Returns the instance of PriceDetailKey for this value, or nil if not found
          def PriceDetailKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PriceDetailKey.ALL.find { |v| v.value == value }
          end

          def PriceDetailKey.ALL
            @@all ||= [PriceDetailKey.item_price, PriceDetailKey.margins, PriceDetailKey.vat, PriceDetailKey.duty, PriceDetailKey.rounding, PriceDetailKey.adjustment]
          end

          # The details of the item price.
          def PriceDetailKey.item_price
            @@_item_price ||= PriceDetailKey.new('item_price')
          end

          # The details of any margins added to the item price.
          def PriceDetailKey.margins
            @@_margins ||= PriceDetailKey.new('margins')
          end

          # The details of any VAT owed on the item.
          def PriceDetailKey.vat
            @@_vat ||= PriceDetailKey.new('vat')
          end

          # The details of any duties owed on the item.
          def PriceDetailKey.duty
            @@_duty ||= PriceDetailKey.new('duty')
          end

          # The details of any rounding added to the item.
          def PriceDetailKey.rounding
            @@_rounding ||= PriceDetailKey.new('rounding')
          end

          # The details of any price adjustments due to sales margins. A negative value
          # indicates a discount.
          def PriceDetailKey.adjustment
            @@_adjustment ||= PriceDetailKey.new('adjustment')
          end

          def to_hash
            value
          end

        end

        class PricingLevySetting

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PricingLevySetting for this value, creating a new instance for an unknown value
          def PricingLevySetting.apply(value)
            if value.instance_of?(PricingLevySetting)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PricingLevySetting.new(value))
            end
          end

          # Returns the instance of PricingLevySetting for this value, or nil if not found
          def PricingLevySetting.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PricingLevySetting.ALL.find { |v| v.value == value }
          end

          def PricingLevySetting.ALL
            @@all ||= [PricingLevySetting.included, PricingLevySetting.displayed, PricingLevySetting.ignored]
          end

          def PricingLevySetting.included
            @@_included ||= PricingLevySetting.new('included')
          end

          def PricingLevySetting.displayed
            @@_displayed ||= PricingLevySetting.new('displayed')
          end

          def PricingLevySetting.ignored
            @@_ignored ||= PricingLevySetting.new('ignored')
          end

          def to_hash
            value
          end

        end

        class PromotionTriggerType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PromotionTriggerType for this value, creating a new instance for an unknown value
          def PromotionTriggerType.apply(value)
            if value.instance_of?(PromotionTriggerType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PromotionTriggerType.new(value))
            end
          end

          # Returns the instance of PromotionTriggerType for this value, or nil if not found
          def PromotionTriggerType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PromotionTriggerType.ALL.find { |v| v.value == value }
          end

          def PromotionTriggerType.ALL
            @@all ||= [PromotionTriggerType.automatic, PromotionTriggerType.order_subtotal]
          end

          # Automatic indicates the the promotion will be automatically applied to the
          # order
          def PromotionTriggerType.automatic
            @@_automatic ||= PromotionTriggerType.new('automatic')
          end

          # Order subtotal sets a minimum value - orders whose subtotal is greater than
          # the minimum will have the promotion applied. A common use case is to offer
          # free shipping to orders about 150 CAD.
          def PromotionTriggerType.order_subtotal
            @@_order_subtotal ||= PromotionTriggerType.new('order_subtotal')
          end

          def to_hash
            value
          end

        end

        class ProvinceType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ProvinceType for this value, creating a new instance for an unknown value
          def ProvinceType.apply(value)
            if value.instance_of?(ProvinceType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ProvinceType.new(value))
            end
          end

          # Returns the instance of ProvinceType for this value, or nil if not found
          def ProvinceType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ProvinceType.ALL.find { |v| v.value == value }
          end

          def ProvinceType.ALL
            @@all ||= [ProvinceType.city, ProvinceType.dependency, ProvinceType.district, ProvinceType.emirate, ProvinceType.entity, ProvinceType.municipality, ProvinceType.outlying_area, ProvinceType.parish, ProvinceType.province, ProvinceType.state, ProvinceType.territory, ProvinceType.other]
          end

          def ProvinceType.city
            @@_city ||= ProvinceType.new('city')
          end

          def ProvinceType.dependency
            @@_dependency ||= ProvinceType.new('dependency')
          end

          def ProvinceType.district
            @@_district ||= ProvinceType.new('district')
          end

          def ProvinceType.emirate
            @@_emirate ||= ProvinceType.new('emirate')
          end

          def ProvinceType.entity
            @@_entity ||= ProvinceType.new('entity')
          end

          def ProvinceType.municipality
            @@_municipality ||= ProvinceType.new('municipality')
          end

          def ProvinceType.outlying_area
            @@_outlying_area ||= ProvinceType.new('outlying_area')
          end

          def ProvinceType.parish
            @@_parish ||= ProvinceType.new('parish')
          end

          def ProvinceType.province
            @@_province ||= ProvinceType.new('province')
          end

          def ProvinceType.state
            @@_state ||= ProvinceType.new('state')
          end

          def ProvinceType.territory
            @@_territory ||= ProvinceType.new('territory')
          end

          def ProvinceType.other
            @@_other ||= ProvinceType.new('other')
          end

          def to_hash
            value
          end

        end

        class QueryType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of QueryType for this value, creating a new instance for an unknown value
          def QueryType.apply(value)
            if value.instance_of?(QueryType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || QueryType.new(value))
            end
          end

          # Returns the instance of QueryType for this value, or nil if not found
          def QueryType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            QueryType.ALL.find { |v| v.value == value }
          end

          def QueryType.ALL
            @@all ||= [QueryType.exclusion, QueryType.inclusion]
          end

          # Exclude items satisfied by the associated query
          def QueryType.exclusion
            @@_exclusion ||= QueryType.new('exclusion')
          end

          # Include items satisfied by the associated query
          def QueryType.inclusion
            @@_inclusion ||= QueryType.new('inclusion')
          end

          def to_hash
            value
          end

        end

        class QuoteErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of QuoteErrorCode for this value, creating a new instance for an unknown value
          def QuoteErrorCode.apply(value)
            if value.instance_of?(QuoteErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || QuoteErrorCode.new(value))
            end
          end

          # Returns the instance of QuoteErrorCode for this value, or nil if not found
          def QuoteErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            QuoteErrorCode.ALL.find { |v| v.value == value }
          end

          def QuoteErrorCode.ALL
            @@all ||= [QuoteErrorCode.generic_error, QuoteErrorCode.items_not_available, QuoteErrorCode.shipping_unavailable]
          end

          def QuoteErrorCode.generic_error
            @@_generic_error ||= QuoteErrorCode.new('generic_error')
          end

          # Item numbers are not available in inventory
          def QuoteErrorCode.items_not_available
            @@_items_not_available ||= QuoteErrorCode.new('items_not_available')
          end

          # Indicates that an order was created for a destination country to which you
          # have no shipping lanes.
          def QuoteErrorCode.shipping_unavailable
            @@_shipping_unavailable ||= QuoteErrorCode.new('shipping_unavailable')
          end

          def to_hash
            value
          end

        end

        class RateType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RateType for this value, creating a new instance for an unknown value
          def RateType.apply(value)
            if value.instance_of?(RateType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RateType.new(value))
            end
          end

          # Returns the instance of RateType for this value, or nil if not found
          def RateType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RateType.ALL.find { |v| v.value == value }
          end

          def RateType.ALL
            @@all ||= [RateType.flow, RateType.organization]
          end

          # Represents a Flow rate type (which excludes currency margins)
          def RateType.flow
            @@_flow ||= RateType.new('flow')
          end

          # Represents an organization rate type (which includes currency margins)
          def RateType.organization
            @@_organization ||= RateType.new('organization')
          end

          def to_hash
            value
          end

        end

        class RatecardOwner

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RatecardOwner for this value, creating a new instance for an unknown value
          def RatecardOwner.apply(value)
            if value.instance_of?(RatecardOwner)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RatecardOwner.new(value))
            end
          end

          # Returns the instance of RatecardOwner for this value, or nil if not found
          def RatecardOwner.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RatecardOwner.ALL.find { |v| v.value == value }
          end

          def RatecardOwner.ALL
            @@all ||= [RatecardOwner.flow, RatecardOwner.organization]
          end

          def RatecardOwner.flow
            @@_flow ||= RatecardOwner.new('flow')
          end

          def RatecardOwner.organization
            @@_organization ||= RatecardOwner.new('organization')
          end

          def to_hash
            value
          end

        end

        class RefundDeclineCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RefundDeclineCode for this value, creating a new instance for an unknown value
          def RefundDeclineCode.apply(value)
            if value.instance_of?(RefundDeclineCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RefundDeclineCode.new(value))
            end
          end

          # Returns the instance of RefundDeclineCode for this value, or nil if not found
          def RefundDeclineCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RefundDeclineCode.ALL.find { |v| v.value == value }
          end

          def RefundDeclineCode.ALL
            @@all ||= [RefundDeclineCode.expired, RefundDeclineCode.insufficient_funds, RefundDeclineCode.unknown]
          end

          # All associated payment captures have expired; refunds can no longer be issued
          def RefundDeclineCode.expired
            @@_expired ||= RefundDeclineCode.new('expired')
          end

          # The requested refund amount exceeded the amount of remaining unrefunded funds
          def RefundDeclineCode.insufficient_funds
            @@_insufficient_funds ||= RefundDeclineCode.new('insufficient_funds')
          end

          # Failed due to another reason (details not known)
          def RefundDeclineCode.unknown
            @@_unknown ||= RefundDeclineCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class RefundStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RefundStatus for this value, creating a new instance for an unknown value
          def RefundStatus.apply(value)
            if value.instance_of?(RefundStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RefundStatus.new(value))
            end
          end

          # Returns the instance of RefundStatus for this value, or nil if not found
          def RefundStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RefundStatus.ALL.find { |v| v.value == value }
          end

          def RefundStatus.ALL
            @@all ||= [RefundStatus.pending, RefundStatus.succeeded, RefundStatus.failed, RefundStatus.canceled]
          end

          # The refund has been initiated and requires time to complete.
          def RefundStatus.pending
            @@_pending ||= RefundStatus.new('pending')
          end

          # The refund has been processed successfully.
          def RefundStatus.succeeded
            @@_succeeded ||= RefundStatus.new('succeeded')
          end

          # The refund failed to process.
          def RefundStatus.failed
            @@_failed ||= RefundStatus.new('failed')
          end

          # The refund was canceled.
          def RefundStatus.canceled
            @@_canceled ||= RefundStatus.new('canceled')
          end

          def to_hash
            value
          end

        end

        class ReturnStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ReturnStatus for this value, creating a new instance for an unknown value
          def ReturnStatus.apply(value)
            if value.instance_of?(ReturnStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ReturnStatus.new(value))
            end
          end

          # Returns the instance of ReturnStatus for this value, or nil if not found
          def ReturnStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ReturnStatus.ALL.find { |v| v.value == value }
          end

          def ReturnStatus.ALL
            @@all ||= [ReturnStatus.open, ReturnStatus.refunded]
          end

          def ReturnStatus.open
            @@_open ||= ReturnStatus.new('open')
          end

          def ReturnStatus.refunded
            @@_refunded ||= ReturnStatus.new('refunded')
          end

          def to_hash
            value
          end

        end

        class ReversalErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ReversalErrorCode for this value, creating a new instance for an unknown value
          def ReversalErrorCode.apply(value)
            if value.instance_of?(ReversalErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ReversalErrorCode.new(value))
            end
          end

          # Returns the instance of ReversalErrorCode for this value, or nil if not found
          def ReversalErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ReversalErrorCode.ALL.find { |v| v.value == value }
          end

          def ReversalErrorCode.ALL
            @@all ||= [ReversalErrorCode.amount_exceeds_balance, ReversalErrorCode.authorization_declined, ReversalErrorCode.authorization_expired, ReversalErrorCode.invalid_authorization, ReversalErrorCode.invalid_key, ReversalErrorCode.invalid_amount, ReversalErrorCode.invalid_currency, ReversalErrorCode.no_remaining_balance, ReversalErrorCode.partial_reversal_not_supported, ReversalErrorCode.unknown]
          end

          # Amount specified exceeds the remaining authorization balance.
          def ReversalErrorCode.amount_exceeds_balance
            @@_amount_exceeds_balance ||= ReversalErrorCode.new('amount_exceeds_balance')
          end

          # The authorization was initially declined; there is nothing to reverse.
          def ReversalErrorCode.authorization_declined
            @@_authorization_declined ||= ReversalErrorCode.new('authorization_declined')
          end

          # The authorization has expired and can no longer be reversed.
          def ReversalErrorCode.authorization_expired
            @@_authorization_expired ||= ReversalErrorCode.new('authorization_expired')
          end

          # The authorization was not found.
          def ReversalErrorCode.invalid_authorization
            @@_invalid_authorization ||= ReversalErrorCode.new('invalid_authorization')
          end

          # Invalid key
          def ReversalErrorCode.invalid_key
            @@_invalid_key ||= ReversalErrorCode.new('invalid_key')
          end

          # Amount is not valid - usually because amount was <= 0
          def ReversalErrorCode.invalid_amount
            @@_invalid_amount ||= ReversalErrorCode.new('invalid_amount')
          end

          # Currency is either not known or invalid
          def ReversalErrorCode.invalid_currency
            @@_invalid_currency ||= ReversalErrorCode.new('invalid_currency')
          end

          # The authorization has already been fully captured and/or reversed - there are
          # no additional funds to reverse.
          def ReversalErrorCode.no_remaining_balance
            @@_no_remaining_balance ||= ReversalErrorCode.new('no_remaining_balance')
          end

          # Indicates a request for a partial reversal when the underlying processor does
          # not support it
          def ReversalErrorCode.partial_reversal_not_supported
            @@_partial_reversal_not_supported ||= ReversalErrorCode.new('partial_reversal_not_supported')
          end

          # Unknown or other
          def ReversalErrorCode.unknown
            @@_unknown ||= ReversalErrorCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class ReversalStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ReversalStatus for this value, creating a new instance for an unknown value
          def ReversalStatus.apply(value)
            if value.instance_of?(ReversalStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ReversalStatus.new(value))
            end
          end

          # Returns the instance of ReversalStatus for this value, or nil if not found
          def ReversalStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ReversalStatus.ALL.find { |v| v.value == value }
          end

          def ReversalStatus.ALL
            @@all ||= [ReversalStatus.pending, ReversalStatus.processed, ReversalStatus.failed]
          end

          # Reversal is pending processing.
          def ReversalStatus.pending
            @@_pending ||= ReversalStatus.new('pending')
          end

          # Reversal has been processed successfully.
          def ReversalStatus.processed
            @@_processed ||= ReversalStatus.new('processed')
          end

          # Reversal failed to process.
          def ReversalStatus.failed
            @@_failed ||= ReversalStatus.new('failed')
          end

          def to_hash
            value
          end

        end

        class Role

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Role for this value, creating a new instance for an unknown value
          def Role.apply(value)
            if value.instance_of?(Role)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Role.new(value))
            end
          end

          # Returns the instance of Role for this value, or nil if not found
          def Role.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Role.ALL.find { |v| v.value == value }
          end

          def Role.ALL
            @@all ||= [Role.admin, Role.member]
          end

          def Role.admin
            @@_admin ||= Role.new('admin')
          end

          def Role.member
            @@_member ||= Role.new('member')
          end

          def to_hash
            value
          end

        end

        class RoundingMethod

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingMethod for this value, creating a new instance for an unknown value
          def RoundingMethod.apply(value)
            if value.instance_of?(RoundingMethod)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingMethod.new(value))
            end
          end

          # Returns the instance of RoundingMethod for this value, or nil if not found
          def RoundingMethod.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingMethod.ALL.find { |v| v.value == value }
          end

          def RoundingMethod.ALL
            @@all ||= [RoundingMethod.up, RoundingMethod.down, RoundingMethod.nearest]
          end

          # Round up to the specified rounding.value
          def RoundingMethod.up
            @@_up ||= RoundingMethod.new('up')
          end

          # Round down to the specified rounding.value
          def RoundingMethod.down
            @@_down ||= RoundingMethod.new('down')
          end

          # Round to the nearest specified rounding.value. If equidistant, will round up.
          def RoundingMethod.nearest
            @@_nearest ||= RoundingMethod.new('nearest')
          end

          def to_hash
            value
          end

        end

        class RoundingType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingType for this value, creating a new instance for an unknown value
          def RoundingType.apply(value)
            if value.instance_of?(RoundingType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingType.new(value))
            end
          end

          # Returns the instance of RoundingType for this value, or nil if not found
          def RoundingType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingType.ALL.find { |v| v.value == value }
          end

          def RoundingType.ALL
            @@all ||= [RoundingType.pattern, RoundingType.multiple]
          end

          # Rounds a value to an amount ending with a pattern, e.g. an amount ending in
          # '.99'.
          def RoundingType.pattern
            @@_pattern ||= RoundingType.new('pattern')
          end

          # Rounds a value to an amount that is the multiple of a value, e.g. rounding to
          # the nearest 5 would ensure that the resulting number ends in either 0 or 5.
          def RoundingType.multiple
            @@_multiple ||= RoundingType.new('multiple')
          end

          def to_hash
            value
          end

        end

        class ScheduleExceptionStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ScheduleExceptionStatus for this value, creating a new instance for an unknown value
          def ScheduleExceptionStatus.apply(value)
            if value.instance_of?(ScheduleExceptionStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ScheduleExceptionStatus.new(value))
            end
          end

          # Returns the instance of ScheduleExceptionStatus for this value, or nil if not found
          def ScheduleExceptionStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ScheduleExceptionStatus.ALL.find { |v| v.value == value }
          end

          def ScheduleExceptionStatus.ALL
            @@all ||= [ScheduleExceptionStatus.open, ScheduleExceptionStatus.closed]
          end

          def ScheduleExceptionStatus.open
            @@_open ||= ScheduleExceptionStatus.new('Open')
          end

          def ScheduleExceptionStatus.closed
            @@_closed ||= ScheduleExceptionStatus.new('Closed')
          end

          def to_hash
            value
          end

        end

        class SerialStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SerialStatus for this value, creating a new instance for an unknown value
          def SerialStatus.apply(value)
            if value.instance_of?(SerialStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SerialStatus.new(value))
            end
          end

          # Returns the instance of SerialStatus for this value, or nil if not found
          def SerialStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SerialStatus.ALL.find { |v| v.value == value }
          end

          def SerialStatus.ALL
            @@all ||= [SerialStatus.available, SerialStatus.reserved, SerialStatus.sold]
          end

          def SerialStatus.available
            @@_available ||= SerialStatus.new('available')
          end

          def SerialStatus.reserved
            @@_reserved ||= SerialStatus.new('reserved')
          end

          def SerialStatus.sold
            @@_sold ||= SerialStatus.new('sold')
          end

          def to_hash
            value
          end

        end

        class ShipmentIntegrationType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShipmentIntegrationType for this value, creating a new instance for an unknown value
          def ShipmentIntegrationType.apply(value)
            if value.instance_of?(ShipmentIntegrationType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShipmentIntegrationType.new(value))
            end
          end

          # Returns the instance of ShipmentIntegrationType for this value, or nil if not found
          def ShipmentIntegrationType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShipmentIntegrationType.ALL.find { |v| v.value == value }
          end

          def ShipmentIntegrationType.ALL
            @@all ||= [ShipmentIntegrationType.direct, ShipmentIntegrationType.information, ShipmentIntegrationType.preadvice]
          end

          # Always generate a label for the chosen delivery option.
          def ShipmentIntegrationType.direct
            @@_direct ||= ShipmentIntegrationType.new('direct')
          end

          # Booking and label generation is not available. Just use Flow to calculate
          # delivery window estimates and shipment prices to display.
          def ShipmentIntegrationType.information
            @@_information ||= ShipmentIntegrationType.new('information')
          end

          # A generic label will be provided by the client organization when available as
          # pre-advice shipment notification to carrier partner.
          def ShipmentIntegrationType.preadvice
            @@_preadvice ||= ShipmentIntegrationType.new('preadvice')
          end

          def to_hash
            value
          end

        end

        class ShipmentRecipient

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShipmentRecipient for this value, creating a new instance for an unknown value
          def ShipmentRecipient.apply(value)
            if value.instance_of?(ShipmentRecipient)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShipmentRecipient.new(value))
            end
          end

          # Returns the instance of ShipmentRecipient for this value, or nil if not found
          def ShipmentRecipient.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShipmentRecipient.ALL.find { |v| v.value == value }
          end

          def ShipmentRecipient.ALL
            @@all ||= [ShipmentRecipient.customer, ShipmentRecipient.return, ShipmentRecipient.crossdock]
          end

          # Outbound shipment to the customer
          def ShipmentRecipient.customer
            @@_customer ||= ShipmentRecipient.new('customer')
          end

          # Inbound or return shipment
          def ShipmentRecipient.return
            @@_return ||= ShipmentRecipient.new('return')
          end

          # Outbound shipment to a crossdock
          def ShipmentRecipient.crossdock
            @@_crossdock ||= ShipmentRecipient.new('crossdock')
          end

          def to_hash
            value
          end

        end

        class ShippingConfigurationType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShippingConfigurationType for this value, creating a new instance for an unknown value
          def ShippingConfigurationType.apply(value)
            if value.instance_of?(ShippingConfigurationType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShippingConfigurationType.new(value))
            end
          end

          # Returns the instance of ShippingConfigurationType for this value, or nil if not found
          def ShippingConfigurationType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShippingConfigurationType.ALL.find { |v| v.value == value }
          end

          def ShippingConfigurationType.ALL
            @@all ||= [ShippingConfigurationType.default, ShippingConfigurationType.variant]
          end

          def ShippingConfigurationType.default
            @@_default ||= ShippingConfigurationType.new('default')
          end

          def ShippingConfigurationType.variant
            @@_variant ||= ShippingConfigurationType.new('variant')
          end

          def to_hash
            value
          end

        end

        class ShopifyGrant

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShopifyGrant for this value, creating a new instance for an unknown value
          def ShopifyGrant.apply(value)
            if value.instance_of?(ShopifyGrant)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShopifyGrant.new(value))
            end
          end

          # Returns the instance of ShopifyGrant for this value, or nil if not found
          def ShopifyGrant.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShopifyGrant.ALL.find { |v| v.value == value }
          end

          def ShopifyGrant.ALL
            @@all ||= [ShopifyGrant.customer, ShopifyGrant.discount, ShopifyGrant.gift_card, ShopifyGrant.metafield, ShopifyGrant.order]
          end

          # Access to /admin/customers.json
          def ShopifyGrant.customer
            @@_customer ||= ShopifyGrant.new('customer')
          end

          # Access to /admin/price_rules/:id/discount_codes.json
          def ShopifyGrant.discount
            @@_discount ||= ShopifyGrant.new('discount')
          end

          # Access to /admin/gift_cards.json
          def ShopifyGrant.gift_card
            @@_gift_card ||= ShopifyGrant.new('gift_card')
          end

          # Access to /admin/variants/:id/metafields.json
          def ShopifyGrant.metafield
            @@_metafield ||= ShopifyGrant.new('metafield')
          end

          # Access to /admin/orders/:id/metafields.json
          def ShopifyGrant.order
            @@_order ||= ShopifyGrant.new('order')
          end

          def to_hash
            value
          end

        end

        class ShopifyLocalizationMethod

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShopifyLocalizationMethod for this value, creating a new instance for an unknown value
          def ShopifyLocalizationMethod.apply(value)
            if value.instance_of?(ShopifyLocalizationMethod)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShopifyLocalizationMethod.new(value))
            end
          end

          # Returns the instance of ShopifyLocalizationMethod for this value, or nil if not found
          def ShopifyLocalizationMethod.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShopifyLocalizationMethod.ALL.find { |v| v.value == value }
          end

          def ShopifyLocalizationMethod.ALL
            @@all ||= [ShopifyLocalizationMethod.api, ShopifyLocalizationMethod.ssr]
          end

          # Indicates localization should be achieved via the API.
          def ShopifyLocalizationMethod.api
            @@_api ||= ShopifyLocalizationMethod.new('api')
          end

          # Indicates localization should be achieved via server side rendering. For
          # example, using variant metafields.
          def ShopifyLocalizationMethod.ssr
            @@_ssr ||= ShopifyLocalizationMethod.new('ssr')
          end

          def to_hash
            value
          end

        end

        class ShopifySyncCheck

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShopifySyncCheck for this value, creating a new instance for an unknown value
          def ShopifySyncCheck.apply(value)
            if value.instance_of?(ShopifySyncCheck)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShopifySyncCheck.new(value))
            end
          end

          # Returns the instance of ShopifySyncCheck for this value, or nil if not found
          def ShopifySyncCheck.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShopifySyncCheck.ALL.find { |v| v.value == value }
          end

          def ShopifySyncCheck.ALL
            @@all ||= [ShopifySyncCheck.localized_variants, ShopifySyncCheck.flow_variant_metafields]
          end

          # Provides status check of localized variant metafields sync to Shopify
          def ShopifySyncCheck.localized_variants
            @@_localized_variants ||= ShopifySyncCheck.new('localized_variants')
          end

          # Provides status check of Flow variant metafields sync to Shopify
          def ShopifySyncCheck.flow_variant_metafields
            @@_flow_variant_metafields ||= ShopifySyncCheck.new('flow_variant_metafields')
          end

          def to_hash
            value
          end

        end

        class SortDirection

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SortDirection for this value, creating a new instance for an unknown value
          def SortDirection.apply(value)
            if value.instance_of?(SortDirection)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SortDirection.new(value))
            end
          end

          # Returns the instance of SortDirection for this value, or nil if not found
          def SortDirection.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SortDirection.ALL.find { |v| v.value == value }
          end

          def SortDirection.ALL
            @@all ||= [SortDirection.ascending, SortDirection.descending]
          end

          def SortDirection.ascending
            @@_ascending ||= SortDirection.new('ascending')
          end

          def SortDirection.descending
            @@_descending ||= SortDirection.new('descending')
          end

          def to_hash
            value
          end

        end

        class Strategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Strategy for this value, creating a new instance for an unknown value
          def Strategy.apply(value)
            if value.instance_of?(Strategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Strategy.new(value))
            end
          end

          # Returns the instance of Strategy for this value, or nil if not found
          def Strategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Strategy.ALL.find { |v| v.value == value }
          end

          def Strategy.ALL
            @@all ||= [Strategy.range, Strategy.from, Strategy.to]
          end

          # Tightest range
          def Strategy.range
            @@_range ||= Strategy.new('range')
          end

          # Lowest minimum of the ranges
          def Strategy.from
            @@_from ||= Strategy.new('from')
          end

          # Lowest maximum of the ranges
          def Strategy.to
            @@_to ||= Strategy.new('to')
          end

          def to_hash
            value
          end

        end

        class SubcatalogItemStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SubcatalogItemStatus for this value, creating a new instance for an unknown value
          def SubcatalogItemStatus.apply(value)
            if value.instance_of?(SubcatalogItemStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SubcatalogItemStatus.new(value))
            end
          end

          # Returns the instance of SubcatalogItemStatus for this value, or nil if not found
          def SubcatalogItemStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SubcatalogItemStatus.ALL.find { |v| v.value == value }
          end

          def SubcatalogItemStatus.ALL
            @@all ||= [SubcatalogItemStatus.excluded, SubcatalogItemStatus.included, SubcatalogItemStatus.restricted]
          end

          # The user has chosen to exclude the item from the associated subcatalog.
          def SubcatalogItemStatus.excluded
            @@_excluded ||= SubcatalogItemStatus.new('excluded')
          end

          # The item is included in the associated subcatalog.
          def SubcatalogItemStatus.included
            @@_included ||= SubcatalogItemStatus.new('included')
          end

          # Item is not allowed to be sold in the market associated with the given
          # subcatalog.
          def SubcatalogItemStatus.restricted
            @@_restricted ||= SubcatalogItemStatus.new('restricted')
          end

          def to_hash
            value
          end

        end

        class SurchargeResponsibleParty

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SurchargeResponsibleParty for this value, creating a new instance for an unknown value
          def SurchargeResponsibleParty.apply(value)
            if value.instance_of?(SurchargeResponsibleParty)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SurchargeResponsibleParty.new(value))
            end
          end

          # Returns the instance of SurchargeResponsibleParty for this value, or nil if not found
          def SurchargeResponsibleParty.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SurchargeResponsibleParty.ALL.find { |v| v.value == value }
          end

          def SurchargeResponsibleParty.ALL
            @@all ||= [SurchargeResponsibleParty.organization, SurchargeResponsibleParty.customer]
          end

          # The merchant pays for this surcharge
          def SurchargeResponsibleParty.organization
            @@_organization ||= SurchargeResponsibleParty.new('organization')
          end

          # The customer pays for this surcharge
          def SurchargeResponsibleParty.customer
            @@_customer ||= SurchargeResponsibleParty.new('customer')
          end

          def to_hash
            value
          end

        end

        class TaxApplicability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TaxApplicability for this value, creating a new instance for an unknown value
          def TaxApplicability.apply(value)
            if value.instance_of?(TaxApplicability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TaxApplicability.new(value))
            end
          end

          # Returns the instance of TaxApplicability for this value, or nil if not found
          def TaxApplicability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TaxApplicability.ALL.find { |v| v.value == value }
          end

          def TaxApplicability.ALL
            @@all ||= [TaxApplicability.none, TaxApplicability.all]
          end

          # In no scenario should a customer pay tax within the Flow system.
          def TaxApplicability.none
            @@_none ||= TaxApplicability.new('none')
          end

          # In all scenarios a customer should pay tax within the Flow system.
          def TaxApplicability.all
            @@_all ||= TaxApplicability.new('all')
          end

          def to_hash
            value
          end

        end

        class TaxVerificationResult

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TaxVerificationResult for this value, creating a new instance for an unknown value
          def TaxVerificationResult.apply(value)
            if value.instance_of?(TaxVerificationResult)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TaxVerificationResult.new(value))
            end
          end

          # Returns the instance of TaxVerificationResult for this value, or nil if not found
          def TaxVerificationResult.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TaxVerificationResult.ALL.find { |v| v.value == value }
          end

          def TaxVerificationResult.ALL
            @@all ||= [TaxVerificationResult.valid, TaxVerificationResult.invalid, TaxVerificationResult.unable_to_validate]
          end

          def TaxVerificationResult.valid
            @@_valid ||= TaxVerificationResult.new('valid')
          end

          def TaxVerificationResult.invalid
            @@_invalid ||= TaxVerificationResult.new('invalid')
          end

          def TaxVerificationResult.unable_to_validate
            @@_unable_to_validate ||= TaxVerificationResult.new('unable_to_validate')
          end

          def to_hash
            value
          end

        end

        class TaxabilityType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TaxabilityType for this value, creating a new instance for an unknown value
          def TaxabilityType.apply(value)
            if value.instance_of?(TaxabilityType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TaxabilityType.new(value))
            end
          end

          # Returns the instance of TaxabilityType for this value, or nil if not found
          def TaxabilityType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TaxabilityType.ALL.find { |v| v.value == value }
          end

          def TaxabilityType.ALL
            @@all ||= [TaxabilityType.tax_rule]
          end

          # Rule indicating how taxes should be applied.  Acceptable values are defined by
          # the 'taxability_value' enum.
          def TaxabilityType.tax_rule
            @@_tax_rule ||= TaxabilityType.new('tax_rule')
          end

          def to_hash
            value
          end

        end

        class TaxabilityValue

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TaxabilityValue for this value, creating a new instance for an unknown value
          def TaxabilityValue.apply(value)
            if value.instance_of?(TaxabilityValue)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TaxabilityValue.new(value))
            end
          end

          # Returns the instance of TaxabilityValue for this value, or nil if not found
          def TaxabilityValue.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TaxabilityValue.ALL.find { |v| v.value == value }
          end

          def TaxabilityValue.ALL
            @@all ||= [TaxabilityValue.exempt]
          end

          # An item with this value is exempt from being taxed.
          def TaxabilityValue.exempt
            @@_exempt ||= TaxabilityValue.new('exempt')
          end

          def to_hash
            value
          end

        end

        class ThreeDSecureCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ThreeDSecureCode for this value, creating a new instance for an unknown value
          def ThreeDSecureCode.apply(value)
            if value.instance_of?(ThreeDSecureCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ThreeDSecureCode.new(value))
            end
          end

          # Returns the instance of ThreeDSecureCode for this value, or nil if not found
          def ThreeDSecureCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ThreeDSecureCode.ALL.find { |v| v.value == value }
          end

          def ThreeDSecureCode.ALL
            @@all ||= [ThreeDSecureCode.verified, ThreeDSecureCode.not_verified, ThreeDSecureCode.failed]
          end

          def ThreeDSecureCode.verified
            @@_verified ||= ThreeDSecureCode.new('verified')
          end

          def ThreeDSecureCode.not_verified
            @@_not_verified ||= ThreeDSecureCode.new('not_verified')
          end

          def ThreeDSecureCode.failed
            @@_failed ||= ThreeDSecureCode.new('failed')
          end

          def to_hash
            value
          end

        end

        class TierEstimateType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TierEstimateType for this value, creating a new instance for an unknown value
          def TierEstimateType.apply(value)
            if value.instance_of?(TierEstimateType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TierEstimateType.new(value))
            end
          end

          # Returns the instance of TierEstimateType for this value, or nil if not found
          def TierEstimateType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TierEstimateType.ALL.find { |v| v.value == value }
          end

          def TierEstimateType.ALL
            @@all ||= [TierEstimateType.calculated, TierEstimateType.custom]
          end

          # Displays the calculated delivery window estimate next to the shipping tier
          # name.
          def TierEstimateType.calculated
            @@_calculated ||= TierEstimateType.new('calculated')
          end

          # Shows a custom label next to the shipping tier name instead of a delivery
          # window estimate.
          def TierEstimateType.custom
            @@_custom ||= TierEstimateType.new('custom')
          end

          def to_hash
            value
          end

        end

        class TierStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TierStrategy for this value, creating a new instance for an unknown value
          def TierStrategy.apply(value)
            if value.instance_of?(TierStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TierStrategy.new(value))
            end
          end

          # Returns the instance of TierStrategy for this value, or nil if not found
          def TierStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TierStrategy.ALL.find { |v| v.value == value }
          end

          def TierStrategy.ALL
            @@all ||= [TierStrategy.fastest, TierStrategy.lowest_cost]
          end

          # Optimize for fastest first, then cheapest
          def TierStrategy.fastest
            @@_fastest ||= TierStrategy.new('fastest')
          end

          # Optimize for lowest cost first, then fastest
          def TierStrategy.lowest_cost
            @@_lowest_cost ||= TierStrategy.new('lowest_cost')
          end

          def to_hash
            value
          end

        end

        class TokenType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TokenType for this value, creating a new instance for an unknown value
          def TokenType.apply(value)
            if value.instance_of?(TokenType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TokenType.new(value))
            end
          end

          # Returns the instance of TokenType for this value, or nil if not found
          def TokenType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TokenType.ALL.find { |v| v.value == value }
          end

          def TokenType.ALL
            @@all ||= [TokenType.permanent, TokenType.one_time]
          end

          # Create a permanent token for the card (stored up until normal purge interval)
          def TokenType.permanent
            @@_permanent ||= TokenType.new('permanent')
          end

          # Create a one time token for the card. This token can be used to either
          # authorized payment or later exchange for a permanent token. Once used, this
          # token cannot be used for future activity.
          def TokenType.one_time
            @@_one_time ||= TokenType.new('one_time')
          end

          def to_hash
            value
          end

        end

        class TrackingNumberType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TrackingNumberType for this value, creating a new instance for an unknown value
          def TrackingNumberType.apply(value)
            if value.instance_of?(TrackingNumberType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TrackingNumberType.new(value))
            end
          end

          # Returns the instance of TrackingNumberType for this value, or nil if not found
          def TrackingNumberType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TrackingNumberType.ALL.find { |v| v.value == value }
          end

          def TrackingNumberType.ALL
            @@all ||= [TrackingNumberType.flow, TrackingNumberType.carrier]
          end

          def TrackingNumberType.flow
            @@_flow ||= TrackingNumberType.new('flow')
          end

          def TrackingNumberType.carrier
            @@_carrier ||= TrackingNumberType.new('carrier')
          end

          def to_hash
            value
          end

        end

        class TrackingStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TrackingStatus for this value, creating a new instance for an unknown value
          def TrackingStatus.apply(value)
            if value.instance_of?(TrackingStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TrackingStatus.new(value))
            end
          end

          # Returns the instance of TrackingStatus for this value, or nil if not found
          def TrackingStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TrackingStatus.ALL.find { |v| v.value == value }
          end

          def TrackingStatus.ALL
            @@all ||= [TrackingStatus.label_created, TrackingStatus.pending, TrackingStatus.info_received, TrackingStatus.picked_up, TrackingStatus.in_transit, TrackingStatus.out_for_delivery, TrackingStatus.attempt_fail, TrackingStatus.delivered, TrackingStatus.exception, TrackingStatus.returned, TrackingStatus.expired]
          end

          def TrackingStatus.label_created
            @@_label_created ||= TrackingStatus.new('label_created')
          end

          def TrackingStatus.pending
            @@_pending ||= TrackingStatus.new('pending')
          end

          def TrackingStatus.info_received
            @@_info_received ||= TrackingStatus.new('info_received')
          end

          def TrackingStatus.picked_up
            @@_picked_up ||= TrackingStatus.new('picked_up')
          end

          def TrackingStatus.in_transit
            @@_in_transit ||= TrackingStatus.new('in_transit')
          end

          def TrackingStatus.out_for_delivery
            @@_out_for_delivery ||= TrackingStatus.new('out_for_delivery')
          end

          def TrackingStatus.attempt_fail
            @@_attempt_fail ||= TrackingStatus.new('attempt_fail')
          end

          def TrackingStatus.delivered
            @@_delivered ||= TrackingStatus.new('delivered')
          end

          def TrackingStatus.exception
            @@_exception ||= TrackingStatus.new('exception')
          end

          def TrackingStatus.returned
            @@_returned ||= TrackingStatus.new('returned')
          end

          def TrackingStatus.expired
            @@_expired ||= TrackingStatus.new('expired')
          end

          def to_hash
            value
          end

        end

        class UnitOfMeasurement

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfMeasurement for this value, creating a new instance for an unknown value
          def UnitOfMeasurement.apply(value)
            if value.instance_of?(UnitOfMeasurement)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfMeasurement.new(value))
            end
          end

          # Returns the instance of UnitOfMeasurement for this value, or nil if not found
          def UnitOfMeasurement.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfMeasurement.ALL.find { |v| v.value == value }
          end

          def UnitOfMeasurement.ALL
            @@all ||= [UnitOfMeasurement.millimeter, UnitOfMeasurement.centimeter, UnitOfMeasurement.inch, UnitOfMeasurement.foot, UnitOfMeasurement.cubic_inch, UnitOfMeasurement.cubic_meter, UnitOfMeasurement.gram, UnitOfMeasurement.kilogram, UnitOfMeasurement.meter, UnitOfMeasurement.ounce, UnitOfMeasurement.pound]
          end

          # Equivalent to MILLI(METRE).
          def UnitOfMeasurement.millimeter
            @@_millimeter ||= UnitOfMeasurement.new('millimeter')
          end

          # Equivalent to CENTI(METRE).
          def UnitOfMeasurement.centimeter
            @@_centimeter ||= UnitOfMeasurement.new('centimeter')
          end

          # A unit of length equal to 0.0254 m (standard name in).
          def UnitOfMeasurement.inch
            @@_inch ||= UnitOfMeasurement.new('inch')
          end

          # A unit of length equal to 0.3048 m (standard name ft).
          def UnitOfMeasurement.foot
            @@_foot ||= UnitOfMeasurement.new('foot')
          end

          # A unit of volume equal to one cubic inch (in).
          def UnitOfMeasurement.cubic_inch
            @@_cubic_inch ||= UnitOfMeasurement.new('cubic_inch')
          end

          # The metric unit for volume quantities (m).
          def UnitOfMeasurement.cubic_meter
            @@_cubic_meter ||= UnitOfMeasurement.new('cubic_meter')
          end

          # A unit of mass equal to 1 / 1000 kilogram (standard name g).
          def UnitOfMeasurement.gram
            @@_gram ||= UnitOfMeasurement.new('gram')
          end

          # The base unit for mass quantities (kg).
          def UnitOfMeasurement.kilogram
            @@_kilogram ||= UnitOfMeasurement.new('kilogram')
          end

          # The base unit for length quantities (m).
          def UnitOfMeasurement.meter
            @@_meter ||= UnitOfMeasurement.new('meter')
          end

          # A unit of mass equal to 1 / 16 POUND (standard name oz).
          def UnitOfMeasurement.ounce
            @@_ounce ||= UnitOfMeasurement.new('ounce')
          end

          # A unit of mass equal to 453.59237 grams (avoirdupois pound, standard name lb).
          def UnitOfMeasurement.pound
            @@_pound ||= UnitOfMeasurement.new('pound')
          end

          def to_hash
            value
          end

        end

        class UnitOfTime

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfTime for this value, creating a new instance for an unknown value
          def UnitOfTime.apply(value)
            if value.instance_of?(UnitOfTime)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfTime.new(value))
            end
          end

          # Returns the instance of UnitOfTime for this value, or nil if not found
          def UnitOfTime.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfTime.ALL.find { |v| v.value == value }
          end

          def UnitOfTime.ALL
            @@all ||= [UnitOfTime.year, UnitOfTime.month, UnitOfTime.week, UnitOfTime.day, UnitOfTime.hour, UnitOfTime.minute]
          end

          def UnitOfTime.year
            @@_year ||= UnitOfTime.new('year')
          end

          def UnitOfTime.month
            @@_month ||= UnitOfTime.new('month')
          end

          def UnitOfTime.week
            @@_week ||= UnitOfTime.new('week')
          end

          def UnitOfTime.day
            @@_day ||= UnitOfTime.new('day')
          end

          def UnitOfTime.hour
            @@_hour ||= UnitOfTime.new('hour')
          end

          def UnitOfTime.minute
            @@_minute ||= UnitOfTime.new('minute')
          end

          def to_hash
            value
          end

        end

        class UpdatePolicy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdatePolicy for this value, creating a new instance for an unknown value
          def UpdatePolicy.apply(value)
            if value.instance_of?(UpdatePolicy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdatePolicy.new(value))
            end
          end

          # Returns the instance of UpdatePolicy for this value, or nil if not found
          def UpdatePolicy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdatePolicy.ALL.find { |v| v.value == value }
          end

          def UpdatePolicy.ALL
            @@all ||= [UpdatePolicy.auto, UpdatePolicy.queue, UpdatePolicy.discard]
          end

          def UpdatePolicy.auto
            @@_auto ||= UpdatePolicy.new('auto')
          end

          # Queue item update for approval.
          def UpdatePolicy.queue
            @@_queue ||= UpdatePolicy.new('queue')
          end

          def UpdatePolicy.discard
            @@_discard ||= UpdatePolicy.new('discard')
          end

          def to_hash
            value
          end

        end

        class UpdateType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdateType for this value, creating a new instance for an unknown value
          def UpdateType.apply(value)
            if value.instance_of?(UpdateType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdateType.new(value))
            end
          end

          # Returns the instance of UpdateType for this value, or nil if not found
          def UpdateType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdateType.ALL.find { |v| v.value == value }
          end

          def UpdateType.ALL
            @@all ||= [UpdateType.change, UpdateType.set]
          end

          # Long value to increment or decrement. Positive quantities are added to
          # inventory while negative quantities are decrement from inventory.
          def UpdateType.change
            @@_change ||= UpdateType.new('change')
          end

          # Set absolute quantity to new value with no regard for previous updates
          def UpdateType.set
            @@_set ||= UpdateType.new('set')
          end

          def to_hash
            value
          end

        end

        class UserStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UserStatus for this value, creating a new instance for an unknown value
          def UserStatus.apply(value)
            if value.instance_of?(UserStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UserStatus.new(value))
            end
          end

          # Returns the instance of UserStatus for this value, or nil if not found
          def UserStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UserStatus.ALL.find { |v| v.value == value }
          end

          def UserStatus.ALL
            @@all ||= [UserStatus.pending, UserStatus.active, UserStatus.inactive]
          end

          # Represents a new user account that is pending approval
          def UserStatus.pending
            @@_pending ||= UserStatus.new('pending')
          end

          # Represents an active user account - can authenticate with this account
          def UserStatus.active
            @@_active ||= UserStatus.new('active')
          end

          # Represents an inactive user account - can no longer authenticate with this
          # account
          def UserStatus.inactive
            @@_inactive ||= UserStatus.new('inactive')
          end

          def to_hash
            value
          end

        end

        class ValueAddedService

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ValueAddedService for this value, creating a new instance for an unknown value
          def ValueAddedService.apply(value)
            if value.instance_of?(ValueAddedService)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ValueAddedService.new(value))
            end
          end

          # Returns the instance of ValueAddedService for this value, or nil if not found
          def ValueAddedService.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ValueAddedService.ALL.find { |v| v.value == value }
          end

          def ValueAddedService.ALL
            @@all ||= [ValueAddedService.hazardous_material]
          end

          # See https://en.wikipedia.org/wiki/ORM-D
          def ValueAddedService.hazardous_material
            @@_hazardous_material ||= ValueAddedService.new('Hazardous Material')
          end

          def to_hash
            value
          end

        end

        class Visibility

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Visibility for this value, creating a new instance for an unknown value
          def Visibility.apply(value)
            if value.instance_of?(Visibility)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Visibility.new(value))
            end
          end

          # Returns the instance of Visibility for this value, or nil if not found
          def Visibility.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Visibility.ALL.find { |v| v.value == value }
          end

          def Visibility.ALL
            @@all ||= [Visibility.public, Visibility.private]
          end

          def Visibility.public
            @@_public ||= Visibility.new('public')
          end

          def Visibility.private
            @@_private ||= Visibility.new('private')
          end

          def to_hash
            value
          end

        end

        class WebhookStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of WebhookStatus for this value, creating a new instance for an unknown value
          def WebhookStatus.apply(value)
            if value.instance_of?(WebhookStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || WebhookStatus.new(value))
            end
          end

          # Returns the instance of WebhookStatus for this value, or nil if not found
          def WebhookStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            WebhookStatus.ALL.find { |v| v.value == value }
          end

          def WebhookStatus.ALL
            @@all ||= [WebhookStatus.pending, WebhookStatus.success, WebhookStatus.failure]
          end

          def WebhookStatus.pending
            @@_pending ||= WebhookStatus.new('pending')
          end

          def WebhookStatus.success
            @@_success ||= WebhookStatus.new('success')
          end

          def WebhookStatus.failure
            @@_failure ||= WebhookStatus.new('failure')
          end

          def to_hash
            value
          end

        end

        class ZeroAmountIndicator

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ZeroAmountIndicator for this value, creating a new instance for an unknown value
          def ZeroAmountIndicator.apply(value)
            if value.instance_of?(ZeroAmountIndicator)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ZeroAmountIndicator.new(value))
            end
          end

          # Returns the instance of ZeroAmountIndicator for this value, or nil if not found
          def ZeroAmountIndicator.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ZeroAmountIndicator.ALL.find { |v| v.value == value }
          end

          def ZeroAmountIndicator.ALL
            @@all ||= [ZeroAmountIndicator.zero, ZeroAmountIndicator.free]
          end

          # Show the number 0.00 in the label
          def ZeroAmountIndicator.zero
            @@_zero ||= ZeroAmountIndicator.new('zero')
          end

          # Show the word `FREE` in the label
          def ZeroAmountIndicator.free
            @@_free ||= ZeroAmountIndicator.new('free')
          end

          def to_hash
            value
          end

        end

        class AccountOrdersExportType < ExportType

          attr_reader :statement_id, :transaction_summary_id, :transaction_created_from, :transaction_created_to, :transaction_created_on_or_after, :transaction_created_after, :transaction_created_on_or_before, :transaction_created_before, :transaction_posted_from, :transaction_posted_to, :transaction_posted_on_or_after, :transaction_posted_after, :transaction_posted_on_or_before, :transaction_posted_before

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::ACCOUNT_ORDERS_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @statement_id = (x = opts.delete(:statement_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('statement_id', x, String))
            @transaction_summary_id = (x = opts.delete(:transaction_summary_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_summary_id', x, String))
            @transaction_created_from = (x = opts.delete(:transaction_created_from); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_created_from', HttpClient::Helper.to_date_iso8601(x), Date))
            @transaction_created_to = (x = opts.delete(:transaction_created_to); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_created_to', HttpClient::Helper.to_date_iso8601(x), Date))
            @transaction_created_on_or_after = (x = opts.delete(:transaction_created_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_created_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_created_after = (x = opts.delete(:transaction_created_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_created_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_created_on_or_before = (x = opts.delete(:transaction_created_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_created_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_created_before = (x = opts.delete(:transaction_created_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_created_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_posted_from = (x = opts.delete(:transaction_posted_from); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_from', HttpClient::Helper.to_date_iso8601(x), Date))
            @transaction_posted_to = (x = opts.delete(:transaction_posted_to); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_to', HttpClient::Helper.to_date_iso8601(x), Date))
            @transaction_posted_on_or_after = (x = opts.delete(:transaction_posted_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_posted_after = (x = opts.delete(:transaction_posted_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_posted_on_or_before = (x = opts.delete(:transaction_posted_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_posted_before = (x = opts.delete(:transaction_posted_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AccountOrdersExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :statement_id => statement_id,
              :transaction_summary_id => transaction_summary_id,
              :transaction_created_from => transaction_created_from,
              :transaction_created_to => transaction_created_to,
              :transaction_created_on_or_after => transaction_created_on_or_after,
              :transaction_created_after => transaction_created_after,
              :transaction_created_on_or_before => transaction_created_on_or_before,
              :transaction_created_before => transaction_created_before,
              :transaction_posted_from => transaction_posted_from,
              :transaction_posted_to => transaction_posted_to,
              :transaction_posted_on_or_after => transaction_posted_on_or_after,
              :transaction_posted_after => transaction_posted_after,
              :transaction_posted_on_or_before => transaction_posted_on_or_before,
              :transaction_posted_before => transaction_posted_before
            }
          end

        end

        class AccountTransactionsExportType < ExportType

          attr_reader :statement_id, :transaction_summary_id, :created_from, :created_to, :created_on_or_after, :created_after, :created_on_or_before, :created_before, :posted_from, :posted_to, :posted_on_or_after, :posted_after, :posted_on_or_before, :posted_before

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::ACCOUNT_TRANSACTIONS_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @statement_id = (x = opts.delete(:statement_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('statement_id', x, String))
            @transaction_summary_id = (x = opts.delete(:transaction_summary_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_summary_id', x, String))
            @created_from = (x = opts.delete(:created_from); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_from', HttpClient::Helper.to_date_iso8601(x), Date))
            @created_to = (x = opts.delete(:created_to); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_to', HttpClient::Helper.to_date_iso8601(x), Date))
            @created_on_or_after = (x = opts.delete(:created_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @created_after = (x = opts.delete(:created_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @created_on_or_before = (x = opts.delete(:created_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @created_before = (x = opts.delete(:created_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @posted_from = (x = opts.delete(:posted_from); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_from', HttpClient::Helper.to_date_iso8601(x), Date))
            @posted_to = (x = opts.delete(:posted_to); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_to', HttpClient::Helper.to_date_iso8601(x), Date))
            @posted_on_or_after = (x = opts.delete(:posted_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @posted_after = (x = opts.delete(:posted_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @posted_on_or_before = (x = opts.delete(:posted_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @posted_before = (x = opts.delete(:posted_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AccountTransactionsExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :statement_id => statement_id,
              :transaction_summary_id => transaction_summary_id,
              :created_from => created_from,
              :created_to => created_to,
              :created_on_or_after => created_on_or_after,
              :created_after => created_after,
              :created_on_or_before => created_on_or_before,
              :created_before => created_before,
              :posted_from => posted_from,
              :posted_to => posted_to,
              :posted_on_or_after => posted_on_or_after,
              :posted_after => posted_after,
              :posted_on_or_before => posted_on_or_before,
              :posted_before => posted_before
            }
          end

        end

        # Used for initiating an ACH (Automated Clearing House) bank transfer.
        class AchAuthorizationForm < AuthorizationForm

          attr_reader :account_owner_name, :account_number, :routing_number, :billing_address, :order_number, :amount, :currency, :key, :attributes, :ip

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::ACH_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:account_owner_name, :account_number, :routing_number, :billing_address, :amount, :currency], 'AchAuthorizationForm')
            @account_owner_name = HttpClient::Preconditions.assert_class('account_owner_name', opts.delete(:account_owner_name), String)
            @account_number = HttpClient::Preconditions.assert_class('account_number', opts.delete(:account_number), String)
            @routing_number = HttpClient::Preconditions.assert_class('routing_number', opts.delete(:routing_number), String)
            @billing_address = (x = opts.delete(:billing_address); x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AchAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :account_owner_name => account_owner_name,
              :account_number => account_number,
              :routing_number => routing_number,
              :billing_address => billing_address.to_hash,
              :order_number => order_number,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :key => key,
              :attributes => attributes.nil? ? nil : attributes,
              :ip => ip
            }
          end

        end

        # Defines structured fields for address to be used in user/form input. Either
        # text or the structured input needs to be present.
        class Address

          attr_reader :text, :streets, :street_number, :city, :province, :postal, :country, :latitude, :longitude

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @street_number = (x = opts.delete(:street_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('street_number', x, String))
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @latitude = (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String))
            @longitude = (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Address.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :text => text,
              :streets => streets.nil? ? nil : streets,
              :street_number => street_number,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :latitude => latitude,
              :longitude => longitude
            }
          end

        end

        class AddressConfiguration

          attr_reader :country, :field_validation, :provinces

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :field_validation], 'AddressConfiguration')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @field_validation = (x = opts.delete(:field_validation); x.is_a?(::Io::Flow::V0::Models::AddressFieldValidation) ? x : ::Io::Flow::V0::Models::AddressFieldValidation.new(x))
            @provinces = HttpClient::Preconditions.assert_class('provinces', (x = opts.delete(:provinces); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AddressConfigurationProvince) ? x : ::Io::Flow::V0::Models::AddressConfigurationProvince.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressConfiguration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country,
              :field_validation => field_validation.to_hash,
              :provinces => provinces.map { |o| o.to_hash }
            }
          end

        end

        class AddressConfigurationProvince

          attr_reader :value, :name, :translations

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :name], 'AddressConfigurationProvince')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @translations = (x = opts.delete(:translations); x.nil? ? nil : HttpClient::Preconditions.assert_class('translations', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AddressConfigurationProvinceTranslation) ? x : ::Io::Flow::V0::Models::AddressConfigurationProvinceTranslation.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressConfigurationProvince.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value,
              :name => name,
              :translations => translations.nil? ? nil : translations.map { |o| o.to_hash }
            }
          end

        end

        class AddressConfigurationProvinceTranslation

          attr_reader :locale, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:locale, :name], 'AddressConfigurationProvinceTranslation')
            @locale = (x = opts.delete(:locale); x.is_a?(::Io::Flow::V0::Models::AddressConfigurationProvinceTranslationLocale) ? x : ::Io::Flow::V0::Models::AddressConfigurationProvinceTranslationLocale.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressConfigurationProvinceTranslation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :locale => locale.to_hash,
              :name => name
            }
          end

        end

        class AddressConfigurationProvinceTranslationLocale

          attr_reader :id, :name, :language

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :language], 'AddressConfigurationProvinceTranslationLocale')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressConfigurationProvinceTranslationLocale.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :language => language
            }
          end

        end

        class AddressFieldValidation

          attr_reader :first_name, :last_name, :street_1, :street_2, :city, :province, :postal, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first_name = HttpClient::Preconditions.assert_class('first_name', (x = opts.delete(:first_name); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
            @last_name = HttpClient::Preconditions.assert_class('last_name', (x = opts.delete(:last_name); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
            @street_1 = HttpClient::Preconditions.assert_class('street_1', (x = opts.delete(:street_1); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
            @street_2 = HttpClient::Preconditions.assert_class('street_2', (x = opts.delete(:street_2); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
            @city = HttpClient::Preconditions.assert_class('city', (x = opts.delete(:city); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
            @province = HttpClient::Preconditions.assert_class('province', (x = opts.delete(:province); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
            @postal = HttpClient::Preconditions.assert_class('postal', (x = opts.delete(:postal); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
            @phone = HttpClient::Preconditions.assert_class('phone', (x = opts.delete(:phone); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FieldValidationRule) ? x : ::Io::Flow::V0::Models::FieldValidationRule.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressFieldValidation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first_name => first_name.map { |o| o.to_hash },
              :last_name => last_name.map { |o| o.to_hash },
              :street_1 => street_1.map { |o| o.to_hash },
              :street_2 => street_2.map { |o| o.to_hash },
              :city => city.map { |o| o.to_hash },
              :province => province.map { |o| o.to_hash },
              :postal => postal.map { |o| o.to_hash },
              :phone => phone.map { |o| o.to_hash }
            }
          end

        end

        # A suggested address (usually providing more accurate information). This object
        # contains both the suggested address as well as metadata on which fields are
        # actually different
        class AddressSuggestion

          attr_reader :address, :streets, :city, :province, :postal, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :streets, :city, :province, :postal, :country], 'AddressSuggestion')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @streets = HttpClient::Preconditions.assert_boolean('streets', opts.delete(:streets))
            @city = HttpClient::Preconditions.assert_boolean('city', opts.delete(:city))
            @province = HttpClient::Preconditions.assert_boolean('province', opts.delete(:province))
            @postal = HttpClient::Preconditions.assert_boolean('postal', opts.delete(:postal))
            @country = HttpClient::Preconditions.assert_boolean('country', opts.delete(:country))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressSuggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :streets => streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country
            }
          end

        end

        # Address verification returns information on whether or not an address is valid
        # and deliverable - meaning carriers will accept this address. Also returns
        # suggestions for address correction, including data to highlight specific
        # fields to correct.
        class AddressVerification

          attr_reader :address, :valid, :suggestions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :valid], 'AddressVerification')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @valid = HttpClient::Preconditions.assert_boolean('valid', opts.delete(:valid))
            @suggestions = HttpClient::Preconditions.assert_class('suggestions', (x = opts.delete(:suggestions); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AddressSuggestion) ? x : ::Io::Flow::V0::Models::AddressSuggestion.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressVerification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :valid => valid,
              :suggestions => suggestions.map { |o| o.to_hash }
            }
          end

        end

        class AdjustmentReason

          attr_reader :key, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :label], 'AdjustmentReason')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::AdjustmentReasonKey) ? x : ::Io::Flow::V0::Models::AdjustmentReasonKey.apply(x))
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AdjustmentReason.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :label => label
            }
          end

        end

        # Data required to assist in challenging a customer natively.
        class AdyenChallengeShopperData < AdyenNativeData

          attr_reader :challenge_token

          def initialize(incoming={})
            super(:discriminator => AdyenNativeData::Types::ADYEN_CHALLENGE_SHOPPER_DATA)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:challenge_token], 'AdyenChallengeShopperData')
            @challenge_token = HttpClient::Preconditions.assert_class('challenge_token', opts.delete(:challenge_token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AdyenChallengeShopperData.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :challenge_token => challenge_token
            }
          end

        end

        # Data required to assist in identifying a customer natively.
        class AdyenIdentifyShopperData < AdyenNativeData

          attr_reader :fingerprint_token

          def initialize(incoming={})
            super(:discriminator => AdyenNativeData::Types::ADYEN_IDENTIFY_SHOPPER_DATA)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:fingerprint_token], 'AdyenIdentifyShopperData')
            @fingerprint_token = HttpClient::Preconditions.assert_class('fingerprint_token', opts.delete(:fingerprint_token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AdyenIdentifyShopperData.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :fingerprint_token => fingerprint_token
            }
          end

        end

        # Provides details for how to acquire additional information from the customer
        # natively in the browser for Adyen (e.g. 3DS2)
        class AdyenNativeActionDetails < AuthorizationResultActionDetails

          attr_reader :origin_key, :data

          def initialize(incoming={})
            super(:discriminator => AuthorizationResultActionDetails::Types::ADYEN_NATIVE_ACTION_DETAILS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin_key = (x = opts.delete(:origin_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin_key', x, String))
            @data = (x = opts.delete(:data); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AdyenNativeData) ? x : ::Io::Flow::V0::Models::AdyenNativeData.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AdyenNativeActionDetails.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :origin_key => origin_key,
              :data => data.nil? ? nil : data.to_hash
            }
          end

        end

        class Allocation

          attr_reader :order, :details

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order, :details], 'Allocation')
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::AllocationOrderSummary) ? x : ::Io::Flow::V0::Models::AllocationOrderSummary.new(x))
            @details = HttpClient::Preconditions.assert_class('details', opts.delete(:details), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationDetail) ? x : ::Io::Flow::V0::Models::AllocationDetail.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Allocation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order.to_hash,
              :details => details.map { |o| o.to_hash }
            }
          end

        end

        class AllocationDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ALLOCATION_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'AllocationDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Represents any component that is not VAT or duty, such as item price,
        # rounding, shipping, etc.
        class AllocationDetailComponent < AllocationComponent

          attr_reader :key, :total, :price

          def initialize(incoming={})
            super(:discriminator => AllocationComponent::Types::ALLOCATION_DETAIL_COMPONENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :total], 'AllocationDetailComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponentKey.apply(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationDetailComponent.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key.value,
              :total => total.to_hash,
              :price => price.nil? ? nil : price.to_hash
            }
          end

        end

        # Represents either a VAT or duty component.
        class AllocationLevyComponent < AllocationComponent

          attr_reader :key, :total, :rate, :name, :price, :accuracy, :basis

          def initialize(incoming={})
            super(:discriminator => AllocationComponent::Types::ALLOCATION_LEVY_COMPONENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :total, :rate, :name], 'AllocationLevyComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponentKey.apply(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @accuracy = (x = (x = opts.delete(:accuracy); x.nil? ? "calculated" : x); x.is_a?(::Io::Flow::V0::Models::PriceAccuracy) ? x : ::Io::Flow::V0::Models::PriceAccuracy.apply(x))
            @basis = (x = opts.delete(:basis); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MoneyWithBase) ? x : ::Io::Flow::V0::Models::MoneyWithBase.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationLevyComponent.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key.value,
              :total => total.to_hash,
              :rate => rate.to_f.to_s,
              :name => name,
              :price => price.nil? ? nil : price.to_hash,
              :accuracy => accuracy.value,
              :basis => basis.nil? ? nil : basis.to_hash
            }
          end

        end

        class AllocationLineDetail < AllocationDetail

          attr_reader :number, :quantity, :key, :price, :total, :included, :not_included

          def initialize(incoming={})
            super(:discriminator => AllocationDetail::Types::ALLOCATION_LINE_DETAIL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity, :key, :price, :total, :included, :not_included], 'AllocationLineDetail')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailKey.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @included = HttpClient::Preconditions.assert_class('included', opts.delete(:included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
            @not_included = HttpClient::Preconditions.assert_class('not_included', opts.delete(:not_included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationLineDetail.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :number => number,
              :quantity => quantity,
              :key => key.value,
              :price => price.to_hash,
              :total => total.to_hash,
              :included => included.map { |o| o.to_hash },
              :not_included => not_included.map { |o| o.to_hash }
            }
          end

        end

        # Represents an order-specific detail such as shipping, insurance, or an
        # order-level discount.
        class AllocationOrderDetail < AllocationDetail

          attr_reader :key, :total, :included, :not_included

          def initialize(incoming={})
            super(:discriminator => AllocationDetail::Types::ALLOCATION_ORDER_DETAIL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :total, :included, :not_included], 'AllocationOrderDetail')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailKey.apply(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @included = HttpClient::Preconditions.assert_class('included', opts.delete(:included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
            @not_included = HttpClient::Preconditions.assert_class('not_included', opts.delete(:not_included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationOrderDetail.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key.value,
              :total => total.to_hash,
              :included => included.map { |o| o.to_hash },
              :not_included => not_included.map { |o| o.to_hash }
            }
          end

        end

        class AllocationOrderSummary

          attr_reader :id, :number, :submitted_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'AllocationOrderSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @submitted_at = (x = opts.delete(:submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationOrderSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :submitted_at => submitted_at
            }
          end

        end

        class AllocationUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :allocation

          def initialize(incoming={})
            super(:discriminator => Event::Types::ALLOCATION_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :allocation], 'AllocationUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @allocation = (x = opts.delete(:allocation); x.is_a?(::Io::Flow::V0::Models::AllocationV2) ? x : ::Io::Flow::V0::Models::AllocationV2.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :allocation => allocation.to_hash
            }
          end

        end

        class AllocationV2

          attr_reader :id, :order, :details, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order, :details, :total], 'AllocationV2')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::AllocationOrderSummary) ? x : ::Io::Flow::V0::Models::AllocationOrderSummary.new(x))
            @details = HttpClient::Preconditions.assert_class('details', opts.delete(:details), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationDetail) ? x : ::Io::Flow::V0::Models::AllocationDetail.from_json(x)) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationV2.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :order => order.to_hash,
              :details => details.map { |o| o.to_hash },
              :total => total.to_hash
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin price
        class AmountMargin < TierRuleOutcome

          attr_reader :margin

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::AMOUNT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:margin], 'AmountMargin')
            @margin = (x = opts.delete(:margin); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AmountMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :margin => margin.to_hash
            }
          end

        end

        class AmountMarginForm < TierRuleOutcomeForm

          attr_reader :margin

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcomeForm::Types::AMOUNT_MARGIN_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:margin], 'AmountMarginForm')
            @margin = (x = opts.delete(:margin); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AmountMarginForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :margin => margin.to_hash
            }
          end

        end

        class AnalyticsExportType < ExportType

          attr_reader :from, :to, :region, :interval

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::ANALYTICS_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @from = (x = opts.delete(:from); x.nil? ? nil : HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @to = (x = opts.delete(:to); x.nil? ? nil : HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @region = (x = opts.delete(:region); x.nil? ? nil : HttpClient::Preconditions.assert_class('region', x, String))
            @interval = (x = opts.delete(:interval); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AnalyticsExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :from => from,
              :to => to,
              :region => region,
              :interval => interval.nil? ? nil : interval.value
            }
          end

        end

        class ApplePayMerchantValidationPayload < AuthorizationPayloadParameters

          attr_reader :validation_url, :display_name

          def initialize(incoming={})
            super(:discriminator => AuthorizationPayloadParameters::Types::APPLE_PAY_MERCHANT_VALIDATION_PAYLOAD)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:validation_url], 'ApplePayMerchantValidationPayload')
            @validation_url = HttpClient::Preconditions.assert_class('validation_url', opts.delete(:validation_url), String)
            @display_name = (x = opts.delete(:display_name); x.nil? ? nil : HttpClient::Preconditions.assert_class('display_name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ApplePayMerchantValidationPayload.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :validation_url => validation_url,
              :display_name => display_name
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost of the service
        class AtCost < TierRuleOutcome

          attr_reader :ignore

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::AT_COST)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ignore = (x = opts.delete(:ignore); x.nil? ? nil : HttpClient::Preconditions.assert_class('ignore', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AtCost.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :ignore => ignore
            }
          end

        end

        # An attribute can be configured to be used in different ways throughout Flow. A
        # common example is to identify a meaningful attribute (e.g. brand) that can
        # then be displayed throughout the Flow console.
        class Attribute

          attr_reader :id, :key, :options, :label, :intent, :type, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :options], 'Attribute')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
            @intent = (x = opts.delete(:intent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeIntent) ? x : ::Io::Flow::V0::Models::AttributeIntent.apply(x)))
            @type = (x = opts.delete(:type); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeDataType) ? x : ::Io::Flow::V0::Models::AttributeDataType.apply(x)))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Attribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :options => options.to_hash,
              :label => label,
              :intent => intent.nil? ? nil : intent.value,
              :type => type.nil? ? nil : type.value,
              :position => position
            }
          end

        end

        class AttributeDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ATTRIBUTE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key], 'AttributeDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key
            }
          end

        end

        class AttributeDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ATTRIBUTE_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'AttributeDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class AttributeForm

          attr_reader :key, :options, :label, :intent, :type, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :options], 'AttributeForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
            @intent = (x = opts.delete(:intent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeIntent) ? x : ::Io::Flow::V0::Models::AttributeIntent.apply(x)))
            @type = (x = opts.delete(:type); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeDataType) ? x : ::Io::Flow::V0::Models::AttributeDataType.apply(x)))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :options => options.to_hash,
              :label => label,
              :intent => intent.nil? ? nil : intent.value,
              :type => type.nil? ? nil : type.value,
              :position => position
            }
          end

        end

        class AttributeUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :label, :intent, :type

          def initialize(incoming={})
            super(:discriminator => Event::Types::ATTRIBUTE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :label, :type], 'AttributeUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @intent = (x = opts.delete(:intent); x.nil? ? nil : HttpClient::Preconditions.assert_class('intent', x, String))
            @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :label => label,
              :intent => intent,
              :type => type
            }
          end

        end

        class AttributeUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :attribute

          def initialize(incoming={})
            super(:discriminator => Event::Types::ATTRIBUTE_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :attribute], 'AttributeUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @attribute = (x = opts.delete(:attribute); x.is_a?(::Io::Flow::V0::Models::Attribute) ? x : ::Io::Flow::V0::Models::Attribute.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :attribute => attribute.to_hash
            }
          end

        end

        # Retrieve journaled history of an attribute
        class AttributeVersion

          attr_reader :id, :timestamp, :type, :attribute

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :attribute], 'AttributeVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @attribute = (x = opts.delete(:attribute); x.is_a?(::Io::Flow::V0::Models::Attribute) ? x : ::Io::Flow::V0::Models::Attribute.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :attribute => attribute.to_hash
            }
          end

        end

        class AuthenticationForm

          attr_reader :email, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email, :password], 'AuthenticationForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password
            }
          end

        end

        # Creates a new authorization based on the underlying information in an existing
        # authorization. A common use case here is to create a new auth when the
        # existing one has expired.
        class AuthorizationCopyForm < AuthorizationForm

          attr_reader :source_authorization_key, :amount, :currency, :attributes

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::AUTHORIZATION_COPY_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:source_authorization_key, :amount, :currency], 'AuthorizationCopyForm')
            @source_authorization_key = HttpClient::Preconditions.assert_class('source_authorization_key', opts.delete(:source_authorization_key), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationCopyForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :source_authorization_key => source_authorization_key,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class AuthorizationDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::AUTHORIZATION_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'AuthorizationDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Details for why an authorization was not created
        class AuthorizationError

          attr_reader :code, :messages, :avs, :cvv

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'AuthorizationError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::AuthorizationDeclineCode) ? x : ::Io::Flow::V0::Models::AuthorizationDeclineCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        class AuthorizationOrderReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'AuthorizationOrderReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationOrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        # Used to complete an inline authorization like Google Pay or Apple Pay.
        class AuthorizationPayload

          attr_reader :parameters

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:parameters], 'AuthorizationPayload')
            @parameters = (x = opts.delete(:parameters); x.is_a?(::Io::Flow::V0::Models::AuthorizationPayloadParameters) ? x : ::Io::Flow::V0::Models::AuthorizationPayloadParameters.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationPayload.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :parameters => parameters.to_hash
            }
          end

        end

        class AuthorizationReference

          attr_reader :id, :key, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'AuthorizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationOrderReference) ? x : ::Io::Flow::V0::Models::AuthorizationOrderReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :order => order.nil? ? nil : order.to_hash
            }
          end

        end

        # Contains the result of the authorization. If an immediate response is not
        # available, the state will be 'pending' - this usually indicates fraud review
        # requires additional time / verification (or a potential network issue with the
        # issuing bank).
        class AuthorizationResult

          attr_reader :status, :action, :decline_code, :avs, :cvv, :three_d_secure, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'AuthorizationResult')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::AuthorizationStatus) ? x : ::Io::Flow::V0::Models::AuthorizationStatus.apply(x))
            @action = (x = opts.delete(:action); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationResultAction) ? x : ::Io::Flow::V0::Models::AuthorizationResultAction.from_json(x)))
            @decline_code = (x = opts.delete(:decline_code); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationDeclineCode) ? x : ::Io::Flow::V0::Models::AuthorizationDeclineCode.apply(x)))
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
            @three_d_secure = (x = opts.delete(:three_d_secure); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ThreeDSecure) ? x : ::Io::Flow::V0::Models::ThreeDSecure.new(x)))
            @description = (x = opts.delete(:description); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationResultDescription) ? x : ::Io::Flow::V0::Models::AuthorizationResultDescription.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationResult.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value,
              :action => action.nil? ? nil : action.to_hash,
              :decline_code => decline_code.nil? ? nil : decline_code.value,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash,
              :three_d_secure => three_d_secure.nil? ? nil : three_d_secure.to_hash,
              :description => description.nil? ? nil : description.to_hash
            }
          end

        end

        # Provides details for how to acquire additional information from the customer
        # using GET (e.g. redirecting to the issuer for online payment method or 3D
        # Secure).
        class AuthorizationResultActionGet < AuthorizationResultAction

          attr_reader :type, :url, :details

          def initialize(incoming={})
            super(:discriminator => AuthorizationResultAction::Types::AUTHORIZATION_RESULT_ACTION_GET)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'AuthorizationResultActionGet')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::AuthorizationResultActionType) ? x : ::Io::Flow::V0::Models::AuthorizationResultActionType.apply(x))
            @url = (x = opts.delete(:url); x.nil? ? nil : HttpClient::Preconditions.assert_class('url', x, String))
            @details = (x = opts.delete(:details); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationResultActionDetails) ? x : ::Io::Flow::V0::Models::AuthorizationResultActionDetails.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationResultActionGet.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :type => type.value,
              :url => url,
              :details => details.nil? ? nil : details.to_hash
            }
          end

        end

        # Provides details for how to acquire additional information from the customer
        # natively in the browser (e.g. for 3D Secure 2).
        class AuthorizationResultActionNative < AuthorizationResultAction

          attr_reader :type, :authorization, :details

          def initialize(incoming={})
            super(:discriminator => AuthorizationResultAction::Types::AUTHORIZATION_RESULT_ACTION_NATIVE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :authorization], 'AuthorizationResultActionNative')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::AuthorizationResultActionType) ? x : ::Io::Flow::V0::Models::AuthorizationResultActionType.apply(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @details = (x = opts.delete(:details); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationResultActionDetails) ? x : ::Io::Flow::V0::Models::AuthorizationResultActionDetails.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationResultActionNative.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :type => type.value,
              :authorization => authorization.to_hash,
              :details => details.nil? ? nil : details.to_hash
            }
          end

        end

        # Provides details for how to acquire additional information from the customer
        # using POST (e.g. redirecting to the issuer for online payment method or 3D
        # Secure).
        class AuthorizationResultActionPost < AuthorizationResultAction

          attr_reader :type, :url, :parameters

          def initialize(incoming={})
            super(:discriminator => AuthorizationResultAction::Types::AUTHORIZATION_RESULT_ACTION_POST)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :url, :parameters], 'AuthorizationResultActionPost')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::AuthorizationResultActionType) ? x : ::Io::Flow::V0::Models::AuthorizationResultActionType.apply(x))
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @parameters = HttpClient::Preconditions.assert_class('parameters', HttpClient::Helper.to_object(opts.delete(:parameters)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationResultActionPost.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :type => type.value,
              :url => url,
              :parameters => parameters
            }
          end

        end

        # Indicates that a response is not ready and that the consumer should poll (or
        # wait) for a response.
        class AuthorizationResultActionWait < AuthorizationResultAction

          attr_reader :type

          def initialize(incoming={})
            super(:discriminator => AuthorizationResultAction::Types::AUTHORIZATION_RESULT_ACTION_WAIT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'AuthorizationResultActionWait')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::AuthorizationResultActionType) ? x : ::Io::Flow::V0::Models::AuthorizationResultActionType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationResultActionWait.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :type => type.value
            }
          end

        end

        class AuthorizationResultDescription

          attr_reader :display

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:display], 'AuthorizationResultDescription')
            @display = HttpClient::Preconditions.assert_class('display', opts.delete(:display), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationResultDescription.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :display => display
            }
          end

        end

        class AuthorizationStatusChanged < Event

          attr_reader :event_id, :timestamp, :organization, :id, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::AUTHORIZATION_STATUS_CHANGED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :authorization], 'AuthorizationStatusChanged')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::Authorization) ? x : ::Io::Flow::V0::Models::Authorization.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationStatusChanged.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :authorization => authorization.to_hash
            }
          end

        end

        class AuthorizationVersion

          attr_reader :id, :timestamp, :type, :authorization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :authorization], 'AuthorizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::Authorization) ? x : ::Io::Flow::V0::Models::Authorization.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :authorization => authorization.to_hash
            }
          end

        end

        class AvailableFilterStructured < AvailableFilter

          attr_reader :field, :operators, :format, :valid_values, :placeholder

          def initialize(incoming={})
            super(:discriminator => AvailableFilter::Types::AVAILABLE_FILTER_STRUCTURED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:field, :operators, :format], 'AvailableFilterStructured')
            @field = HttpClient::Preconditions.assert_class('field', opts.delete(:field), String)
            @operators = HttpClient::Preconditions.assert_class('operators', opts.delete(:operators), Array).map { |v| HttpClient::Preconditions.assert_class('operators', v, String) }
            @format = (x = opts.delete(:format); x.is_a?(::Io::Flow::V0::Models::AvailableFilterFormat) ? x : ::Io::Flow::V0::Models::AvailableFilterFormat.apply(x))
            @valid_values = (x = opts.delete(:valid_values); x.nil? ? nil : HttpClient::Preconditions.assert_class('valid_values', x, Array).map { |v| HttpClient::Preconditions.assert_class('valid_values', v, String) })
            @placeholder = (x = opts.delete(:placeholder); x.nil? ? nil : HttpClient::Preconditions.assert_class('placeholder', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailableFilterStructured.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :field => field,
              :operators => operators,
              :format => format.value,
              :valid_values => valid_values.nil? ? nil : valid_values,
              :placeholder => placeholder
            }
          end

        end

        class AvailableFilterUnstructured < AvailableFilter

          attr_reader :placeholder

          def initialize(incoming={})
            super(:discriminator => AvailableFilter::Types::AVAILABLE_FILTER_UNSTRUCTURED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @placeholder = (x = opts.delete(:placeholder); x.nil? ? nil : HttpClient::Preconditions.assert_class('placeholder', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailableFilterUnstructured.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :placeholder => placeholder
            }
          end

        end

        class AvailablePromotion

          attr_reader :id, :shipping_configuration, :region, :promotions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :shipping_configuration, :region, :promotions], 'AvailablePromotion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationReference) ? x : ::Io::Flow::V0::Models::ShippingConfigurationReference.new(x))
            @region = (x = opts.delete(:region); x.is_a?(::Io::Flow::V0::Models::RegionReference) ? x : ::Io::Flow::V0::Models::RegionReference.new(x))
            @promotions = HttpClient::Preconditions.assert_class('promotions', opts.delete(:promotions), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Promotion) ? x : ::Io::Flow::V0::Models::Promotion.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailablePromotion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :shipping_configuration => shipping_configuration.to_hash,
              :region => region.to_hash,
              :promotions => promotions.map { |o| o.to_hash }
            }
          end

        end

        class AvailablePromotionsDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::AVAILABLE_PROMOTIONS_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key], 'AvailablePromotionsDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailablePromotionsDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key
            }
          end

        end

        class AvailablePromotionsDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :available_promotion

          def initialize(incoming={})
            super(:discriminator => Event::Types::AVAILABLE_PROMOTIONS_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :available_promotion], 'AvailablePromotionsDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @available_promotion = (x = opts.delete(:available_promotion); x.is_a?(::Io::Flow::V0::Models::AvailablePromotion) ? x : ::Io::Flow::V0::Models::AvailablePromotion.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailablePromotionsDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :available_promotion => available_promotion.to_hash
            }
          end

        end

        class AvailablePromotionsUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key, :available_promotions

          def initialize(incoming={})
            super(:discriminator => Event::Types::AVAILABLE_PROMOTIONS_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key, :available_promotions], 'AvailablePromotionsUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @available_promotions = HttpClient::Preconditions.assert_class('available_promotions', opts.delete(:available_promotions), Array).map { |v| HttpClient::Preconditions.assert_class('available_promotions', HttpClient::Helper.to_object(v), Hash) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailablePromotionsUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key,
              :available_promotions => available_promotions
            }
          end

        end

        class AvailablePromotionsUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :available_promotion

          def initialize(incoming={})
            super(:discriminator => Event::Types::AVAILABLE_PROMOTIONS_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :available_promotion], 'AvailablePromotionsUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @available_promotion = (x = opts.delete(:available_promotion); x.is_a?(::Io::Flow::V0::Models::AvailablePromotion) ? x : ::Io::Flow::V0::Models::AvailablePromotion.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailablePromotionsUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :available_promotion => available_promotion.to_hash
            }
          end

        end

        # Representation of a service level available at a center and the special pickup
        # times during the week. If pickup schedules are not provided, assumption is
        # once a day during the weekdays.
        class AvailableService

          attr_reader :service, :scheduled_pickups, :lead_days

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service], 'AvailableService')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @scheduled_pickups = (x = opts.delete(:scheduled_pickups); x.nil? ? nil : HttpClient::Preconditions.assert_class('scheduled_pickups', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ScheduledPickup) ? x : ::Io::Flow::V0::Models::ScheduledPickup.new(x)) })
            @lead_days = (x = opts.delete(:lead_days); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NumberRange) ? x : ::Io::Flow::V0::Models::NumberRange.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailableService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :scheduled_pickups => scheduled_pickups.nil? ? nil : scheduled_pickups.map { |o| o.to_hash },
              :lead_days => lead_days.nil? ? nil : lead_days.to_hash
            }
          end

        end

        class AvalaraTaxCsvSetting < TaxSetting

          attr_reader :schedule, :timezone, :email_recipients

          def initialize(incoming={})
            super(:discriminator => TaxSetting::Types::AVALARA_TAX_CSV_SETTING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:schedule, :timezone], 'AvalaraTaxCsvSetting')
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::RepeatSchedule) ? x : ::Io::Flow::V0::Models::RepeatSchedule.from_json(x))
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
            @email_recipients = (x = opts.delete(:email_recipients); x.nil? ? nil : HttpClient::Preconditions.assert_class('email_recipients', x, Array).map { |v| HttpClient::Preconditions.assert_class('email_recipients', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvalaraTaxCsvSetting.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :schedule => schedule.to_hash,
              :timezone => timezone,
              :email_recipients => email_recipients.nil? ? nil : email_recipients
            }
          end

        end

        class AvalaraTaxSetting < TaxSetting

          attr_reader :company_code, :base_currency, :api_key

          def initialize(incoming={})
            super(:discriminator => TaxSetting::Types::AVALARA_TAX_SETTING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:company_code, :base_currency], 'AvalaraTaxSetting')
            @company_code = HttpClient::Preconditions.assert_class('company_code', opts.delete(:company_code), String)
            @base_currency = HttpClient::Preconditions.assert_class('base_currency', opts.delete(:base_currency), String)
            @api_key = (x = opts.delete(:api_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('api_key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvalaraTaxSetting.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :company_code => company_code,
              :base_currency => base_currency,
              :api_key => api_key
            }
          end

        end

        # Represents the address verification results
        class Avs

          attr_reader :code, :name, :address, :postal, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'Avs')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::AvsCode) ? x : ::Io::Flow::V0::Models::AvsCode.apply(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('name', x))
            @address = (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('address', x))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('postal', x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Avs.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :name => name,
              :address => address,
              :postal => postal,
              :description => description
            }
          end

        end

        # The b2b credit memo represents a refund transaction between Flow and one of
        # our clients
        class B2bCreditMemo

          attr_reader :id, :number, :buyer, :seller, :status, :date, :key, :invoice, :lines, :documents, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :buyer, :seller, :status, :date, :key, :invoice, :lines, :documents, :attributes], 'B2bCreditMemo')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @buyer = (x = opts.delete(:buyer); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x))
            @seller = (x = opts.delete(:seller); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceStatus) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceStatus.apply(x))
            @date = HttpClient::Preconditions.assert_class('date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:date)), DateTime)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @invoice = (x = opts.delete(:invoice); x.is_a?(::Io::Flow::V0::Models::B2bInvoiceReference) ? x : ::Io::Flow::V0::Models::B2bInvoiceReference.new(x))
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLine) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLine.from_json(x)) }
            @documents = HttpClient::Preconditions.assert_class('documents', opts.delete(:documents), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceDocument) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceDocument.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            B2bCreditMemo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :buyer => buyer.to_hash,
              :seller => seller.to_hash,
              :status => status.value,
              :date => date,
              :key => key,
              :invoice => invoice.to_hash,
              :lines => lines.map { |o| o.to_hash },
              :documents => documents.map { |o| o.to_hash },
              :attributes => attributes
            }
          end

        end

        class B2bCreditMemoDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :b2b_credit_memo

          def initialize(incoming={})
            super(:discriminator => Event::Types::B2B_CREDIT_MEMO_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :b2b_credit_memo], 'B2bCreditMemoDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @b2b_credit_memo = (x = opts.delete(:b2b_credit_memo); x.is_a?(::Io::Flow::V0::Models::B2bCreditMemo) ? x : ::Io::Flow::V0::Models::B2bCreditMemo.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            B2bCreditMemoDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :b2b_credit_memo => b2b_credit_memo.to_hash
            }
          end

        end

        class B2bCreditMemoUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :b2b_credit_memo

          def initialize(incoming={})
            super(:discriminator => Event::Types::B2B_CREDIT_MEMO_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :b2b_credit_memo], 'B2bCreditMemoUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @b2b_credit_memo = (x = opts.delete(:b2b_credit_memo); x.is_a?(::Io::Flow::V0::Models::B2bCreditMemo) ? x : ::Io::Flow::V0::Models::B2bCreditMemo.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            B2bCreditMemoUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :b2b_credit_memo => b2b_credit_memo.to_hash
            }
          end

        end

        # The b2b invoice represents a transaction between Flow and one of our clients
        # (e.g. Flow purchasing inventory to resell to a consumer).
        class B2bInvoice

          attr_reader :id, :number, :buyer, :seller, :status, :date, :key, :order, :economic_title_location, :center, :destination, :tax, :lines, :documents, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :buyer, :seller, :status, :date, :key, :order, :economic_title_location, :tax, :lines, :documents, :attributes], 'B2bInvoice')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @buyer = (x = opts.delete(:buyer); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x))
            @seller = (x = opts.delete(:seller); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceStatus) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceStatus.apply(x))
            @date = HttpClient::Preconditions.assert_class('date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:date)), DateTime)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceOrderSummary) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceOrderSummary.new(x))
            @economic_title_location = (x = opts.delete(:economic_title_location); x.is_a?(::Io::Flow::V0::Models::EconomicTitleLocation) ? x : ::Io::Flow::V0::Models::EconomicTitleLocation.apply(x))
            @center = (x = opts.delete(:center); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceCenterReference) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceCenterReference.new(x)))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x)))
            @tax = (x = opts.delete(:tax); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLine) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLine.from_json(x)) }
            @documents = HttpClient::Preconditions.assert_class('documents', opts.delete(:documents), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceDocument) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceDocument.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            B2bInvoice.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :buyer => buyer.to_hash,
              :seller => seller.to_hash,
              :status => status.value,
              :date => date,
              :key => key,
              :order => order.to_hash,
              :economic_title_location => economic_title_location.value,
              :center => center.nil? ? nil : center.to_hash,
              :destination => destination.nil? ? nil : destination.to_hash,
              :tax => tax.to_hash,
              :lines => lines.map { |o| o.to_hash },
              :documents => documents.map { |o| o.to_hash },
              :attributes => attributes
            }
          end

        end

        class B2bInvoiceDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :b2b_invoice

          def initialize(incoming={})
            super(:discriminator => Event::Types::B2B_INVOICE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :b2b_invoice], 'B2bInvoiceDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @b2b_invoice = (x = opts.delete(:b2b_invoice); x.is_a?(::Io::Flow::V0::Models::B2bInvoice) ? x : ::Io::Flow::V0::Models::B2bInvoice.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            B2bInvoiceDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :b2b_invoice => b2b_invoice.to_hash
            }
          end

        end

        class B2bInvoiceReference

          attr_reader :id, :key, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :number], 'B2bInvoiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            B2bInvoiceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :number => number
            }
          end

        end

        class B2bInvoiceUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :b2b_invoice

          def initialize(incoming={})
            super(:discriminator => Event::Types::B2B_INVOICE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :b2b_invoice], 'B2bInvoiceUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @b2b_invoice = (x = opts.delete(:b2b_invoice); x.is_a?(::Io::Flow::V0::Models::B2bInvoice) ? x : ::Io::Flow::V0::Models::B2bInvoice.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            B2bInvoiceUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :b2b_invoice => b2b_invoice.to_hash
            }
          end

        end

        class BehaviorAudit

          attr_reader :behavior, :authentication_techniques, :roles

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:behavior, :authentication_techniques, :roles], 'BehaviorAudit')
            @behavior = (x = opts.delete(:behavior); x.is_a?(::Io::Flow::V0::Models::FlowBehavior) ? x : ::Io::Flow::V0::Models::FlowBehavior.apply(x))
            @authentication_techniques = HttpClient::Preconditions.assert_class('authentication_techniques', opts.delete(:authentication_techniques), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AuthenticationTechnique) ? x : ::Io::Flow::V0::Models::AuthenticationTechnique.apply(x)) }
            @roles = HttpClient::Preconditions.assert_class('roles', opts.delete(:roles), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BehaviorAudit.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :behavior => behavior.value,
              :authentication_techniques => authentication_techniques.map { |o| o.value },
              :roles => roles.map { |o| o.to_hash }
            }
          end

        end

        class BillingAddress

          attr_reader :name, :streets, :city, :province, :postal, :country, :company

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @company = (x = opts.delete(:company); x.nil? ? nil : HttpClient::Preconditions.assert_class('company', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BillingAddress.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.nil? ? nil : name.to_hash,
              :streets => streets.nil? ? nil : streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :company => company
            }
          end

        end

        class BrowseOptinResponses

          attr_reader :id, :session_id, :optin_responses

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :session_id, :optin_responses], 'BrowseOptinResponses')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @session_id = HttpClient::Preconditions.assert_class('session_id', opts.delete(:session_id), String)
            @optin_responses = HttpClient::Preconditions.assert_class('optin_responses', opts.delete(:optin_responses), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OptinResponse) ? x : ::Io::Flow::V0::Models::OptinResponse.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BrowseOptinResponses.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :session_id => session_id,
              :optin_responses => optin_responses.map { |o| o.to_hash }
            }
          end

        end

        class BrowseOptinResponsesDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::BROWSE_OPTIN_RESPONSES_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'BrowseOptinResponsesDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BrowseOptinResponsesDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class BrowseOptinResponsesUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :browse_optin_responses

          def initialize(incoming={})
            super(:discriminator => Event::Types::BROWSE_OPTIN_RESPONSES_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :browse_optin_responses], 'BrowseOptinResponsesUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @browse_optin_responses = (x = opts.delete(:browse_optin_responses); x.is_a?(::Io::Flow::V0::Models::BrowseOptinResponses) ? x : ::Io::Flow::V0::Models::BrowseOptinResponses.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BrowseOptinResponsesUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :browse_optin_responses => browse_optin_responses.to_hash
            }
          end

        end

        # Shopper browser info. All of these fields are required if you are using 3DS2.
        class BrowserInfo

          attr_reader :origin, :language, :java_enabled, :color_depth, :screen_height, :screen_width, :time_zone_offset, :user_agent, :accept

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @java_enabled = (x = opts.delete(:java_enabled); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('java_enabled', x))
            @color_depth = (x = opts.delete(:color_depth); x.nil? ? nil : HttpClient::Preconditions.assert_class('color_depth', x, Integer))
            @screen_height = (x = opts.delete(:screen_height); x.nil? ? nil : HttpClient::Preconditions.assert_class('screen_height', x, Integer))
            @screen_width = (x = opts.delete(:screen_width); x.nil? ? nil : HttpClient::Preconditions.assert_class('screen_width', x, Integer))
            @time_zone_offset = (x = opts.delete(:time_zone_offset); x.nil? ? nil : HttpClient::Preconditions.assert_class('time_zone_offset', x, Integer))
            @user_agent = (x = opts.delete(:user_agent); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_agent', x, String))
            @accept = (x = opts.delete(:accept); x.nil? ? nil : HttpClient::Preconditions.assert_class('accept', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BrowserInfo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin => origin,
              :language => language,
              :java_enabled => java_enabled,
              :color_depth => color_depth,
              :screen_height => screen_height,
              :screen_width => screen_width,
              :time_zone_offset => time_zone_offset,
              :user_agent => user_agent,
              :accept => accept
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class Capture

          attr_reader :id, :key, :authorization, :amount, :currency, :requested, :created_at, :attributes, :status, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :authorization, :amount, :currency, :created_at], 'Capture')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @requested = (x = opts.delete(:requested); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @status = (x = (x = opts.delete(:status); x.nil? ? "succeeded" : x); x.is_a?(::Io::Flow::V0::Models::CaptureStatus) ? x : ::Io::Flow::V0::Models::CaptureStatus.apply(x))
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Capture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :authorization => authorization.to_hash,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :requested => requested.nil? ? nil : requested.to_hash,
              :created_at => created_at,
              :attributes => attributes.nil? ? nil : attributes,
              :status => status.value,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        class CaptureDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :capture

          def initialize(incoming={})
            super(:discriminator => Event::Types::CAPTURE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :capture], 'CaptureDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :capture => capture.to_hash
            }
          end

        end

        class CaptureError

          attr_reader :code, :messages, :decline_code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages, :decline_code], 'CaptureError')
            @code = (x = (x = opts.delete(:code); x.nil? ? "generic_error" : x); x.is_a?(::Io::Flow::V0::Models::GenericErrorCode) ? x : ::Io::Flow::V0::Models::GenericErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @decline_code = (x = opts.delete(:decline_code); x.is_a?(::Io::Flow::V0::Models::CaptureDeclineCode) ? x : ::Io::Flow::V0::Models::CaptureDeclineCode.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :decline_code => decline_code.value
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class CaptureForm

          attr_reader :authorization_id, :key, :amount, :currency, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authorization_id], 'CaptureForm')
            @authorization_id = HttpClient::Preconditions.assert_class('authorization_id', opts.delete(:authorization_id), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :authorization_id => authorization_id,
              :key => key,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class CaptureIdentifier

          attr_reader :id, :capture, :identifier, :primary

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :capture, :identifier, :primary], 'CaptureIdentifier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::CaptureReference) ? x : ::Io::Flow::V0::Models::CaptureReference.new(x))
            @identifier = HttpClient::Preconditions.assert_class('identifier', opts.delete(:identifier), String)
            @primary = HttpClient::Preconditions.assert_boolean('primary', opts.delete(:primary))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureIdentifier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :capture => capture.to_hash,
              :identifier => identifier,
              :primary => primary
            }
          end

        end

        class CaptureIdentifierDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :identifier

          def initialize(incoming={})
            super(:discriminator => Event::Types::CAPTURE_IDENTIFIER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :identifier], 'CaptureIdentifierDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @identifier = (x = opts.delete(:identifier); x.is_a?(::Io::Flow::V0::Models::CaptureIdentifier) ? x : ::Io::Flow::V0::Models::CaptureIdentifier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureIdentifierDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :identifier => identifier.to_hash
            }
          end

        end

        class CaptureIdentifierUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :identifier

          def initialize(incoming={})
            super(:discriminator => Event::Types::CAPTURE_IDENTIFIER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :identifier], 'CaptureIdentifierUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @identifier = (x = opts.delete(:identifier); x.is_a?(::Io::Flow::V0::Models::CaptureIdentifier) ? x : ::Io::Flow::V0::Models::CaptureIdentifier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureIdentifierUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :identifier => identifier.to_hash
            }
          end

        end

        class CaptureReference

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'CaptureReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        class CaptureUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :capture

          def initialize(incoming={})
            super(:discriminator => Event::Types::CAPTURE_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :capture], 'CaptureUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :capture => capture.to_hash
            }
          end

        end

        class CaptureVersion

          attr_reader :id, :timestamp, :type, :capture

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :capture], 'CaptureVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :capture => capture.to_hash
            }
          end

        end

        # Card represents the metadata about a secure, tokenized card. The card 'token'
        # is a unique, cryptographically secure token by which this card can be
        # identified in the future. The card token itself will either be a permanent
        # card token (denoted by a prefix of F96) or a one time nonce (denoted by a
        # prefix of F17). Nonces represent cards that were encrypted from public
        # channels (like the user's browser via JavaScript) and can be used once only.
        # If you have a nonce you can exchange it for a permanent card token via the
        # operation POST /:organization/cards/nonces
        class Card < ExpandableCard

          attr_reader :id, :token, :type, :expiration, :iin, :issuer, :last4, :name, :address

          def initialize(incoming={})
            super(:discriminator => ExpandableCard::Types::CARD)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :token, :type, :expiration, :iin, :last4, :name], 'Card')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CardType) ? x : ::Io::Flow::V0::Models::CardType.apply(x))
            @expiration = (x = opts.delete(:expiration); x.is_a?(::Io::Flow::V0::Models::Expiration) ? x : ::Io::Flow::V0::Models::Expiration.new(x))
            @iin = HttpClient::Preconditions.assert_class('iin', opts.delete(:iin), String)
            @issuer = (x = opts.delete(:issuer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::IssuerSummary) ? x : ::Io::Flow::V0::Models::IssuerSummary.new(x)))
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Card.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :token => token,
              :type => type.value,
              :expiration => expiration.to_hash,
              :iin => iin,
              :issuer => issuer.nil? ? nil : issuer.to_hash,
              :last4 => last4,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class CardAuthorization < Authorization

          attr_reader :id, :key, :merchant_of_record, :method, :card, :amount, :currency, :requested, :customer, :attributes, :destination, :billing_address, :order, :ip, :result, :created_at, :expires_at, :base

          def initialize(incoming={})
            super(:discriminator => Authorization::Types::CARD_AUTHORIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :card, :amount, :currency, :customer, :attributes, :result, :created_at], 'CardAuthorization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @merchant_of_record = (x = (x = opts.delete(:merchant_of_record); x.nil? ? "flow" : x); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecord) ? x : ::Io::Flow::V0::Models::MerchantOfRecord.apply(x))
            @method = (x = opts.delete(:method); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PaymentMethod) ? x : ::Io::Flow::V0::Models::PaymentMethod.new(x)))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::ExpandableCard) ? x : ::Io::Flow::V0::Models::ExpandableCard.from_json(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @requested = (x = opts.delete(:requested); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::OrderCustomer) ? x : ::Io::Flow::V0::Models::OrderCustomer.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @billing_address = (x = opts.delete(:billing_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationOrderReference) ? x : ::Io::Flow::V0::Models::AuthorizationOrderReference.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @result = (x = opts.delete(:result); x.is_a?(::Io::Flow::V0::Models::AuthorizationResult) ? x : ::Io::Flow::V0::Models::AuthorizationResult.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @expires_at = (x = opts.delete(:expires_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardAuthorization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :merchant_of_record => merchant_of_record.value,
              :method => method.nil? ? nil : method.to_hash,
              :card => card.to_hash,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :requested => requested.nil? ? nil : requested.to_hash,
              :customer => customer.to_hash,
              :attributes => attributes,
              :destination => destination.nil? ? nil : destination.to_hash,
              :billing_address => billing_address.nil? ? nil : billing_address.to_hash,
              :order => order.nil? ? nil : order.to_hash,
              :ip => ip,
              :result => result.to_hash,
              :created_at => created_at,
              :expires_at => expires_at,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        class CardAuthorizationDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_AUTHORIZATION_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :authorization], 'CardAuthorizationDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::CardAuthorization) ? x : ::Io::Flow::V0::Models::CardAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardAuthorizationDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :authorization => authorization.to_hash
            }
          end

        end

        # Represents an authorization for a card payment method
        class CardAuthorizationUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_AUTHORIZATION_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :authorization], 'CardAuthorizationUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::CardAuthorization) ? x : ::Io::Flow::V0::Models::CardAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardAuthorizationUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :authorization => authorization.to_hash
            }
          end

        end

        class CardDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'CardDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class CardDeletedV2

          attr_reader :event_id, :timestamp, :organization, :card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :card], 'CardDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardDeletedV2.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :card => card.to_hash
            }
          end

        end

        # Details for why a card was not created
        class CardError

          attr_reader :code, :messages, :avs, :cvv

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'CardError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::CardErrorCode) ? x : ::Io::Flow::V0::Models::CardErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        class CardForm

          attr_reader :number, :cipher, :expiration_month, :expiration_year, :name, :cvv, :address, :ip, :challenge_text, :challenge_cipher, :token_type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:expiration_month, :expiration_year, :name, :cvv], 'CardForm')
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @cipher = (x = opts.delete(:cipher); x.nil? ? nil : HttpClient::Preconditions.assert_class('cipher', x, String))
            @expiration_month = HttpClient::Preconditions.assert_class('expiration_month', opts.delete(:expiration_month), Integer)
            @expiration_year = HttpClient::Preconditions.assert_class('expiration_year', opts.delete(:expiration_year), Integer)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @cvv = HttpClient::Preconditions.assert_class('cvv', opts.delete(:cvv), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @challenge_text = (x = opts.delete(:challenge_text); x.nil? ? nil : HttpClient::Preconditions.assert_class('challenge_text', x, String))
            @challenge_cipher = (x = opts.delete(:challenge_cipher); x.nil? ? nil : HttpClient::Preconditions.assert_class('challenge_cipher', x, String))
            @token_type = (x = opts.delete(:token_type); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TokenType) ? x : ::Io::Flow::V0::Models::TokenType.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :cipher => cipher,
              :expiration_month => expiration_month,
              :expiration_year => expiration_year,
              :name => name,
              :cvv => cvv,
              :address => address.nil? ? nil : address.to_hash,
              :ip => ip,
              :challenge_text => challenge_text,
              :challenge_cipher => challenge_cipher,
              :token_type => token_type.nil? ? nil : token_type.value
            }
          end

        end

        # The card nonce form presents a one time token to exchange server side for a
        # permanent, secure tokenized card
        class CardNonceForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'CardNonceForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardNonceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        # Represents a saved credit card payment method.
        class CardPaymentSource < PaymentSource

          attr_reader :id, :actions, :summary

          def initialize(incoming={})
            super(:discriminator => PaymentSource::Types::CARD_PAYMENT_SOURCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :summary], 'CardPaymentSource')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @actions = (x = opts.delete(:actions); x.nil? ? nil : HttpClient::Preconditions.assert_class('actions', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentSourceConfirmationAction) ? x : ::Io::Flow::V0::Models::PaymentSourceConfirmationAction.new(x)) })
            @summary = (x = opts.delete(:summary); x.is_a?(::Io::Flow::V0::Models::CardPaymentSourceSummary) ? x : ::Io::Flow::V0::Models::CardPaymentSourceSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardPaymentSource.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :actions => actions.nil? ? nil : actions.map { |o| o.to_hash },
              :summary => summary.to_hash
            }
          end

        end

        # Creates an authorization for a transaction from a card payment source.
        class CardPaymentSourceAuthorizationForm < AuthorizationForm

          attr_reader :key, :card_payment_source_id, :order_number, :amount, :currency, :browser_info

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::CARD_PAYMENT_SOURCE_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:card_payment_source_id, :order_number, :amount, :currency], 'CardPaymentSourceAuthorizationForm')
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @card_payment_source_id = HttpClient::Preconditions.assert_class('card_payment_source_id', opts.delete(:card_payment_source_id), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @browser_info = (x = opts.delete(:browser_info); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BrowserInfo) ? x : ::Io::Flow::V0::Models::BrowserInfo.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardPaymentSourceAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key,
              :card_payment_source_id => card_payment_source_id,
              :order_number => order_number,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :browser_info => browser_info.nil? ? nil : browser_info.to_hash
            }
          end

        end

        # Contains a summary of a card, which is useful for displaying to a customer.
        class CardPaymentSourceForm < PaymentSourceForm

          attr_reader :customer_number, :card_id

          def initialize(incoming={})
            super(:discriminator => PaymentSourceForm::Types::CARD_PAYMENT_SOURCE_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:customer_number, :card_id], 'CardPaymentSourceForm')
            @customer_number = HttpClient::Preconditions.assert_class('customer_number', opts.delete(:customer_number), String)
            @card_id = HttpClient::Preconditions.assert_class('card_id', opts.delete(:card_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardPaymentSourceForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :customer_number => customer_number,
              :card_id => card_id
            }
          end

        end

        # Contains a summary of a card, which is useful for displaying to a customer.
        class CardPaymentSourceSummary

          attr_reader :customer_number, :card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:customer_number, :card], 'CardPaymentSourceSummary')
            @customer_number = HttpClient::Preconditions.assert_class('customer_number', opts.delete(:customer_number), String)
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::CardSummary) ? x : ::Io::Flow::V0::Models::CardSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardPaymentSourceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :customer_number => customer_number,
              :card => card.to_hash
            }
          end

        end

        class CardReference < ExpandableCard

          attr_reader :id, :token

          def initialize(incoming={})
            super(:discriminator => ExpandableCard::Types::CARD_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :token], 'CardReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :token => token
            }
          end

        end

        # Card Summary is the card without the token
        class CardSummary < ExpandableCard

          attr_reader :id, :type, :expiration, :iin, :issuer, :last4, :name, :address

          def initialize(incoming={})
            super(:discriminator => ExpandableCard::Types::CARD_SUMMARY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :expiration, :iin, :last4, :name], 'CardSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CardType) ? x : ::Io::Flow::V0::Models::CardType.apply(x))
            @expiration = (x = opts.delete(:expiration); x.is_a?(::Io::Flow::V0::Models::Expiration) ? x : ::Io::Flow::V0::Models::Expiration.new(x))
            @iin = HttpClient::Preconditions.assert_class('iin', opts.delete(:iin), String)
            @issuer = (x = opts.delete(:issuer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::IssuerSummary) ? x : ::Io::Flow::V0::Models::IssuerSummary.new(x)))
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardSummary.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :type => type.value,
              :expiration => expiration.to_hash,
              :iin => iin,
              :issuer => issuer.nil? ? nil : issuer.to_hash,
              :last4 => last4,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CardTokenForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'CardTokenForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardTokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        class CardUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :card

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :card], 'CardUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :card => card.to_hash
            }
          end

        end

        class CardVersion

          attr_reader :id, :timestamp, :type, :card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :card], 'CardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :card => card.to_hash
            }
          end

        end

        # Partner that actually takes a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class Carrier

          attr_reader :id, :name, :tracking_url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :tracking_url], 'Carrier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @tracking_url = HttpClient::Preconditions.assert_class('tracking_url', opts.delete(:tracking_url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Carrier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :tracking_url => tracking_url
            }
          end

        end

        class CarrierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class CarrierService

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'CarrierService')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class CartReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CartReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CartReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class Catalog

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'Catalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Catalog.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CatalogDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog], 'CatalogDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog
            }
          end

        end

        class CatalogItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog], 'CatalogItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog
            }
          end

        end

        class CatalogItemDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :item

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_ITEM_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :item], 'CatalogItemDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :item => item.to_hash
            }
          end

        end

        class CatalogItemDocument < Document

          attr_reader :number, :name, :categories, :experiences, :attributes, :images

          def initialize(incoming={})
            super(:discriminator => Document::Types::CATALOG_ITEM_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :categories, :experiences, :attributes, :images], 'CatalogItemDocument')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @experiences = HttpClient::Preconditions.assert_class('experiences', opts.delete(:experiences), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @images = (x = opts.delete(:images); x.is_a?(::Io::Flow::V0::Models::CatalogItemDocumentImages) ? x : ::Io::Flow::V0::Models::CatalogItemDocumentImages.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :number => number,
              :name => name,
              :categories => categories,
              :experiences => experiences.map { |o| o.to_hash },
              :attributes => attributes,
              :images => images.to_hash
            }
          end

        end

        class CatalogItemDocumentImages

          attr_reader :thumbnail

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @thumbnail = (x = opts.delete(:thumbnail); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDocumentImages.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :thumbnail => thumbnail.nil? ? nil : thumbnail.to_hash
            }
          end

        end

        # Defines the filters that can be applied when requesting a catalog item data
        # export
        class CatalogItemExportType < ExportType

          attr_reader :numbers, :q, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::CATALOG_ITEM_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :q => q,
              :sort => sort
            }
          end

        end

        class CatalogItemReference

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'CatalogItemReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class CatalogItemSummary

          attr_reader :number, :name, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :attributes], 'CatalogItemSummary')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :name => name,
              :attributes => attributes
            }
          end

        end

        class CatalogItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog, :locale, :name, :currency, :price, :categories, :attributes, :dimensions, :images], 'CatalogItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @dimensions = HttpClient::Preconditions.assert_class('dimensions', HttpClient::Helper.to_object(opts.delete(:dimensions)), Hash)
            @images = HttpClient::Preconditions.assert_class('images', opts.delete(:images), Array).map { |v| HttpClient::Preconditions.assert_class('images', HttpClient::Helper.to_object(v), Hash) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories,
              :description => description,
              :attributes => attributes,
              :dimensions => dimensions,
              :images => images
            }
          end

        end

        class CatalogItemUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :item

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_ITEM_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :item], 'CatalogItemUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :item => item.to_hash
            }
          end

        end

        # Represents the returned information for searching particular price book items
        class CatalogPriceBookItemDocument

          attr_reader :price_book_key, :price_book_item_key, :catalog, :amount, :starts_at, :ends_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price_book_key, :price_book_item_key, :catalog, :amount, :starts_at], 'CatalogPriceBookItemDocument')
            @price_book_key = HttpClient::Preconditions.assert_class('price_book_key', opts.delete(:price_book_key), String)
            @price_book_item_key = HttpClient::Preconditions.assert_class('price_book_item_key', opts.delete(:price_book_item_key), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogItemSummary) ? x : ::Io::Flow::V0::Models::CatalogItemSummary.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @starts_at = HttpClient::Preconditions.assert_class('starts_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:starts_at)), DateTime)
            @ends_at = (x = opts.delete(:ends_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('ends_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogPriceBookItemDocument.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price_book_key => price_book_key,
              :price_book_item_key => price_book_item_key,
              :catalog => catalog.to_hash,
              :amount => amount.to_f.to_s,
              :starts_at => starts_at,
              :ends_at => ends_at
            }
          end

        end

        class CatalogReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CatalogReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Statistics covering product catalog item information, including total catalog
        # item count, number of distinct categories, etc.
        class CatalogStatistics

          attr_reader :items, :categories

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :categories], 'CatalogStatistics')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Integer)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items,
              :categories => categories
            }
          end

        end

        class CatalogUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog], 'CatalogUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog
            }
          end

        end

        class CatalogVersion

          attr_reader :id, :timestamp, :type, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :catalog], 'CatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :catalog => catalog.to_hash
            }
          end

        end

        class CategorySummary

          attr_reader :name, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:count], 'CategorySummary')
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CategorySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :count => count
            }
          end

        end

        # Represents a facility capable of fulfilling a shipment
        class Center < ExpandableCenter

          attr_reader :id, :key, :address, :packaging, :name, :services, :schedule, :timezone, :capabilities, :partner_center

          def initialize(incoming={})
            super(:discriminator => ExpandableCenter::Types::CENTER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :address, :packaging, :name, :services, :schedule, :timezone], 'Center')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
            @capabilities = (x = opts.delete(:capabilities); x.nil? ? nil : HttpClient::Preconditions.assert_class('capabilities', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CenterCapability) ? x : ::Io::Flow::V0::Models::CenterCapability.apply(x)) })
            @partner_center = (x = opts.delete(:partner_center); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PartnerCenter) ? x : ::Io::Flow::V0::Models::PartnerCenter.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Center.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone,
              :capabilities => capabilities.nil? ? nil : capabilities.map { |o| o.value },
              :partner_center => partner_center.nil? ? nil : partner_center.to_hash
            }
          end

        end

        class CenterDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :center

          def initialize(incoming={})
            super(:discriminator => Event::Types::CENTER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :center], 'CenterDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::Center) ? x : ::Io::Flow::V0::Models::Center.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :center => center.to_hash
            }
          end

        end

        class CenterForm

          attr_reader :address, :packaging, :name, :services, :schedule, :timezone, :key, :capabilities, :partner_center_form

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :packaging, :name, :services, :schedule], 'CenterForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = (x = opts.delete(:timezone); x.nil? ? nil : HttpClient::Preconditions.assert_class('timezone', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @capabilities = (x = opts.delete(:capabilities); x.nil? ? nil : HttpClient::Preconditions.assert_class('capabilities', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CenterCapability) ? x : ::Io::Flow::V0::Models::CenterCapability.apply(x)) })
            @partner_center_form = (x = opts.delete(:partner_center_form); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PartnerCenterForm) ? x : ::Io::Flow::V0::Models::PartnerCenterForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone,
              :key => key,
              :capabilities => capabilities.nil? ? nil : capabilities.map { |o| o.value },
              :partner_center_form => partner_center_form.nil? ? nil : partner_center_form.to_hash
            }
          end

        end

        class CenterQuery

          attr_reader :q

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q], 'CenterQuery')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterQuery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q
            }
          end

        end

        class CenterReference < ExpandableCenter

          attr_reader :organization_id, :center_key

          def initialize(incoming={})
            super(:discriminator => ExpandableCenter::Types::CENTER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization_id, :center_key], 'CenterReference')
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @center_key = HttpClient::Preconditions.assert_class('center_key', opts.delete(:center_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :organization_id => organization_id,
              :center_key => center_key
            }
          end

        end

        class CenterSummary

          attr_reader :id, :key, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'CenterSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CenterUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :center

          def initialize(incoming={})
            super(:discriminator => Event::Types::CENTER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :center], 'CenterUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::Center) ? x : ::Io::Flow::V0::Models::Center.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :center => center.to_hash
            }
          end

        end

        class CenterVersion

          attr_reader :id, :timestamp, :type, :center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :center], 'CenterVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::Center) ? x : ::Io::Flow::V0::Models::Center.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :center => center.to_hash
            }
          end

        end

        # A Checkout Attribute defines an attribute that will be made available via the
        # checkout item content. This is useful if you would like to surface a specific
        # attribute (like 'size' or 'color') in checkout.
        class CheckoutAttribute

          attr_reader :id, :experience, :key, :name, :attribute_keys, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :key, :name, :attribute_keys, :position], 'CheckoutAttribute')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @attribute_keys = HttpClient::Preconditions.assert_class('attribute_keys', opts.delete(:attribute_keys), Array).map { |v| HttpClient::Preconditions.assert_class('attribute_keys', v, String) }
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutAttribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :key => key,
              :name => name,
              :attribute_keys => attribute_keys,
              :position => position
            }
          end

        end

        class CheckoutAttributeForm

          attr_reader :key, :name, :experience_key, :attribute_keys, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :experience_key, :attribute_keys], 'CheckoutAttributeForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @attribute_keys = HttpClient::Preconditions.assert_class('attribute_keys', opts.delete(:attribute_keys), Array).map { |v| HttpClient::Preconditions.assert_class('attribute_keys', v, String) }
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutAttributeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name,
              :experience_key => experience_key,
              :attribute_keys => attribute_keys,
              :position => position
            }
          end

        end

        # A Checkout Item Content provides information about an item to support
        # rendering of that item in the context of checkout
        class CheckoutItemContent

          attr_reader :item, :name, :description, :attributes, :image

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :name, :attributes], 'CheckoutItemContent')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CheckoutItemContentAttribute) ? x : ::Io::Flow::V0::Models::CheckoutItemContentAttribute.new(x)) }
            @image = (x = opts.delete(:image); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutItemContent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :name => name,
              :description => description,
              :attributes => attributes.map { |o| o.to_hash },
              :image => image.nil? ? nil : image.to_hash
            }
          end

        end

        class CheckoutItemContentAttribute

          attr_reader :key, :name, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name, :value], 'CheckoutItemContentAttribute')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutItemContentAttribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name,
              :value => value
            }
          end

        end

        class CheckoutOptinResponses

          attr_reader :id, :order_number, :session_id, :optin_responses

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order_number, :session_id, :optin_responses], 'CheckoutOptinResponses')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @session_id = HttpClient::Preconditions.assert_class('session_id', opts.delete(:session_id), String)
            @optin_responses = HttpClient::Preconditions.assert_class('optin_responses', opts.delete(:optin_responses), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OptinResponse) ? x : ::Io::Flow::V0::Models::OptinResponse.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutOptinResponses.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :order_number => order_number,
              :session_id => session_id,
              :optin_responses => optin_responses.map { |o| o.to_hash }
            }
          end

        end

        class CheckoutOptinResponsesDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::CHECKOUT_OPTIN_RESPONSES_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'CheckoutOptinResponsesDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutOptinResponsesDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class CheckoutOptinResponsesUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :checkout_optin_responses

          def initialize(incoming={})
            super(:discriminator => Event::Types::CHECKOUT_OPTIN_RESPONSES_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :checkout_optin_responses], 'CheckoutOptinResponsesUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @checkout_optin_responses = (x = opts.delete(:checkout_optin_responses); x.is_a?(::Io::Flow::V0::Models::CheckoutOptinResponses) ? x : ::Io::Flow::V0::Models::CheckoutOptinResponses.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutOptinResponsesUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :checkout_optin_responses => checkout_optin_responses.to_hash
            }
          end

        end

        class CheckoutReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CheckoutReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CheckoutSettings

          attr_reader :configuration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:configuration], 'CheckoutSettings')
            @configuration = (x = opts.delete(:configuration); x.is_a?(::Io::Flow::V0::Models::ExperienceConfigurationReference) ? x : ::Io::Flow::V0::Models::ExperienceConfigurationReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :configuration => configuration.to_hash
            }
          end

        end

        # Represents a secure token that can be used to redirect to Checkout UI
        class CheckoutToken

          attr_reader :id, :organization, :checkout, :order, :urls, :expires_at, :session, :customer

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :checkout, :order, :urls, :expires_at, :session], 'CheckoutToken')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @checkout = (x = opts.delete(:checkout); x.is_a?(::Io::Flow::V0::Models::CheckoutReference) ? x : ::Io::Flow::V0::Models::CheckoutReference.new(x))
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderNumberReference) ? x : ::Io::Flow::V0::Models::OrderNumberReference.new(x))
            @urls = (x = opts.delete(:urls); x.is_a?(::Io::Flow::V0::Models::CheckoutUrls) ? x : ::Io::Flow::V0::Models::CheckoutUrls.new(x))
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            @session = (x = opts.delete(:session); x.is_a?(::Io::Flow::V0::Models::SessionReference) ? x : ::Io::Flow::V0::Models::SessionReference.new(x))
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CustomerReference) ? x : ::Io::Flow::V0::Models::CustomerReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutToken.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :checkout => checkout.to_hash,
              :order => order.to_hash,
              :urls => urls.to_hash,
              :expires_at => expires_at,
              :session => session.to_hash,
              :customer => customer.nil? ? nil : customer.to_hash
            }
          end

        end

        # Use this form to securly pass order and optional customer information to be
        # created or updated.
        class CheckoutTokenOrderForm < CheckoutTokenForm

          attr_reader :order_form, :customer, :address_book, :payment_sources, :session_id, :urls, :identifiers

          def initialize(incoming={})
            super(:discriminator => CheckoutTokenForm::Types::CHECKOUT_TOKEN_ORDER_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order_form, :session_id], 'CheckoutTokenOrderForm')
            @order_form = (x = opts.delete(:order_form); x.is_a?(::Io::Flow::V0::Models::OrderForm) ? x : ::Io::Flow::V0::Models::OrderForm.new(x))
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CustomerForm) ? x : ::Io::Flow::V0::Models::CustomerForm.new(x)))
            @address_book = (x = opts.delete(:address_book); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CustomerAddressBookForm) ? x : ::Io::Flow::V0::Models::CustomerAddressBookForm.new(x)))
            @payment_sources = (x = opts.delete(:payment_sources); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment_sources', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentSourceForm) ? x : ::Io::Flow::V0::Models::PaymentSourceForm.from_json(x)) })
            @session_id = HttpClient::Preconditions.assert_class('session_id', opts.delete(:session_id), String)
            @urls = (x = opts.delete(:urls); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CheckoutUrlsForm) ? x : ::Io::Flow::V0::Models::CheckoutUrlsForm.new(x)))
            @identifiers = (x = opts.delete(:identifiers); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifiers', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderSubmissionIdentifierForm) ? x : ::Io::Flow::V0::Models::OrderSubmissionIdentifierForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutTokenOrderForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :order_form => order_form.to_hash,
              :customer => customer.nil? ? nil : customer.to_hash,
              :address_book => address_book.nil? ? nil : address_book.to_hash,
              :payment_sources => payment_sources.nil? ? nil : payment_sources.map { |o| o.to_hash },
              :session_id => session_id,
              :urls => urls.nil? ? nil : urls.to_hash,
              :identifiers => identifiers.nil? ? nil : identifiers.map { |o| o.to_hash }
            }
          end

        end

        # Use this form when order number and session id are known. Optional customer
        # information will be created or updated.
        class CheckoutTokenReferenceForm < CheckoutTokenForm

          attr_reader :order_number, :session_id, :urls

          def initialize(incoming={})
            super(:discriminator => CheckoutTokenForm::Types::CHECKOUT_TOKEN_REFERENCE_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order_number, :session_id, :urls], 'CheckoutTokenReferenceForm')
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @session_id = HttpClient::Preconditions.assert_class('session_id', opts.delete(:session_id), String)
            @urls = (x = opts.delete(:urls); x.is_a?(::Io::Flow::V0::Models::CheckoutUrlsForm) ? x : ::Io::Flow::V0::Models::CheckoutUrlsForm.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutTokenReferenceForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :order_number => order_number,
              :session_id => session_id,
              :urls => urls.to_hash
            }
          end

        end

        class CheckoutUrls

          attr_reader :continue_shopping, :confirmation, :invalid_checkout

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @continue_shopping = (x = opts.delete(:continue_shopping); x.nil? ? nil : HttpClient::Preconditions.assert_class('continue_shopping', x, String))
            @confirmation = (x = opts.delete(:confirmation); x.nil? ? nil : HttpClient::Preconditions.assert_class('confirmation', x, String))
            @invalid_checkout = (x = opts.delete(:invalid_checkout); x.nil? ? nil : HttpClient::Preconditions.assert_class('invalid_checkout', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutUrls.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :continue_shopping => continue_shopping,
              :confirmation => confirmation,
              :invalid_checkout => invalid_checkout
            }
          end

        end

        class CheckoutUrlsForm

          attr_reader :continue_shopping, :confirmation, :invalid_checkout

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @continue_shopping = (x = opts.delete(:continue_shopping); x.nil? ? nil : HttpClient::Preconditions.assert_class('continue_shopping', x, String))
            @confirmation = (x = opts.delete(:confirmation); x.nil? ? nil : HttpClient::Preconditions.assert_class('confirmation', x, String))
            @invalid_checkout = (x = opts.delete(:invalid_checkout); x.nil? ? nil : HttpClient::Preconditions.assert_class('invalid_checkout', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutUrlsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :continue_shopping => continue_shopping,
              :confirmation => confirmation,
              :invalid_checkout => invalid_checkout
            }
          end

        end

        # The actual value of the API token. This is modeled as a separate resource as
        # it is fetched only on demand.
        class Cleartext

          attr_reader :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value], 'Cleartext')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cleartext.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value
            }
          end

        end

        class CommercialInvoiceFee < PartnerCenterFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => PartnerCenterFee::Types::COMMERCIAL_INVOICE_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'CommercialInvoiceFee')
            @amount = (x = opts.delete(:amount); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CommercialInvoiceFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_hash
            }
          end

        end

        # The consumer invoice represents the details of a set of items from a given
        # order. This may represent either the full order or a partial fulfillment.
        class ConsumerInvoice

          attr_reader :id, :number, :status, :date, :key, :order, :entity, :payments, :center, :destination, :billing_address, :lines, :documents, :attributes, :tax_registration, :customer_type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :status, :date, :key, :order, :entity, :payments, :destination, :lines, :documents, :attributes], 'ConsumerInvoice')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceStatus) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceStatus.apply(x))
            @date = HttpClient::Preconditions.assert_class('date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:date)), DateTime)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceOrderSummary) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceOrderSummary.new(x))
            @entity = (x = opts.delete(:entity); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x))
            @payments = HttpClient::Preconditions.assert_class('payments', opts.delete(:payments), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoicePayment) ? x : ::Io::Flow::V0::Models::ConsumerInvoicePayment.new(x)) }
            @center = (x = opts.delete(:center); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceCenterReference) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceCenterReference.new(x)))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
            @billing_address = (x = opts.delete(:billing_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLine) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLine.from_json(x)) }
            @documents = HttpClient::Preconditions.assert_class('documents', opts.delete(:documents), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceDocument) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceDocument.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @tax_registration = (x = opts.delete(:tax_registration); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TaxRegistration) ? x : ::Io::Flow::V0::Models::TaxRegistration.new(x)))
            @customer_type = (x = opts.delete(:customer_type); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceCustomerType) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceCustomerType.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoice.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :status => status.value,
              :date => date,
              :key => key,
              :order => order.to_hash,
              :entity => entity.to_hash,
              :payments => payments.map { |o| o.to_hash },
              :center => center.nil? ? nil : center.to_hash,
              :destination => destination.to_hash,
              :billing_address => billing_address.nil? ? nil : billing_address.to_hash,
              :lines => lines.map { |o| o.to_hash },
              :documents => documents.map { |o| o.to_hash },
              :attributes => attributes,
              :tax_registration => tax_registration.nil? ? nil : tax_registration.to_hash,
              :customer_type => customer_type.nil? ? nil : customer_type.value
            }
          end

        end

        class ConsumerInvoiceCenterReference

          attr_reader :id, :key, :name, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name, :address], 'ConsumerInvoiceCenterReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceCenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :address => address.to_hash
            }
          end

        end

        class ConsumerInvoiceDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :consumer_invoice

          def initialize(incoming={})
            super(:discriminator => Event::Types::CONSUMER_INVOICE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :consumer_invoice], 'ConsumerInvoiceDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @consumer_invoice = (x = opts.delete(:consumer_invoice); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoice) ? x : ::Io::Flow::V0::Models::ConsumerInvoice.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :consumer_invoice => consumer_invoice.to_hash
            }
          end

        end

        class ConsumerInvoiceDocument

          attr_reader :type, :language, :url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :language, :url], 'ConsumerInvoiceDocument')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceDocumentType) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceDocumentType.apply(x))
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceDocument.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :language => language,
              :url => url
            }
          end

        end

        class ConsumerInvoiceForm

          attr_reader :order_number, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order_number], 'ConsumerInvoiceForm')
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order_number => order_number,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class ConsumerInvoiceFormByOrder

          attr_reader :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceFormByOrder.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class ConsumerInvoiceLevy

          attr_reader :rate, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :value], 'ConsumerInvoiceLevy')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @value = (x = opts.delete(:value); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLevy.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate.to_f.to_s,
              :value => value.to_hash
            }
          end

        end

        class ConsumerInvoiceLevyForm

          attr_reader :rate, :amount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :amount], 'ConsumerInvoiceLevyForm')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLevyForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate.to_f.to_s,
              :amount => amount.to_f.to_s
            }
          end

        end

        class ConsumerInvoiceLineDiscount < ConsumerInvoiceLine

          attr_reader :price

          def initialize(incoming={})
            super(:discriminator => ConsumerInvoiceLine::Types::CONSUMER_INVOICE_LINE_DISCOUNT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'ConsumerInvoiceLineDiscount')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLineDiscount.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        class ConsumerInvoiceLineDiscountForm < ConsumerInvoiceLineForm

          attr_reader :price

          def initialize(incoming={})
            super(:discriminator => ConsumerInvoiceLineForm::Types::CONSUMER_INVOICE_LINE_DISCOUNT_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'ConsumerInvoiceLineDiscountForm')
            @price = HttpClient::Preconditions.assert_class('price', HttpClient::Helper.to_big_decimal(opts.delete(:price)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLineDiscountForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_f.to_s
            }
          end

        end

        class ConsumerInvoiceLineItem < ConsumerInvoiceLine

          attr_reader :item, :description, :quantity, :unit_price, :unit_discount, :unit_tax, :unit_duty

          def initialize(incoming={})
            super(:discriminator => ConsumerInvoiceLine::Types::CONSUMER_INVOICE_LINE_ITEM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :description, :quantity, :unit_price], 'ConsumerInvoiceLineItem')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::ItemReference) ? x : ::Io::Flow::V0::Models::ItemReference.new(x))
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @unit_price = (x = opts.delete(:unit_price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @unit_discount = (x = opts.delete(:unit_discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @unit_tax = (x = opts.delete(:unit_tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevy) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevy.new(x)))
            @unit_duty = (x = opts.delete(:unit_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevy) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevy.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLineItem.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :item => item.to_hash,
              :description => description,
              :quantity => quantity,
              :unit_price => unit_price.to_hash,
              :unit_discount => unit_discount.nil? ? nil : unit_discount.to_hash,
              :unit_tax => unit_tax.nil? ? nil : unit_tax.to_hash,
              :unit_duty => unit_duty.nil? ? nil : unit_duty.to_hash
            }
          end

        end

        class ConsumerInvoiceLineItemForm < ConsumerInvoiceLineForm

          attr_reader :item_number, :quantity, :unit_price, :unit_discount, :unit_tax, :unit_duty

          def initialize(incoming={})
            super(:discriminator => ConsumerInvoiceLineForm::Types::CONSUMER_INVOICE_LINE_ITEM_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :quantity, :unit_price], 'ConsumerInvoiceLineItemForm')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @unit_price = HttpClient::Preconditions.assert_class('unit_price', HttpClient::Helper.to_big_decimal(opts.delete(:unit_price)), BigDecimal)
            @unit_discount = (x = opts.delete(:unit_discount); x.nil? ? nil : HttpClient::Preconditions.assert_class('unit_discount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @unit_tax = (x = opts.delete(:unit_tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevyForm) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevyForm.new(x)))
            @unit_duty = (x = opts.delete(:unit_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevyForm) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevyForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLineItemForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :item_number => item_number,
              :quantity => quantity,
              :unit_price => unit_price.to_f.to_s,
              :unit_discount => unit_discount.to_f.to_s,
              :unit_tax => unit_tax.nil? ? nil : unit_tax.to_hash,
              :unit_duty => unit_duty.nil? ? nil : unit_duty.to_hash
            }
          end

        end

        class ConsumerInvoiceLineShipping < ConsumerInvoiceLine

          attr_reader :price, :discount, :tax, :duty

          def initialize(incoming={})
            super(:discriminator => ConsumerInvoiceLine::Types::CONSUMER_INVOICE_LINE_SHIPPING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'ConsumerInvoiceLineShipping')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @tax = (x = opts.delete(:tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevy) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevy.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevy) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevy.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLineShipping.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :tax => tax.nil? ? nil : tax.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash
            }
          end

        end

        class ConsumerInvoiceLineShippingForm < ConsumerInvoiceLineForm

          attr_reader :price, :discount, :tax, :duty

          def initialize(incoming={})
            super(:discriminator => ConsumerInvoiceLineForm::Types::CONSUMER_INVOICE_LINE_SHIPPING_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'ConsumerInvoiceLineShippingForm')
            @price = HttpClient::Preconditions.assert_class('price', HttpClient::Helper.to_big_decimal(opts.delete(:price)), BigDecimal)
            @discount = (x = opts.delete(:discount); x.nil? ? nil : HttpClient::Preconditions.assert_class('discount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @tax = (x = opts.delete(:tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevyForm) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevyForm.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLevyForm) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLevyForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceLineShippingForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_f.to_s,
              :discount => discount.to_f.to_s,
              :tax => tax.nil? ? nil : tax.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash
            }
          end

        end

        class ConsumerInvoiceOrderSummary

          attr_reader :id, :number, :submitted_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :submitted_at], 'ConsumerInvoiceOrderSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @submitted_at = HttpClient::Preconditions.assert_class('submitted_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:submitted_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceOrderSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :submitted_at => submitted_at
            }
          end

        end

        class ConsumerInvoicePayment

          attr_reader :date, :description, :value, :billing_address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:date, :description, :value], 'ConsumerInvoicePayment')
            @date = HttpClient::Preconditions.assert_class('date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:date)), DateTime)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @value = (x = opts.delete(:value); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @billing_address = (x = opts.delete(:billing_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoicePayment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :date => date,
              :description => description,
              :value => value.to_hash,
              :billing_address => billing_address.nil? ? nil : billing_address.to_hash
            }
          end

        end

        class ConsumerInvoiceReference

          attr_reader :id, :key, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :number], 'ConsumerInvoiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :number => number
            }
          end

        end

        class ConsumerInvoiceUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :consumer_invoice

          def initialize(incoming={})
            super(:discriminator => Event::Types::CONSUMER_INVOICE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :consumer_invoice], 'ConsumerInvoiceUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @consumer_invoice = (x = opts.delete(:consumer_invoice); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoice) ? x : ::Io::Flow::V0::Models::ConsumerInvoice.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ConsumerInvoiceUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :consumer_invoice => consumer_invoice.to_hash
            }
          end

        end

        # Defines structured fields for a contact person. Typically used for specifying
        # contact person for an account, shipment, or organization representative
        class Contact

          attr_reader :name, :company, :email, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Contact')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @company = (x = opts.delete(:company); x.nil? ? nil : HttpClient::Preconditions.assert_class('company', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Contact.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :company => company,
              :email => email,
              :phone => phone
            }
          end

        end

        # ISO 3166 country codes. Note Flow APIs will accept either the 2 or 3 character
        # country code, but internally we normalize data and store as the 3 character,
        # upper case ISO code. See https://api.flow.io/reference/countries
        class Country

          attr_reader :name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system, :default_currency, :default_language, :timezones, :default_delivered_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system, :timezones], 'Country')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_3166_2 = HttpClient::Preconditions.assert_class('iso_3166_2', opts.delete(:iso_3166_2), String)
            @iso_3166_3 = HttpClient::Preconditions.assert_class('iso_3166_3', opts.delete(:iso_3166_3), String)
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_system = HttpClient::Preconditions.assert_class('measurement_system', opts.delete(:measurement_system), String)
            @default_currency = (x = opts.delete(:default_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_currency', x, String))
            @default_language = (x = opts.delete(:default_language); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_language', x, String))
            @timezones = HttpClient::Preconditions.assert_class('timezones', opts.delete(:timezones), Array).map { |v| HttpClient::Preconditions.assert_class('timezones', v, String) }
            @default_delivered_duty = (x = opts.delete(:default_delivered_duty); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_delivered_duty', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Country.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_3166_2 => iso_3166_2,
              :iso_3166_3 => iso_3166_3,
              :languages => languages,
              :measurement_system => measurement_system,
              :default_currency => default_currency,
              :default_language => default_language,
              :timezones => timezones,
              :default_delivered_duty => default_delivered_duty
            }
          end

        end

        class CountryAvailability

          attr_reader :status, :countries

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status, :countries], 'CountryAvailability')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ItemAvailabilityStatus) ? x : ::Io::Flow::V0::Models::ItemAvailabilityStatus.apply(x))
            @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CountryAvailability.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value,
              :countries => countries
            }
          end

        end

        # Provides country level default settings for currency, language, etc.
        class CountryDefaults

          attr_reader :country, :currency, :language

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :currency, :language], 'CountryDefaults')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CountryDefaults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country,
              :currency => currency,
              :language => language
            }
          end

        end

        class CountryShippingPricing

          attr_reader :pricing, :countries

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:pricing, :countries], 'CountryShippingPricing')
            @pricing = (x = opts.delete(:pricing); x.is_a?(::Io::Flow::V0::Models::ItemShippingPricing) ? x : ::Io::Flow::V0::Models::ItemShippingPricing.new(x))
            @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CountryShippingPricing.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :pricing => pricing.to_hash,
              :countries => countries
            }
          end

        end

        # The credit memo represents the details of a refund and the reasons for the
        # issuance of the refund.
        class CreditMemo

          attr_reader :id, :number, :status, :date, :key, :invoice, :entity, :payments, :lines, :documents, :attributes, :tax_registration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :date, :key, :invoice, :entity, :payments, :lines, :documents, :attributes], 'CreditMemo')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceStatus) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceStatus.apply(x))
            @date = HttpClient::Preconditions.assert_class('date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:date)), DateTime)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @invoice = (x = opts.delete(:invoice); x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceReference) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceReference.new(x))
            @entity = (x = opts.delete(:entity); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x))
            @payments = HttpClient::Preconditions.assert_class('payments', opts.delete(:payments), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoicePayment) ? x : ::Io::Flow::V0::Models::ConsumerInvoicePayment.new(x)) }
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLine) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLine.from_json(x)) }
            @documents = HttpClient::Preconditions.assert_class('documents', opts.delete(:documents), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceDocument) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceDocument.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @tax_registration = (x = opts.delete(:tax_registration); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TaxRegistration) ? x : ::Io::Flow::V0::Models::TaxRegistration.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditMemo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :status => status.value,
              :date => date,
              :key => key,
              :invoice => invoice.to_hash,
              :entity => entity.to_hash,
              :payments => payments.map { |o| o.to_hash },
              :lines => lines.map { |o| o.to_hash },
              :documents => documents.map { |o| o.to_hash },
              :attributes => attributes,
              :tax_registration => tax_registration.nil? ? nil : tax_registration.to_hash
            }
          end

        end

        class CreditMemoDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :credit_memo

          def initialize(incoming={})
            super(:discriminator => Event::Types::CREDIT_MEMO_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :credit_memo], 'CreditMemoDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @credit_memo = (x = opts.delete(:credit_memo); x.is_a?(::Io::Flow::V0::Models::CreditMemo) ? x : ::Io::Flow::V0::Models::CreditMemo.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditMemoDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :credit_memo => credit_memo.to_hash
            }
          end

        end

        # A credit memo form defines the information needed to create a credit memo. You
        # must provide a way to identify the refund issued - either by id, key or
        # identifier.
        class CreditMemoForm

          attr_reader :refund_id, :refund_key, :refund_identifier, :lines, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:lines], 'CreditMemoForm')
            @refund_id = (x = opts.delete(:refund_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_id', x, String))
            @refund_key = (x = opts.delete(:refund_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_key', x, String))
            @refund_identifier = (x = opts.delete(:refund_identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_identifier', x, String))
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ConsumerInvoiceLineForm) ? x : ::Io::Flow::V0::Models::ConsumerInvoiceLineForm.from_json(x)) }
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditMemoForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :refund_id => refund_id,
              :refund_key => refund_key,
              :refund_identifier => refund_identifier,
              :lines => lines.map { |o| o.to_hash },
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class CreditMemoUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :credit_memo

          def initialize(incoming={})
            super(:discriminator => Event::Types::CREDIT_MEMO_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :credit_memo], 'CreditMemoUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @credit_memo = (x = opts.delete(:credit_memo); x.is_a?(::Io::Flow::V0::Models::CreditMemo) ? x : ::Io::Flow::V0::Models::CreditMemo.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditMemoUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :credit_memo => credit_memo.to_hash
            }
          end

        end

        # A Credit Payment records a 'non cash' payment against an order (e.g. a store
        # credit, gift card, etc.), recording the amount of that credit and additional
        # details to reconcile payments. The primary purpose of the credit payment is to
        # record that a payment has been made against an order so the remaining balance
        # can be correctly computed.
        class CreditPayment

          attr_reader :id, :order, :key, :description, :value, :original, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order, :key, :description, :value, :original, :attributes], 'CreditPayment')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::ExpandableOrder) ? x : ::Io::Flow::V0::Models::ExpandableOrder.from_json(x))
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @value = (x = opts.delete(:value); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @original = (x = opts.delete(:original); x.is_a?(::Io::Flow::V0::Models::OriginalPrices) ? x : ::Io::Flow::V0::Models::OriginalPrices.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditPayment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :order => order.to_hash,
              :key => key,
              :description => description,
              :value => value.to_hash,
              :original => original.to_hash,
              :attributes => attributes
            }
          end

        end

        class CreditPaymentError

          attr_reader :code, :messages, :codes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages, :codes], 'CreditPaymentError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::CreditPaymentErrorCode) ? x : ::Io::Flow::V0::Models::CreditPaymentErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @codes = HttpClient::Preconditions.assert_class('codes', opts.delete(:codes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CreditPaymentErrorCode) ? x : ::Io::Flow::V0::Models::CreditPaymentErrorCode.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditPaymentError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :codes => codes.map { |o| o.value }
            }
          end

        end

        class CreditPaymentForm

          attr_reader :order_number, :description, :amount, :max, :currency, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order_number, :description, :amount, :max, :currency], 'CreditPaymentForm')
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @max = HttpClient::Preconditions.assert_class('max', HttpClient::Helper.to_big_decimal(opts.delete(:max)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditPaymentForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order_number => order_number,
              :description => description,
              :amount => amount.to_f.to_s,
              :max => max.to_f.to_s,
              :currency => currency,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class CreditPaymentVersion

          attr_reader :id, :timestamp, :type, :credit_payment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :credit_payment], 'CreditPaymentVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @credit_payment = (x = opts.delete(:credit_payment); x.is_a?(::Io::Flow::V0::Models::CreditPayment) ? x : ::Io::Flow::V0::Models::CreditPayment.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CreditPaymentVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :credit_payment => credit_payment.to_hash
            }
          end

        end

        class CrossdockRatecardFee < RatecardFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => RatecardFee::Types::CROSSDOCK_RATECARD_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'CrossdockRatecardFee')
            @amount = (x = opts.delete(:amount); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CrossdockRatecardFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_hash
            }
          end

        end

        class CrossdockShipment

          attr_reader :partner_id, :center_id, :tracking_id, :order_number, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:partner_id, :center_id, :tracking_id, :order_number, :status], 'CrossdockShipment')
            @partner_id = HttpClient::Preconditions.assert_class('partner_id', opts.delete(:partner_id), String)
            @center_id = HttpClient::Preconditions.assert_class('center_id', opts.delete(:center_id), String)
            @tracking_id = HttpClient::Preconditions.assert_class('tracking_id', opts.delete(:tracking_id), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CrossdockShipment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :partner_id => partner_id,
              :center_id => center_id,
              :tracking_id => tracking_id,
              :order_number => order_number,
              :status => status
            }
          end

        end

        class CrossdockShipmentUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :crossdock_shipment

          def initialize(incoming={})
            super(:discriminator => Event::Types::CROSSDOCK_SHIPMENT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :crossdock_shipment], 'CrossdockShipmentUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @crossdock_shipment = (x = opts.delete(:crossdock_shipment); x.is_a?(::Io::Flow::V0::Models::CrossdockShipment) ? x : ::Io::Flow::V0::Models::CrossdockShipment.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CrossdockShipmentUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :crossdock_shipment => crossdock_shipment.to_hash
            }
          end

        end

        # Represents the format used to export price book item documents
        class CsvPriceBookItemExportRow

          attr_reader :price_book_key, :price_book_item_key, :item_number, :item_name, :amount, :item_attributes, :starts_at, :ends_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price_book_key, :price_book_item_key, :item_number, :item_name, :amount, :starts_at], 'CsvPriceBookItemExportRow')
            @price_book_key = HttpClient::Preconditions.assert_class('price_book_key', opts.delete(:price_book_key), String)
            @price_book_item_key = HttpClient::Preconditions.assert_class('price_book_item_key', opts.delete(:price_book_item_key), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @item_name = HttpClient::Preconditions.assert_class('item_name', opts.delete(:item_name), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @item_attributes = (x = opts.delete(:item_attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('item_attributes', d[1], String); h })
            @starts_at = HttpClient::Preconditions.assert_class('starts_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:starts_at)), DateTime)
            @ends_at = (x = opts.delete(:ends_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('ends_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CsvPriceBookItemExportRow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price_book_key => price_book_key,
              :price_book_item_key => price_book_item_key,
              :item_number => item_number,
              :item_name => item_name,
              :amount => amount.to_f.to_s,
              :item_attributes => item_attributes.nil? ? nil : item_attributes,
              :starts_at => starts_at,
              :ends_at => ends_at
            }
          end

        end

        # ISO 4217 3-character currency code. See
        # https://api.flow.io/reference/currencies
        class Currency

          attr_reader :name, :iso_4217_3, :number_decimals, :symbols, :default_locale

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_4217_3, :number_decimals], 'Currency')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_4217_3 = HttpClient::Preconditions.assert_class('iso_4217_3', opts.delete(:iso_4217_3), String)
            @number_decimals = HttpClient::Preconditions.assert_class('number_decimals', opts.delete(:number_decimals), Integer)
            @symbols = (x = opts.delete(:symbols); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CurrencySymbols) ? x : ::Io::Flow::V0::Models::CurrencySymbols.new(x)))
            @default_locale = (x = opts.delete(:default_locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_locale', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Currency.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_4217_3 => iso_4217_3,
              :number_decimals => number_decimals,
              :symbols => symbols.nil? ? nil : symbols.to_hash,
              :default_locale => default_locale
            }
          end

        end

        class CurrencyFormat

          attr_reader :symbol, :label_formatters

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:symbol, :label_formatters], 'CurrencyFormat')
            @symbol = (x = opts.delete(:symbol); x.is_a?(::Io::Flow::V0::Models::CurrencySymbolFormat) ? x : ::Io::Flow::V0::Models::CurrencySymbolFormat.apply(x))
            @label_formatters = HttpClient::Preconditions.assert_class('label_formatters', opts.delete(:label_formatters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CurrencyLabelFormatter) ? x : ::Io::Flow::V0::Models::CurrencyLabelFormatter.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CurrencyFormat.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :symbol => symbol.value,
              :label_formatters => label_formatters.map { |o| o.value }
            }
          end

        end

        class CurrencyFormatDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::CURRENCY_FORMAT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'CurrencyFormatDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CurrencyFormatDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class CurrencyFormatUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :experience_key, :symbol, :label_formatters

          def initialize(incoming={})
            super(:discriminator => Event::Types::CURRENCY_FORMAT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :experience_key, :symbol, :label_formatters], 'CurrencyFormatUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @symbol = (x = opts.delete(:symbol); x.is_a?(::Io::Flow::V0::Models::CurrencySymbolFormat) ? x : ::Io::Flow::V0::Models::CurrencySymbolFormat.apply(x))
            @label_formatters = HttpClient::Preconditions.assert_class('label_formatters', opts.delete(:label_formatters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CurrencyLabelFormatter) ? x : ::Io::Flow::V0::Models::CurrencyLabelFormatter.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CurrencyFormatUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :experience_key => experience_key,
              :symbol => symbol.value,
              :label_formatters => label_formatters.map { |o| o.value }
            }
          end

        end

        # Defines one or more symbols representing this currency
        class CurrencySymbols

          attr_reader :primary, :narrow

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:primary], 'CurrencySymbols')
            @primary = HttpClient::Preconditions.assert_class('primary', opts.delete(:primary), String)
            @narrow = (x = opts.delete(:narrow); x.nil? ? nil : HttpClient::Preconditions.assert_class('narrow', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CurrencySymbols.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :primary => primary,
              :narrow => narrow
            }
          end

        end

        # A customer represents the actual person placing an order.
        class Customer

          attr_reader :id, :number, :email, :name, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'Customer')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Customer.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :phone => phone
            }
          end

        end

        # A composed model representing a customer's address book contacts.
        class CustomerAddressBook

          attr_reader :contacts

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contacts], 'CustomerAddressBook')
            @contacts = HttpClient::Preconditions.assert_class('contacts', opts.delete(:contacts), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CustomerAddressBookContact) ? x : ::Io::Flow::V0::Models::CustomerAddressBookContact.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerAddressBook.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contacts => contacts.map { |o| o.to_hash }
            }
          end

        end

        # Preferences may indicate a contact is preferred for billing, invoicing, and/or
        # shipping.
        class CustomerAddressBookContact

          attr_reader :id, :address, :contact, :address_preferences

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :address, :contact, :address_preferences], 'CustomerAddressBookContact')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @contact = (x = opts.delete(:contact); x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x))
            @address_preferences = HttpClient::Preconditions.assert_class('address_preferences', opts.delete(:address_preferences), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CustomerAddressPreference) ? x : ::Io::Flow::V0::Models::CustomerAddressPreference.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerAddressBookContact.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :address => address.to_hash,
              :contact => contact.to_hash,
              :address_preferences => address_preferences.map { |o| o.to_hash }
            }
          end

        end

        class CustomerAddressBookContactDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :customer_address_book_contact

          def initialize(incoming={})
            super(:discriminator => Event::Types::CUSTOMER_ADDRESS_BOOK_CONTACT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :customer_address_book_contact], 'CustomerAddressBookContactDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @customer_address_book_contact = (x = opts.delete(:customer_address_book_contact); x.is_a?(::Io::Flow::V0::Models::CustomerAddressBookContact) ? x : ::Io::Flow::V0::Models::CustomerAddressBookContact.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerAddressBookContactDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :customer_address_book_contact => customer_address_book_contact.to_hash
            }
          end

        end

        class CustomerAddressBookContactForm

          attr_reader :address, :contact, :address_preferences

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address], 'CustomerAddressBookContactForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @contact = (x = opts.delete(:contact); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x)))
            @address_preferences = (x = opts.delete(:address_preferences); x.nil? ? nil : HttpClient::Preconditions.assert_class('address_preferences', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CustomerAddressPreference) ? x : ::Io::Flow::V0::Models::CustomerAddressPreference.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerAddressBookContactForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :contact => contact.nil? ? nil : contact.to_hash,
              :address_preferences => address_preferences.nil? ? nil : address_preferences.map { |o| o.to_hash }
            }
          end

        end

        class CustomerAddressBookContactUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :customer_address_book_contact

          def initialize(incoming={})
            super(:discriminator => Event::Types::CUSTOMER_ADDRESS_BOOK_CONTACT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :customer_address_book_contact], 'CustomerAddressBookContactUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @customer_address_book_contact = (x = opts.delete(:customer_address_book_contact); x.is_a?(::Io::Flow::V0::Models::CustomerAddressBookContact) ? x : ::Io::Flow::V0::Models::CustomerAddressBookContact.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerAddressBookContactUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :customer_address_book_contact => customer_address_book_contact.to_hash
            }
          end

        end

        # Represents address book contacts to append in bulk.
        class CustomerAddressBookForm

          attr_reader :contacts

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contacts], 'CustomerAddressBookForm')
            @contacts = HttpClient::Preconditions.assert_class('contacts', opts.delete(:contacts), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CustomerAddressBookContactForm) ? x : ::Io::Flow::V0::Models::CustomerAddressBookContactForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerAddressBookForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contacts => contacts.map { |o| o.to_hash }
            }
          end

        end

        # Represents a customer address preference. Only a single address book contact
        # can be associated per type. If contact is created or updated with a
        # preference, existing preferences of the same type will be removed.
        class CustomerAddressPreference

          attr_reader :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'CustomerAddressPreference')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CustomerAddressType) ? x : ::Io::Flow::V0::Models::CustomerAddressType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerAddressPreference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value
            }
          end

        end

        # A bundle of all the content needed to render customer data.
        class CustomerBundle

          attr_reader :customer, :last_used

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:customer], 'CustomerBundle')
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @last_used = (x = opts.delete(:last_used); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CustomerLastUsed) ? x : ::Io::Flow::V0::Models::CustomerLastUsed.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerBundle.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :customer => customer.to_hash,
              :last_used => last_used.nil? ? nil : last_used.to_hash
            }
          end

        end

        class CustomerDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :customer

          def initialize(incoming={})
            super(:discriminator => Event::Types::CUSTOMER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :customer], 'CustomerDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :customer => customer.to_hash
            }
          end

        end

        class CustomerForm

          attr_reader :number, :email, :name, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'CustomerForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :phone => phone
            }
          end

        end

        class CustomerInvoice

          attr_reader :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerInvoice.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        # Last used details pertaining to a customer.
        class CustomerLastUsed

          attr_reader :order, :payment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order, :payment], 'CustomerLastUsed')
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::CustomerOrder) ? x : ::Io::Flow::V0::Models::CustomerOrder.new(x))
            @payment = (x = opts.delete(:payment); x.is_a?(::Io::Flow::V0::Models::CustomerPayment) ? x : ::Io::Flow::V0::Models::CustomerPayment.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerLastUsed.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order.to_hash,
              :payment => payment.to_hash
            }
          end

        end

        # Order details pertaining to a customer.
        class CustomerOrder

          attr_reader :number, :destination, :payments, :submitted_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :destination], 'CustomerOrder')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
            @payments = (x = opts.delete(:payments); x.nil? ? nil : HttpClient::Preconditions.assert_class('payments', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPayment) ? x : ::Io::Flow::V0::Models::OrderPayment.new(x)) })
            @submitted_at = (x = opts.delete(:submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerOrder.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :destination => destination.to_hash,
              :payments => payments.nil? ? nil : payments.map { |o| o.to_hash },
              :submitted_at => submitted_at
            }
          end

        end

        # Customer payment details.
        class CustomerPayment

          attr_reader :payment_methods

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:payment_methods], 'CustomerPayment')
            @payment_methods = HttpClient::Preconditions.assert_class('payment_methods', opts.delete(:payment_methods), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentMethod) ? x : ::Io::Flow::V0::Models::PaymentMethod.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerPayment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :payment_methods => payment_methods.map { |o| o.to_hash }
            }
          end

        end

        class CustomerPutForm

          attr_reader :email, :name, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :phone => phone
            }
          end

        end

        class CustomerReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'CustomerReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        # Represents a mapping between a customer number and a token
        class CustomerToken

          attr_reader :id, :customer, :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :customer, :token], 'CustomerToken')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::CustomerReference) ? x : ::Io::Flow::V0::Models::CustomerReference.new(x))
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerToken.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :customer => customer.to_hash,
              :token => token
            }
          end

        end

        class CustomerUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :customer

          def initialize(incoming={})
            super(:discriminator => Event::Types::CUSTOMER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :customer], 'CustomerUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :customer => customer.to_hash
            }
          end

        end

        # Represents the card verification results
        class Cvv

          attr_reader :code, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'Cvv')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::CvvCode) ? x : ::Io::Flow::V0::Models::CvvCode.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cvv.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :description => description
            }
          end

        end

        class DatetimeRange

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DatetimeRange')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DatetimeRange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class DdpRatecardFee < RatecardFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => RatecardFee::Types::DDP_RATECARD_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'DdpRatecardFee')
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DdpRatecardFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_f.to_s
            }
          end

        end

        class DeliveredDutySetting

          attr_reader :default, :available, :display

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:default, :available], 'DeliveredDutySetting')
            @default = (x = opts.delete(:default); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)) }
            @display = (x = opts.delete(:display); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDutyDisplayType) ? x : ::Io::Flow::V0::Models::DeliveredDutyDisplayType.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveredDutySetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :default => default.value,
              :available => available.map { |o| o.value },
              :display => display.nil? ? nil : display.value
            }
          end

        end

        class DeliveryItem

          attr_reader :number, :quantity, :shipment_estimate, :price, :attributes, :center, :line_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'DeliveryItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @shipment_estimate = (x = opts.delete(:shipment_estimate); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MoneyWithOptionalBase) ? x : ::Io::Flow::V0::Models::MoneyWithOptionalBase.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
            @line_number = (x = opts.delete(:line_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('line_number', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity,
              :shipment_estimate => shipment_estimate.nil? ? nil : shipment_estimate.to_hash,
              :price => price.nil? ? nil : price.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :center => center,
              :line_number => line_number
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOption

          attr_reader :id, :cost, :delivered_duty, :price, :service, :tier, :window, :rule_outcome, :weight, :send_to, :surcharge, :ratecard_owner

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :delivered_duty, :price, :service, :tier, :window], 'DeliveryOption')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::PriceWithBaseAndDetails) ? x : ::Io::Flow::V0::Models::PriceWithBaseAndDetails.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBaseAndDetails) ? x : ::Io::Flow::V0::Models::PriceWithBaseAndDetails.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierSummary) ? x : ::Io::Flow::V0::Models::TierSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DeliveryWindow) ? x : ::Io::Flow::V0::Models::DeliveryWindow.new(x))
            @rule_outcome = (x = opts.delete(:rule_outcome); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TierRuleOutcome) ? x : ::Io::Flow::V0::Models::TierRuleOutcome.from_json(x)))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OptionWeightEstimates) ? x : ::Io::Flow::V0::Models::OptionWeightEstimates.new(x)))
            @send_to = (x = opts.delete(:send_to); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
            @surcharge = (x = opts.delete(:surcharge); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBaseAndDetails) ? x : ::Io::Flow::V0::Models::PriceWithBaseAndDetails.new(x)))
            @ratecard_owner = (x = opts.delete(:ratecard_owner); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::RatecardOwner) ? x : ::Io::Flow::V0::Models::RatecardOwner.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOption.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :delivered_duty => delivered_duty.value,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash,
              :rule_outcome => rule_outcome.nil? ? nil : rule_outcome.to_hash,
              :weight => weight.nil? ? nil : weight.to_hash,
              :send_to => send_to.nil? ? nil : send_to.to_hash,
              :surcharge => surcharge.nil? ? nil : surcharge.to_hash,
              :ratecard_owner => ratecard_owner.nil? ? nil : ratecard_owner.value
            }
          end

        end

        class DeliveryOptionCostComponent

          attr_reader :key, :currency, :amount, :label, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label], 'DeliveryOptionCostComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionCostDetailComponentKey) ? x : ::Io::Flow::V0::Models::DeliveryOptionCostDetailComponentKey.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionCostComponent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :currency => currency,
              :amount => amount.to_f.to_s,
              :label => label,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        class DeliveryOptionCostDetail

          attr_reader :source, :currency, :amount, :label, :base, :components

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:source, :currency, :amount, :label, :components], 'DeliveryOptionCostDetail')
            @source = (x = opts.delete(:source); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionCostDetailSource) ? x : ::Io::Flow::V0::Models::DeliveryOptionCostDetailSource.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOptionCostComponent) ? x : ::Io::Flow::V0::Models::DeliveryOptionCostComponent.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionCostDetail.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :source => source.value,
              :currency => currency,
              :amount => amount.to_f.to_s,
              :label => label,
              :base => base.nil? ? nil : base.to_hash,
              :components => components.map { |o| o.to_hash }
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOptionForm

          attr_reader :delivery, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivery, :items, :destination], 'DeliveryOptionForm')
            @delivery = HttpClient::Preconditions.assert_class('delivery', opts.delete(:delivery), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::QuoteLineItemForm) ? x : ::Io::Flow::V0::Models::QuoteLineItemForm.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivery => delivery,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        class DeliveryOptionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'DeliveryOptionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class DeliveryOptionSummary

          attr_reader :id, :cost, :delivered_duty, :price, :service, :tier, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :delivered_duty, :price, :service, :tier, :window], 'DeliveryOptionSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :delivered_duty => delivered_duty.value,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash
            }
          end

        end

        class DeliveryOptionVersion

          attr_reader :id, :timestamp, :type, :delivery_option

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery_option], 'DeliveryOptionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery_option = (x = opts.delete(:delivery_option); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionSummary) ? x : ::Io::Flow::V0::Models::DeliveryOptionSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery_option => delivery_option.to_hash
            }
          end

        end

        class DeliverySummary

          attr_reader :id, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items], 'DeliverySummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliverySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class DeliveryVersion

          attr_reader :id, :timestamp, :type, :delivery

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery], 'DeliveryVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery = (x = opts.delete(:delivery); x.is_a?(::Io::Flow::V0::Models::DeliverySummary) ? x : ::Io::Flow::V0::Models::DeliverySummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery => delivery.to_hash
            }
          end

        end

        # Flow's estimate of when a shipment for this delivery will actually arrive at
        # the final destination, taking into account a shipment estimate, center
        # schedules, and carrier transit windows.
        class DeliveryWindow

          attr_reader :from, :to, :timezone, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DeliveryWindow')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
            @timezone = (x = opts.delete(:timezone); x.nil? ? nil : HttpClient::Preconditions.assert_class('timezone', x, String))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :timezone => timezone,
              :label => label
            }
          end

        end

        class DeliveryWindowComponent

          attr_reader :from, :to, :source

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to, :source], 'DeliveryWindowComponent')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
            @source = (x = opts.delete(:source); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowComponentSource) ? x : ::Io::Flow::V0::Models::DeliveryWindowComponentSource.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindowComponent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :source => source.value
            }
          end

        end

        # Components and information taken into account when calculating a final
        # delivery window.
        class DeliveryWindowComponents

          attr_reader :shipment_estimate, :transit_estimate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:shipment_estimate, :transit_estimate], 'DeliveryWindowComponents')
            @shipment_estimate = (x = opts.delete(:shipment_estimate); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowComponent) ? x : ::Io::Flow::V0::Models::DeliveryWindowComponent.new(x))
            @transit_estimate = (x = opts.delete(:transit_estimate); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowComponent) ? x : ::Io::Flow::V0::Models::DeliveryWindowComponent.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindowComponents.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :shipment_estimate => shipment_estimate.to_hash,
              :transit_estimate => transit_estimate.to_hash
            }
          end

        end

        # Components and information taken into account when calculating a final
        # delivery window
        class DeliveryWindowComponentsV2

          attr_reader :processing_estimates, :transit_estimates

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:processing_estimates, :transit_estimates], 'DeliveryWindowComponentsV2')
            @processing_estimates = HttpClient::Preconditions.assert_class('processing_estimates', opts.delete(:processing_estimates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ProcessingEstimate) ? x : ::Io::Flow::V0::Models::ProcessingEstimate.new(x)) }
            @transit_estimates = HttpClient::Preconditions.assert_class('transit_estimates', opts.delete(:transit_estimates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TransitEstimate) ? x : ::Io::Flow::V0::Models::TransitEstimate.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindowComponentsV2.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :processing_estimates => processing_estimates.map { |o| o.to_hash },
              :transit_estimates => transit_estimates.map { |o| o.to_hash }
            }
          end

        end

        # De Minimis per item describes rules which require minimum and/or maximum
        # values per item
        class DeminimisPerItem < Deminimis

          attr_reader :currency, :minimum, :maximum

          def initialize(incoming={})
            super(:discriminator => Deminimis::Types::DEMINIMIS_PER_ITEM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency], 'DeminimisPerItem')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @minimum = (x = opts.delete(:minimum); x.nil? ? nil : HttpClient::Preconditions.assert_class('minimum', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @maximum = (x = opts.delete(:maximum); x.nil? ? nil : HttpClient::Preconditions.assert_class('maximum', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeminimisPerItem.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :minimum => minimum.to_f.to_s,
              :maximum => maximum.to_f.to_s
            }
          end

        end

        # De Minimis for most common example which includes a value threshold and rules
        # on what components are used in the duty calculation
        class DeminimisSimple < Deminimis

          attr_reader :value, :currency, :components, :minimum

          def initialize(incoming={})
            super(:discriminator => Deminimis::Types::DEMINIMIS_SIMPLE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :components], 'DeminimisSimple')
            @value = (x = opts.delete(:value); x.nil? ? nil : HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @minimum = (x = opts.delete(:minimum); x.nil? ? nil : HttpClient::Preconditions.assert_class('minimum', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeminimisSimple.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :value => value.to_f.to_s,
              :currency => currency,
              :components => components.map { |o| o.value },
              :minimum => minimum.to_f.to_s
            }
          end

        end

        class DetailedShippingLabelForm < ShippingLabelForm

          attr_reader :destination, :origin, :package, :attributes, :delivered_duty, :direction, :order_number, :service, :shipment_recipient

          def initialize(incoming={})
            super(:discriminator => ShippingLabelForm::Types::DETAILED_SHIPPING_LABEL_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :origin, :package], 'DetailedShippingLabelForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @direction = (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Direction) ? x : ::Io::Flow::V0::Models::Direction.apply(x)))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            @shipment_recipient = (x = opts.delete(:shipment_recipient); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShipmentRecipient) ? x : ::Io::Flow::V0::Models::ShipmentRecipient.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DetailedShippingLabelForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :destination => destination.to_hash,
              :origin => origin.to_hash,
              :package => package.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :direction => direction.nil? ? nil : direction.value,
              :order_number => order_number,
              :service => service,
              :shipment_recipient => shipment_recipient.nil? ? nil : shipment_recipient.value
            }
          end

        end

        # Detailed form for information about a client-facilitated shipment where the
        # shipping label and fulfillment was not handled by Flow.
        class DetailedShippingNotificationForm < ShippingNotificationForm

          attr_reader :key, :attributes, :carrier_tracking_number, :destination, :order_number, :package, :service, :origin, :shipment_recipient

          def initialize(incoming={})
            super(:discriminator => ShippingNotificationForm::Types::DETAILED_SHIPPING_NOTIFICATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:carrier_tracking_number, :destination, :order_number, :package, :service], 'DetailedShippingNotificationForm')
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
            @shipment_recipient = (x = opts.delete(:shipment_recipient); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShipmentRecipient) ? x : ::Io::Flow::V0::Models::ShipmentRecipient.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DetailedShippingNotificationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key,
              :attributes => attributes.nil? ? nil : attributes,
              :carrier_tracking_number => carrier_tracking_number,
              :destination => destination.to_hash,
              :order_number => order_number,
              :package => package.to_hash,
              :service => service,
              :origin => origin.nil? ? nil : origin.to_hash,
              :shipment_recipient => shipment_recipient.nil? ? nil : shipment_recipient.value
            }
          end

        end

        # Represents a collection of items that are digitally available and do not
        # require a physical shipment
        class DigitalDelivery < Delivery

          attr_reader :id, :key, :items, :prices, :total

          def initialize(incoming={})
            super(:discriminator => Delivery::Types::DIGITAL_DELIVERY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items], 'DigitalDelivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryItem) ? x : ::Io::Flow::V0::Models::DeliveryItem.new(x)) }
            @prices = (x = opts.delete(:prices); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetail) ? x : ::Io::Flow::V0::Models::OrderPriceDetail.new(x)) })
            @total = (x = opts.delete(:total); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DigitalDelivery.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :items => items.map { |o| o.to_hash },
              :prices => prices.nil? ? nil : prices.map { |o| o.to_hash },
              :total => total.nil? ? nil : total.to_hash
            }
          end

        end

        class Dimension

          attr_reader :depth, :diameter, :length, :weight, :width

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @depth = (x = opts.delete(:depth); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @diameter = (x = opts.delete(:diameter); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @length = (x = opts.delete(:length); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @width = (x = opts.delete(:width); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimension.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :depth => depth.nil? ? nil : depth.to_hash,
              :diameter => diameter.nil? ? nil : diameter.to_hash,
              :length => length.nil? ? nil : length.to_hash,
              :weight => weight.nil? ? nil : weight.to_hash,
              :width => width.nil? ? nil : width.to_hash
            }
          end

        end

        class DimensionEstimate

          attr_reader :id, :q, :dimensions, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :dimensions, :position], 'DimensionEstimate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::EstimatedDimensions) ? x : ::Io::Flow::V0::Models::EstimatedDimensions.new(x))
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DimensionEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :dimensions => dimensions.to_hash,
              :position => position
            }
          end

        end

        class DimensionEstimateForm

          attr_reader :q, :dimensions, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :dimensions], 'DimensionEstimateForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::EstimatedDimensions) ? x : ::Io::Flow::V0::Models::EstimatedDimensions.new(x))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DimensionEstimateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :dimensions => dimensions.to_hash,
              :position => position
            }
          end

        end

        class DimensionEstimateVersion

          attr_reader :id, :timestamp, :type, :dimension_estimate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :dimension_estimate], 'DimensionEstimateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @dimension_estimate = (x = opts.delete(:dimension_estimate); x.is_a?(::Io::Flow::V0::Models::DimensionEstimate) ? x : ::Io::Flow::V0::Models::DimensionEstimate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DimensionEstimateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :dimension_estimate => dimension_estimate.to_hash
            }
          end

        end

        class Dimensions

          attr_reader :product, :packaging

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @product = (x = opts.delete(:product); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
            @packaging = (x = opts.delete(:packaging); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimensions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :product => product.nil? ? nil : product.to_hash,
              :packaging => packaging.nil? ? nil : packaging.to_hash
            }
          end

        end

        # Creates an authorization for a transaction in which you remain the merchant of
        # record. An authorization is used to check and reserve funds w/ a given payment
        # method. No funds are actually transferred; once you have you an authorization,
        # you can capture up to the amount of the authorization.
        class DirectAuthorizationForm < AuthorizationForm

          attr_reader :token, :amount, :currency, :customer, :key, :cvv, :attributes, :destination, :billing_address, :ip, :options, :redirect_urls, :browser_info

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::DIRECT_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :amount, :currency], 'DirectAuthorizationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderCustomer) ? x : ::Io::Flow::V0::Models::OrderCustomer.new(x)))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @billing_address = (x = opts.delete(:billing_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @options = (x = opts.delete(:options); x.nil? ? nil : HttpClient::Preconditions.assert_class('options', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AuthorizationOption) ? x : ::Io::Flow::V0::Models::AuthorizationOption.apply(x)) })
            @redirect_urls = (x = opts.delete(:redirect_urls); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PostPaymentRedirectUrls) ? x : ::Io::Flow::V0::Models::PostPaymentRedirectUrls.new(x)))
            @browser_info = (x = opts.delete(:browser_info); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BrowserInfo) ? x : ::Io::Flow::V0::Models::BrowserInfo.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DirectAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :token => token,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :customer => customer.nil? ? nil : customer.to_hash,
              :key => key,
              :cvv => cvv,
              :attributes => attributes.nil? ? nil : attributes,
              :destination => destination.nil? ? nil : destination.to_hash,
              :billing_address => billing_address.nil? ? nil : billing_address.to_hash,
              :ip => ip,
              :options => options.nil? ? nil : options.map { |o| o.value },
              :redirect_urls => redirect_urls.nil? ? nil : redirect_urls.to_hash,
              :browser_info => browser_info.nil? ? nil : browser_info.to_hash
            }
          end

        end

        # Represents an online direct debit payment.
        class DirectDebit < ConfirmationDetails

          attr_reader :routing_number, :last4

          def initialize(incoming={})
            super(:discriminator => ConfirmationDetails::Types::DIRECT_DEBIT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:routing_number, :last4], 'DirectDebit')
            @routing_number = HttpClient::Preconditions.assert_class('routing_number', opts.delete(:routing_number), String)
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DirectDebit.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :routing_number => routing_number,
              :last4 => last4
            }
          end

        end

        class Discount < Promotion

          attr_reader :id, :code, :label, :price, :attributes

          def initialize(incoming={})
            super(:discriminator => Promotion::Types::DISCOUNT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :label, :price], 'Discount')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @code = (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String))
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Discount.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :code => code,
              :label => label,
              :price => price.to_hash,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class DiscountForm

          attr_reader :offer, :target, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:offer], 'DiscountForm')
            @offer = (x = opts.delete(:offer); x.is_a?(::Io::Flow::V0::Models::DiscountOffer) ? x : ::Io::Flow::V0::Models::DiscountOffer.from_json(x))
            @target = (x = (x = opts.delete(:target); x.nil? ? "item" : x); x.is_a?(::Io::Flow::V0::Models::DiscountTarget) ? x : ::Io::Flow::V0::Models::DiscountTarget.apply(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DiscountForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :offer => offer.to_hash,
              :target => target.value,
              :label => label
            }
          end

        end

        class DiscountOfferFixed < DiscountOffer

          attr_reader :money

          def initialize(incoming={})
            super(:discriminator => DiscountOffer::Types::DISCOUNT_OFFER_FIXED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:money], 'DiscountOfferFixed')
            @money = (x = opts.delete(:money); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DiscountOfferFixed.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :money => money.to_hash
            }
          end

        end

        class DiscountOfferPercent < DiscountOffer

          attr_reader :percent

          def initialize(incoming={})
            super(:discriminator => DiscountOffer::Types::DISCOUNT_OFFER_PERCENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:percent], 'DiscountOfferPercent')
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DiscountOfferPercent.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :percent => percent.to_f.to_s
            }
          end

        end

        class DiscountsForm

          attr_reader :discounts

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discounts], 'DiscountsForm')
            @discounts = HttpClient::Preconditions.assert_class('discounts', opts.delete(:discounts), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DiscountForm) ? x : ::Io::Flow::V0::Models::DiscountForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DiscountsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :discounts => discounts.map { |o| o.to_hash }
            }
          end

        end

        # Represents a duration of time.
        class Duration

          attr_reader :unit, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:unit, :value], 'Duration')
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :unit => unit.value,
              :value => value
            }
          end

        end

        # Represents a simple model of duties that apply to a given item / trade lane.
        class Duty

          attr_reader :rate, :components, :deminimis, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :components], 'Duty')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimis = (x = opts.delete(:deminimis); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimis) ? x : ::Io::Flow::V0::Models::Deminimis.from_json(x)))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate.to_f.to_s,
              :components => components.map { |o| o.value },
              :deminimis => deminimis.nil? ? nil : deminimis.to_hash,
              :name => name
            }
          end

        end

        # The Ecommerce Platform defines what the organization is using for their
        # ecommerce systems.
        class EcommercePlatform

          attr_reader :id, :type, :version

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type], 'EcommercePlatform')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::EcommercePlatformType) ? x : ::Io::Flow::V0::Models::EcommercePlatformType.apply(x))
            @version = (x = opts.delete(:version); x.nil? ? nil : HttpClient::Preconditions.assert_class('version', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EcommercePlatform.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :version => version
            }
          end

        end

        class EcommercePlatformDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :ecommerce_platform

          def initialize(incoming={})
            super(:discriminator => Event::Types::ECOMMERCE_PLATFORM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :ecommerce_platform], 'EcommercePlatformDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @ecommerce_platform = (x = opts.delete(:ecommerce_platform); x.is_a?(::Io::Flow::V0::Models::EcommercePlatform) ? x : ::Io::Flow::V0::Models::EcommercePlatform.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EcommercePlatformDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :ecommerce_platform => ecommerce_platform.to_hash
            }
          end

        end

        class EcommercePlatformUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :ecommerce_platform

          def initialize(incoming={})
            super(:discriminator => Event::Types::ECOMMERCE_PLATFORM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :ecommerce_platform], 'EcommercePlatformUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @ecommerce_platform = (x = opts.delete(:ecommerce_platform); x.is_a?(::Io::Flow::V0::Models::EcommercePlatform) ? x : ::Io::Flow::V0::Models::EcommercePlatform.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EcommercePlatformUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :ecommerce_platform => ecommerce_platform.to_hash
            }
          end

        end

        # An Email Notification indicates that an email message should be delivered. The
        # type of email depends on the data and can be found in the field
        # data.discriminator.
        class EmailNotification

          attr_reader :id, :to, :created_at, :data

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :to, :created_at, :data], 'EmailNotification')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @to = (x = opts.delete(:to); x.is_a?(::Io::Flow::V0::Models::EmailRecipient) ? x : ::Io::Flow::V0::Models::EmailRecipient.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @data = (x = opts.delete(:data); x.is_a?(::Io::Flow::V0::Models::EmailNotificationData) ? x : ::Io::Flow::V0::Models::EmailNotificationData.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailNotification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :to => to.to_hash,
              :created_at => created_at,
              :data => data.to_hash
            }
          end

        end

        # Sends an refund confirmation email to the customer (using the
        # order.customer.email as the recipient).
        class EmailNotificationDataRefund < EmailNotificationData

          attr_reader :order, :return_, :payment

          def initialize(incoming={})
            super(:discriminator => EmailNotificationData::Types::EMAIL_NOTIFICATION_DATA_REFUND)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order, :return_, :payment], 'EmailNotificationDataRefund')
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderSummary) ? x : ::Io::Flow::V0::Models::OrderSummary.new(x))
            @return_ = (x = opts.delete(:return); x.is_a?(::Io::Flow::V0::Models::OrderSummary) ? x : ::Io::Flow::V0::Models::OrderSummary.new(x))
            @payment = (x = opts.delete(:payment); x.is_a?(::Io::Flow::V0::Models::EmailPaymentSummary) ? x : ::Io::Flow::V0::Models::EmailPaymentSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailNotificationDataRefund.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :order => order.to_hash,
              :return => return_.to_hash,
              :payment => payment.to_hash
            }
          end

        end

        class EmailNotificationDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :notification

          def initialize(incoming={})
            super(:discriminator => Event::Types::EMAIL_NOTIFICATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :notification], 'EmailNotificationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @notification = (x = opts.delete(:notification); x.is_a?(::Io::Flow::V0::Models::EmailNotification) ? x : ::Io::Flow::V0::Models::EmailNotification.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailNotificationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :notification => notification.to_hash
            }
          end

        end

        class EmailNotificationForm

          attr_reader :to, :created_at, :data

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:to, :created_at, :data], 'EmailNotificationForm')
            @to = (x = opts.delete(:to); x.is_a?(::Io::Flow::V0::Models::EmailRecipient) ? x : ::Io::Flow::V0::Models::EmailRecipient.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @data = (x = opts.delete(:data); x.is_a?(::Io::Flow::V0::Models::EmailNotificationData) ? x : ::Io::Flow::V0::Models::EmailNotificationData.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailNotificationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :to => to.to_hash,
              :created_at => created_at,
              :data => data.to_hash
            }
          end

        end

        class EmailNotificationUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :notification

          def initialize(incoming={})
            super(:discriminator => Event::Types::EMAIL_NOTIFICATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :notification], 'EmailNotificationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @notification = (x = opts.delete(:notification); x.is_a?(::Io::Flow::V0::Models::EmailNotification) ? x : ::Io::Flow::V0::Models::EmailNotification.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailNotificationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :notification => notification.to_hash
            }
          end

        end

        class EmailPaymentSummary

          attr_reader :refund

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:refund], 'EmailPaymentSummary')
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailPaymentSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :refund => refund.to_hash
            }
          end

        end

        class EmailRecipient

          attr_reader :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'EmailRecipient')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailRecipient.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        # Represents the successful response of an email verification token. We return
        # the email address in this case to allow the UI to display which email address
        # was verified.
        class EmailVerification

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'EmailVerification')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailVerification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        class EstimatedDimensions

          attr_reader :depth, :length, :weight, :width

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:depth, :length, :weight, :width], 'EstimatedDimensions')
            @depth = (x = opts.delete(:depth); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
            @length = (x = opts.delete(:length); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
            @weight = (x = opts.delete(:weight); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
            @width = (x = opts.delete(:width); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EstimatedDimensions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :depth => depth.to_hash,
              :length => length.to_hash,
              :weight => weight.to_hash,
              :width => width.to_hash
            }
          end

        end

        # Range of time given a from and to number and the unit. For example: 1-4 hours
        # or 4-7 days
        class EstimatedWindow

          attr_reader :from, :to, :unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to, :unit], 'EstimatedWindow')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EstimatedWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :unit => unit.value
            }
          end

        end

        # Represents an exception to the schedule of a center.
        class Exception

          attr_reader :type, :datetime_range

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :datetime_range], 'Exception')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExceptionType) ? x : ::Io::Flow::V0::Models::ExceptionType.apply(x))
            @datetime_range = (x = opts.delete(:datetime_range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Exception.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :datetime_range => datetime_range.to_hash
            }
          end

        end

        # A global exclusion rule allows the user to select 1 or more items by query and
        # to globally exclude those items from sale in one or more regions.
        class ExclusionRule

          attr_reader :id, :q, :query, :regions, :status, :description, :statistics

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :query, :regions, :status, :statistics], 'ExclusionRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @query = (x = opts.delete(:query); x.is_a?(::Io::Flow::V0::Models::Query) ? x : ::Io::Flow::V0::Models::Query.new(x))
            @regions = HttpClient::Preconditions.assert_class('regions', opts.delete(:regions), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Region) ? x : ::Io::Flow::V0::Models::Region.new(x)) }
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @statistics = (x = opts.delete(:statistics); x.is_a?(::Io::Flow::V0::Models::ExclusionRuleStatistic) ? x : ::Io::Flow::V0::Models::ExclusionRuleStatistic.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExclusionRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :query => query.to_hash,
              :regions => regions.map { |o| o.to_hash },
              :status => status.value,
              :description => description,
              :statistics => statistics.to_hash
            }
          end

        end

        class ExclusionRuleForm

          attr_reader :q, :regions, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :regions], 'ExclusionRuleForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @regions = HttpClient::Preconditions.assert_class('regions', opts.delete(:regions), Array).map { |v| HttpClient::Preconditions.assert_class('regions', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExclusionRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :regions => regions,
              :description => description
            }
          end

        end

        class ExclusionRuleStatistic

          attr_reader :state, :number_items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:state, :number_items], 'ExclusionRuleStatistic')
            @state = (x = opts.delete(:state); x.is_a?(::Io::Flow::V0::Models::ExclusionRuleState) ? x : ::Io::Flow::V0::Models::ExclusionRuleState.apply(x))
            @number_items = HttpClient::Preconditions.assert_class('number_items', opts.delete(:number_items), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExclusionRuleStatistic.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :state => state.value,
              :number_items => number_items
            }
          end

        end

        class ExclusionRuleVersion

          attr_reader :id, :timestamp, :type, :exclusion_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :exclusion_rule], 'ExclusionRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @exclusion_rule = (x = opts.delete(:exclusion_rule); x.is_a?(::Io::Flow::V0::Models::ExclusionRule) ? x : ::Io::Flow::V0::Models::ExclusionRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExclusionRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :exclusion_rule => exclusion_rule.to_hash
            }
          end

        end

        # Experiences define a local experience for a given geographic region
        class Experience < ExpandableExperience

          attr_reader :id, :key, :name, :delivered_duty, :region, :country, :currency, :language, :measurement_system, :subcatalog, :position, :settings, :status

          def initialize(incoming={})
            super(:discriminator => ExpandableExperience::Types::EXPERIENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name, :delivered_duty, :region, :country, :currency, :language, :measurement_system, :subcatalog, :position, :settings], 'Experience')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @region = (x = opts.delete(:region); x.is_a?(::Io::Flow::V0::Models::RegionReference) ? x : ::Io::Flow::V0::Models::RegionReference.new(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x))
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::V0::Models::ExperienceSettings) ? x : ::Io::Flow::V0::Models::ExperienceSettings.new(x))
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExperienceStatus) ? x : ::Io::Flow::V0::Models::ExperienceStatus.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Experience.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :delivered_duty => delivered_duty.value,
              :region => region.to_hash,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value,
              :subcatalog => subcatalog.to_hash,
              :position => position,
              :settings => settings.to_hash,
              :status => status.nil? ? nil : status.value
            }
          end

        end

        class ExperienceCheckoutSettings

          attr_reader :id, :experience, :checkout_configuration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :checkout_configuration], 'ExperienceCheckoutSettings')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceOverview) ? x : ::Io::Flow::V0::Models::ExperienceOverview.new(x))
            @checkout_configuration = (x = opts.delete(:checkout_configuration); x.is_a?(::Io::Flow::V0::Models::ExperienceConfigurationReference) ? x : ::Io::Flow::V0::Models::ExperienceConfigurationReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceCheckoutSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :checkout_configuration => checkout_configuration.to_hash
            }
          end

        end

        class ExperienceCheckoutSettingsForm

          attr_reader :checkout_configuration_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:checkout_configuration_id], 'ExperienceCheckoutSettingsForm')
            @checkout_configuration_id = HttpClient::Preconditions.assert_class('checkout_configuration_id', opts.delete(:checkout_configuration_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceCheckoutSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :checkout_configuration_id => checkout_configuration_id
            }
          end

        end

        # Represents a request to clone an experience.
        class ExperienceClone

          attr_reader :id, :source_experience, :cloned_experience, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :source_experience, :status], 'ExperienceClone')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @source_experience = (x = opts.delete(:source_experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @cloned_experience = (x = opts.delete(:cloned_experience); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x)))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ExperienceCloneStatus) ? x : ::Io::Flow::V0::Models::ExperienceCloneStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceClone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :source_experience => source_experience.to_hash,
              :cloned_experience => cloned_experience.nil? ? nil : cloned_experience.to_hash,
              :status => status.value
            }
          end

        end

        # Form for cloning an experience
        class ExperienceCloneForm

          attr_reader :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceCloneForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name
            }
          end

        end

        class ExperienceConfigurationReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ExperienceConfigurationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceConfigurationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ExperienceCurrencyFormat

          attr_reader :symbol, :label_formatters

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:symbol, :label_formatters], 'ExperienceCurrencyFormat')
            @symbol = (x = opts.delete(:symbol); x.is_a?(::Io::Flow::V0::Models::CurrencySymbolFormat) ? x : ::Io::Flow::V0::Models::CurrencySymbolFormat.apply(x))
            @label_formatters = HttpClient::Preconditions.assert_class('label_formatters', opts.delete(:label_formatters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CurrencyLabelFormatter) ? x : ::Io::Flow::V0::Models::CurrencyLabelFormatter.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceCurrencyFormat.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :symbol => symbol.value,
              :label_formatters => label_formatters.map { |o| o.value }
            }
          end

        end

        class ExperienceCurrencyFormatForm

          attr_reader :symbol, :label_formatters

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:symbol, :label_formatters], 'ExperienceCurrencyFormatForm')
            @symbol = (x = opts.delete(:symbol); x.is_a?(::Io::Flow::V0::Models::CurrencySymbolFormat) ? x : ::Io::Flow::V0::Models::CurrencySymbolFormat.apply(x))
            @label_formatters = HttpClient::Preconditions.assert_class('label_formatters', opts.delete(:label_formatters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CurrencyLabelFormatter) ? x : ::Io::Flow::V0::Models::CurrencyLabelFormatter.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceCurrencyFormatForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :symbol => symbol.value,
              :label_formatters => label_formatters.map { |o| o.value }
            }
          end

        end

        # Defines a set of defaults for a given organization and region
        class ExperienceDefaults

          attr_reader :key, :name, :delivered_duty, :country, :currency, :language, :measurement_system

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name, :delivered_duty, :country, :currency, :language, :measurement_system], 'ExperienceDefaults')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceDefaults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name,
              :delivered_duty => delivered_duty.value,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value
            }
          end

        end

        class ExperienceDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :subcatalog_id], 'ExperienceDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class ExperienceDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :experience

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience], 'ExperienceDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::Experience) ? x : ::Io::Flow::V0::Models::Experience.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience => experience.to_hash
            }
          end

        end

        # Defines the filters that can be applied when requesting an experience data
        # export
        class ExperienceExportType < ExportType

          attr_reader :organization_id, :ids, :keys

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::EXPERIENCE_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization_id], 'ExperienceExportType')
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @ids = (x = opts.delete(:ids); x.nil? ? nil : HttpClient::Preconditions.assert_class('ids', x, Array).map { |v| HttpClient::Preconditions.assert_class('ids', v, String) })
            @keys = (x = opts.delete(:keys); x.nil? ? nil : HttpClient::Preconditions.assert_class('keys', x, Array).map { |v| HttpClient::Preconditions.assert_class('keys', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :organization_id => organization_id,
              :ids => ids.nil? ? nil : ids,
              :keys => keys.nil? ? nil : keys
            }
          end

        end

        # Experiences define a local experience for a given geographic region
        class ExperienceForm

          attr_reader :region_id, :name, :delivered_duty, :country, :currency, :language, :key, :measurement_system, :subcatalog_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:region_id, :name], 'ExperienceForm')
            @region_id = HttpClient::Preconditions.assert_class('region_id', opts.delete(:region_id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @measurement_system = (x = opts.delete(:measurement_system); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x)))
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :region_id => region_id,
              :name => name,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :country => country,
              :currency => currency,
              :language => language,
              :key => key,
              :measurement_system => measurement_system.nil? ? nil : measurement_system.value,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        # Experience Geo summarizes an experience along with geographic info
        class ExperienceGeo

          attr_reader :key, :name, :region, :country, :currency, :language, :measurement_system

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name, :region, :country, :currency, :language, :measurement_system], 'ExperienceGeo')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @region = (x = opts.delete(:region); x.is_a?(::Io::Flow::V0::Models::RegionReference) ? x : ::Io::Flow::V0::Models::RegionReference.new(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceGeo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name,
              :region => region.to_hash,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value
            }
          end

        end

        class ExperienceLogisticsSettings

          attr_reader :id, :experience, :shipping_configuration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :shipping_configuration], 'ExperienceLogisticsSettings')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceOverview) ? x : ::Io::Flow::V0::Models::ExperienceOverview.new(x))
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationReference) ? x : ::Io::Flow::V0::Models::ShippingConfigurationReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceLogisticsSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :shipping_configuration => shipping_configuration.to_hash
            }
          end

        end

        class ExperienceLogisticsSettingsDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :logistics_settings

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_LOGISTICS_SETTINGS_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :logistics_settings], 'ExperienceLogisticsSettingsDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @logistics_settings = (x = opts.delete(:logistics_settings); x.is_a?(::Io::Flow::V0::Models::ExperienceLogisticsSettings) ? x : ::Io::Flow::V0::Models::ExperienceLogisticsSettings.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceLogisticsSettingsDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :logistics_settings => logistics_settings.to_hash
            }
          end

        end

        # Assigns logistics related settings to an experience
        class ExperienceLogisticsSettingsPutForm

          attr_reader :shipping_configuration_key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:shipping_configuration_key], 'ExperienceLogisticsSettingsPutForm')
            @shipping_configuration_key = HttpClient::Preconditions.assert_class('shipping_configuration_key', opts.delete(:shipping_configuration_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceLogisticsSettingsPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :shipping_configuration_key => shipping_configuration_key
            }
          end

        end

        class ExperienceLogisticsSettingsUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :logistics_settings

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_LOGISTICS_SETTINGS_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :logistics_settings], 'ExperienceLogisticsSettingsUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @logistics_settings = (x = opts.delete(:logistics_settings); x.is_a?(::Io::Flow::V0::Models::ExperienceLogisticsSettings) ? x : ::Io::Flow::V0::Models::ExperienceLogisticsSettings.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceLogisticsSettingsUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :logistics_settings => logistics_settings.to_hash
            }
          end

        end

        class ExperienceLogisticsSummary

          attr_reader :outbound, :return_

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @outbound = (x = opts.delete(:outbound); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExperienceLogisticsTierSummary) ? x : ::Io::Flow::V0::Models::ExperienceLogisticsTierSummary.new(x)))
            @return_ = (x = opts.delete(:return); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExperienceLogisticsTierSummary) ? x : ::Io::Flow::V0::Models::ExperienceLogisticsTierSummary.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceLogisticsSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :outbound => outbound.nil? ? nil : outbound.to_hash,
              :return => return_.nil? ? nil : return_.to_hash
            }
          end

        end

        class ExperienceLogisticsTierSummary

          attr_reader :prices

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:prices], 'ExperienceLogisticsTierSummary')
            @prices = (x = opts.delete(:prices); x.is_a?(::Io::Flow::V0::Models::ExperienceLogisticsTierSummaryPrices) ? x : ::Io::Flow::V0::Models::ExperienceLogisticsTierSummaryPrices.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceLogisticsTierSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :prices => prices.to_hash
            }
          end

        end

        class ExperienceLogisticsTierSummaryPrices

          attr_reader :minimum

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:minimum], 'ExperienceLogisticsTierSummaryPrices')
            @minimum = (x = opts.delete(:minimum); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceLogisticsTierSummaryPrices.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :minimum => minimum.to_hash
            }
          end

        end

        class ExperienceOverview

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'ExperienceOverview')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceOverview.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        class ExperiencePaymentMethodRuleForm

          attr_reader :payment_method_id, :tags, :q

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:payment_method_id, :tags], 'ExperiencePaymentMethodRuleForm')
            @payment_method_id = HttpClient::Preconditions.assert_class('payment_method_id', opts.delete(:payment_method_id), String)
            @tags = HttpClient::Preconditions.assert_class('tags', opts.delete(:tags), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperiencePaymentMethodTag) ? x : ::Io::Flow::V0::Models::ExperiencePaymentMethodTag.apply(x)) }
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperiencePaymentMethodRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :payment_method_id => payment_method_id,
              :tags => tags.map { |o| o.value },
              :q => q
            }
          end

        end

        class ExperiencePriceBookMapping

          attr_reader :id, :experience, :price_book, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :price_book, :position], 'ExperiencePriceBookMapping')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @price_book = (x = opts.delete(:price_book); x.is_a?(::Io::Flow::V0::Models::PriceBookReference) ? x : ::Io::Flow::V0::Models::PriceBookReference.new(x))
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperiencePriceBookMapping.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :price_book => price_book.to_hash,
              :position => position
            }
          end

        end

        class ExperiencePriceBookMappingDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_PRICE_BOOK_MAPPING_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'ExperiencePriceBookMappingDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperiencePriceBookMappingDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class ExperiencePriceBookMappingForm

          attr_reader :price_book_key, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price_book_key], 'ExperiencePriceBookMappingForm')
            @price_book_key = HttpClient::Preconditions.assert_class('price_book_key', opts.delete(:price_book_key), String)
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperiencePriceBookMappingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price_book_key => price_book_key,
              :position => position
            }
          end

        end

        class ExperiencePriceBookMappingPutForm

          attr_reader :price_books

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price_books], 'ExperiencePriceBookMappingPutForm')
            @price_books = HttpClient::Preconditions.assert_class('price_books', opts.delete(:price_books), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperiencePriceBookMappingForm) ? x : ::Io::Flow::V0::Models::ExperiencePriceBookMappingForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperiencePriceBookMappingPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price_books => price_books.map { |o| o.to_hash }
            }
          end

        end

        class ExperiencePriceBookMappingUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_price_book_mapping

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_PRICE_BOOK_MAPPING_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_price_book_mapping], 'ExperiencePriceBookMappingUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_price_book_mapping = (x = opts.delete(:experience_price_book_mapping); x.is_a?(::Io::Flow::V0::Models::ExperiencePriceBookMapping) ? x : ::Io::Flow::V0::Models::ExperiencePriceBookMapping.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperiencePriceBookMappingUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_price_book_mapping => experience_price_book_mapping.to_hash
            }
          end

        end

        class ExperienceReference < ExpandableExperience

          attr_reader :key

          def initialize(incoming={})
            super(:discriminator => ExpandableExperience::Types::EXPERIENCE_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'ExperienceReference')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key
            }
          end

        end

        class ExperienceSettings

          attr_reader :delivered_duty, :pricing_settings, :logistics_settings, :checkout_settings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivered_duty], 'ExperienceSettings')
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDutySetting) ? x : ::Io::Flow::V0::Models::DeliveredDutySetting.new(x))
            @pricing_settings = (x = opts.delete(:pricing_settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PricingSettings) ? x : ::Io::Flow::V0::Models::PricingSettings.new(x)))
            @logistics_settings = (x = opts.delete(:logistics_settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LogisticsSettings) ? x : ::Io::Flow::V0::Models::LogisticsSettings.new(x)))
            @checkout_settings = (x = opts.delete(:checkout_settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CheckoutSettings) ? x : ::Io::Flow::V0::Models::CheckoutSettings.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivered_duty => delivered_duty.to_hash,
              :pricing_settings => pricing_settings.nil? ? nil : pricing_settings.to_hash,
              :logistics_settings => logistics_settings.nil? ? nil : logistics_settings.to_hash,
              :checkout_settings => checkout_settings.nil? ? nil : checkout_settings.to_hash
            }
          end

        end

        # The experience status form is used to update the status of a particular
        # experience.
        class ExperienceStatusForm

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'ExperienceStatusForm')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ExperienceStatus) ? x : ::Io::Flow::V0::Models::ExperienceStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceStatusForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value
            }
          end

        end

        # Some important fields related to experiences used in various APIs
        class ExperienceSummary

          attr_reader :id, :key, :name, :country, :currency, :language

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name], 'ExperienceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :country => country,
              :currency => currency,
              :language => language
            }
          end

        end

        class ExperienceUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :name, :delivered_duty, :subcatalog_id, :region_id, :country, :currency, :language, :measurement_system, :position, :status

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :name, :delivered_duty, :subcatalog_id, :region_id, :country, :currency, :language, :measurement_system, :position], 'ExperienceUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = HttpClient::Preconditions.assert_class('delivered_duty', opts.delete(:delivered_duty), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @region_id = HttpClient::Preconditions.assert_class('region_id', opts.delete(:region_id), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = HttpClient::Preconditions.assert_class('measurement_system', opts.delete(:measurement_system), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @status = (x = opts.delete(:status); x.nil? ? nil : HttpClient::Preconditions.assert_class('status', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :name => name,
              :delivered_duty => delivered_duty,
              :subcatalog_id => subcatalog_id,
              :region_id => region_id,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system,
              :position => position,
              :status => status
            }
          end

        end

        class ExperienceUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :experience

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience], 'ExperienceUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::Experience) ? x : ::Io::Flow::V0::Models::Experience.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience => experience.to_hash
            }
          end

        end

        class ExperienceVersion

          attr_reader :id, :timestamp, :type, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :experience], 'ExperienceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::Experience) ? x : ::Io::Flow::V0::Models::Experience.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :experience => experience.to_hash
            }
          end

        end

        # The month and year at which a card expires
        class Expiration

          attr_reader :month, :year

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:month, :year], 'Expiration')
            @month = HttpClient::Preconditions.assert_class('month', opts.delete(:month), Integer)
            @year = HttpClient::Preconditions.assert_class('year', opts.delete(:year), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Expiration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :month => month,
              :year => year
            }
          end

        end

        # Exports represent data extraction requests (e.g. download my catalog items to
        # a CSV file)
        class Export

          attr_reader :id, :type, :status, :organization_q, :created_at, :started_at, :completed_at, :url, :deliveries

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :status, :organization_q, :created_at, :deliveries], 'Export')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ExportStatus) ? x : ::Io::Flow::V0::Models::ExportStatus.apply(x))
            @organization_q = HttpClient::Preconditions.assert_class('organization_q', opts.delete(:organization_q), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @started_at = (x = opts.delete(:started_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('started_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @completed_at = (x = opts.delete(:completed_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('completed_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @url = (x = opts.delete(:url); x.nil? ? nil : HttpClient::Preconditions.assert_class('url', x, String))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportDelivery) ? x : ::Io::Flow::V0::Models::ExportDelivery.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Export.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.to_hash,
              :status => status.value,
              :organization_q => organization_q,
              :created_at => created_at,
              :started_at => started_at,
              :completed_at => completed_at,
              :url => url,
              :deliveries => deliveries.map { |o| o.to_hash }
            }
          end

        end

        # Triggers an email notification once the requested export is ready
        class ExportDeliveryEmail < ExportDelivery

          attr_reader :email

          def initialize(incoming={})
            super(:discriminator => ExportDelivery::Types::EXPORT_DELIVERY_EMAIL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'ExportDeliveryEmail')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportDeliveryEmail.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :email => email
            }
          end

        end

        # Export forms are used to create exports. The export type defines both the type
        # of the export (e.g. the CSV File format) and the available parameters for each
        # export (e.g. the filters to apply to select the desired data).
        class ExportForm

          attr_reader :type, :emails, :organization_q

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'ExportForm')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x))
            @emails = (x = opts.delete(:emails); x.nil? ? nil : HttpClient::Preconditions.assert_class('emails', x, Array).map { |v| HttpClient::Preconditions.assert_class('emails', v, String) })
            @organization_q = (x = opts.delete(:organization_q); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_q', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.to_hash,
              :emails => emails.nil? ? nil : emails,
              :organization_q => organization_q
            }
          end

        end

        class ExportLocalizedItemPrices

          attr_reader :organization, :experience, :item, :prices, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :experience, :item, :prices], 'ExportLocalizedItemPrices')
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::CatalogItemReference) ? x : ::Io::Flow::V0::Models::CatalogItemReference.new(x))
            @prices = (x = opts.delete(:prices); x.is_a?(::Io::Flow::V0::Models::ExportLocalizedItemPricesDetail) ? x : ::Io::Flow::V0::Models::ExportLocalizedItemPricesDetail.new(x))
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportLocalizedItemPrices.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization.to_hash,
              :experience => experience.to_hash,
              :item => item.to_hash,
              :prices => prices.to_hash,
              :status => status.nil? ? nil : status.value
            }
          end

        end

        class ExportLocalizedItemPricesDetail

          attr_reader :item, :vat, :duty, :price_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :price_attributes], 'ExportLocalizedItemPricesDetail')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::LocalizedItemPrice) ? x : ::Io::Flow::V0::Models::LocalizedItemPrice.new(x))
            @vat = (x = opts.delete(:vat); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedItemVat) ? x : ::Io::Flow::V0::Models::LocalizedItemVat.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedItemDuty) ? x : ::Io::Flow::V0::Models::LocalizedItemDuty.new(x)))
            @price_attributes = HttpClient::Preconditions.assert_class('price_attributes', opts.delete(:price_attributes), Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportLocalizedItemPricesDetail.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :vat => vat.nil? ? nil : vat.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash,
              :price_attributes => price_attributes.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        class ExportVersion

          attr_reader :id, :timestamp, :type, :export

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :export], 'ExportVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @export = (x = opts.delete(:export); x.is_a?(::Io::Flow::V0::Models::Export) ? x : ::Io::Flow::V0::Models::Export.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :export => export.to_hash
            }
          end

        end

        class ExternalApiTimeoutReservationError < ReservationError

          attr_reader :messages

          def initialize(incoming={})
            super(:code => ReservationError::Types::EXTERNAL_API_TIMEOUT_RESERVATION_ERROR)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages], 'ExternalApiTimeoutReservationError')
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExternalApiTimeoutReservationError.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :messages => messages
            }
          end

        end

        class FieldValidationMax < FieldValidationRule

          attr_reader :length

          def initialize(incoming={})
            super(:discriminator => FieldValidationRule::Types::FIELD_VALIDATION_MAX)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:length], 'FieldValidationMax')
            @length = HttpClient::Preconditions.assert_class('length', opts.delete(:length), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FieldValidationMax.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :length => length
            }
          end

        end

        class FieldValidationMin < FieldValidationRule

          attr_reader :length

          def initialize(incoming={})
            super(:discriminator => FieldValidationRule::Types::FIELD_VALIDATION_MIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:length], 'FieldValidationMin')
            @length = HttpClient::Preconditions.assert_class('length', opts.delete(:length), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FieldValidationMin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :length => length
            }
          end

        end

        class FieldValidationPattern < FieldValidationRule

          attr_reader :pattern

          def initialize(incoming={})
            super(:discriminator => FieldValidationRule::Types::FIELD_VALIDATION_PATTERN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:pattern], 'FieldValidationPattern')
            @pattern = HttpClient::Preconditions.assert_class('pattern', opts.delete(:pattern), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FieldValidationPattern.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :pattern => pattern
            }
          end

        end

        # Indicates a field is required
        class FieldValidationRequired < FieldValidationRule

          attr_reader :unused

          def initialize(incoming={})
            super(:discriminator => FieldValidationRule::Types::FIELD_VALIDATION_REQUIRED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:unused], 'FieldValidationRequired')
            @unused = HttpClient::Preconditions.assert_class('unused', opts.delete(:unused), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FieldValidationRequired.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :unused => unused
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is pre-defined flat rate
        class FlatRate < TierRuleOutcome

          attr_reader :price, :zero_amount_indicator

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::FLAT_RATE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'FlatRate')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @zero_amount_indicator = (x = opts.delete(:zero_amount_indicator); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ZeroAmountIndicator) ? x : ::Io::Flow::V0::Models::ZeroAmountIndicator.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlatRate.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash,
              :zero_amount_indicator => zero_amount_indicator.nil? ? nil : zero_amount_indicator.value
            }
          end

        end

        class FlatRateForm < TierRuleOutcomeForm

          attr_reader :price, :zero_amount_indicator

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcomeForm::Types::FLAT_RATE_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'FlatRateForm')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @zero_amount_indicator = (x = opts.delete(:zero_amount_indicator); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ZeroAmountIndicator) ? x : ::Io::Flow::V0::Models::ZeroAmountIndicator.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlatRateForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash,
              :zero_amount_indicator => zero_amount_indicator.nil? ? nil : zero_amount_indicator.value
            }
          end

        end

        class FlowCenterReference

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'FlowCenterReference')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlowCenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key
            }
          end

        end

        class FlowItemIndexMetadata

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'FlowItemIndexMetadata')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlowItemIndexMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value
            }
          end

        end

        # Rule to apply to enable white-listing and black-listing for an email address.
        class FraudEmailRule

          attr_reader :email, :decision

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email, :decision], 'FraudEmailRule')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @decision = (x = opts.delete(:decision); x.is_a?(::Io::Flow::V0::Models::FraudEmailRuleDecision) ? x : ::Io::Flow::V0::Models::FraudEmailRuleDecision.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FraudEmailRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :decision => decision.value
            }
          end

        end

        class FraudEmailRuleForm

          attr_reader :rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rule], 'FraudEmailRuleForm')
            @rule = (x = opts.delete(:rule); x.is_a?(::Io::Flow::V0::Models::FraudEmailRule) ? x : ::Io::Flow::V0::Models::FraudEmailRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FraudEmailRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rule => rule.to_hash
            }
          end

        end

        # Event emitted when the fraud status for an order changes.
        class FraudStatusChanged < Event

          attr_reader :event_id, :timestamp, :id, :organization, :order, :status

          def initialize(incoming={})
            super(:discriminator => Event::Types::FRAUD_STATUS_CHANGED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :organization, :order, :status], 'FraudStatusChanged')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderReference) ? x : ::Io::Flow::V0::Models::OrderReference.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::FraudStatus) ? x : ::Io::Flow::V0::Models::FraudStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FraudStatusChanged.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :organization => organization,
              :order => order.to_hash,
              :status => status.value
            }
          end

        end

        class FreeShipping < Promotion

          attr_reader :trigger, :max

          def initialize(incoming={})
            super(:discriminator => Promotion::Types::FREE_SHIPPING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:trigger], 'FreeShipping')
            @trigger = (x = opts.delete(:trigger); x.is_a?(::Io::Flow::V0::Models::PromotionTrigger) ? x : ::Io::Flow::V0::Models::PromotionTrigger.new(x))
            @max = (x = opts.delete(:max); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FreeShipping.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :trigger => trigger.to_hash,
              :max => max.nil? ? nil : max.to_hash
            }
          end

        end

        class FreeShippingOrderPromotion < OrderPromotion

          attr_reader :id, :order, :key, :trigger, :max, :attributes

          def initialize(incoming={})
            super(:discriminator => OrderPromotion::Types::FREE_SHIPPING_ORDER_PROMOTION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order, :key, :trigger, :attributes], 'FreeShippingOrderPromotion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::ExpandableOrder) ? x : ::Io::Flow::V0::Models::ExpandableOrder.from_json(x))
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @trigger = (x = opts.delete(:trigger); x.is_a?(::Io::Flow::V0::Models::OrderPromotionTrigger) ? x : ::Io::Flow::V0::Models::OrderPromotionTrigger.new(x))
            @max = (x = opts.delete(:max); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FreeShippingOrderPromotion.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :order => order.to_hash,
              :key => key,
              :trigger => trigger.to_hash,
              :max => max.nil? ? nil : max.to_hash,
              :attributes => attributes
            }
          end

        end

        class FreeShippingOrderPromotionForm < OrderPromotionForm

          attr_reader :trigger, :max, :attributes

          def initialize(incoming={})
            super(:discriminator => OrderPromotionForm::Types::FREE_SHIPPING_ORDER_PROMOTION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:trigger], 'FreeShippingOrderPromotionForm')
            @trigger = (x = opts.delete(:trigger); x.is_a?(::Io::Flow::V0::Models::PromotionTriggerForm) ? x : ::Io::Flow::V0::Models::PromotionTriggerForm.new(x))
            @max = (x = opts.delete(:max); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceForm) ? x : ::Io::Flow::V0::Models::PriceForm.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FreeShippingOrderPromotionForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :trigger => trigger.to_hash,
              :max => max.nil? ? nil : max.to_hash,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # The FTP Account is your username and password to access this FTP server.
        class FtpAccount

          attr_reader :server, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:server, :user], 'FtpAccount')
            @server = (x = opts.delete(:server); x.is_a?(::Io::Flow::V0::Models::FtpServer) ? x : ::Io::Flow::V0::Models::FtpServer.new(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::FtpUser) ? x : ::Io::Flow::V0::Models::FtpUser.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpAccount.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :server => server.to_hash,
              :user => user.to_hash
            }
          end

        end

        # The FTP File represents a file uploaded to the FTP Server
        class FtpFile

          attr_reader :id, :source, :name, :directory, :url, :created_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :source, :name, :directory, :url, :created_at], 'FtpFile')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @source = (x = opts.delete(:source); x.is_a?(::Io::Flow::V0::Models::FtpFileSource) ? x : ::Io::Flow::V0::Models::FtpFileSource.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @directory = HttpClient::Preconditions.assert_class('directory', opts.delete(:directory), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpFile.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :source => source.value,
              :name => name,
              :directory => directory,
              :url => url,
              :created_at => created_at
            }
          end

        end

        # Create a file that will be uploaded to this organization's FTP Server
        class FtpFileForm

          attr_reader :url, :directory, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url, :directory], 'FtpFileForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @directory = HttpClient::Preconditions.assert_class('directory', opts.delete(:directory), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpFileForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :directory => directory,
              :name => name
            }
          end

        end

        # The FTP Folder represents a single folder associated with an organization for
        # which we create an external FTP Directory
        class FtpFolder

          attr_reader :id, :path, :webhook, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :path, :webhook], 'FtpFolder')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @path = HttpClient::Preconditions.assert_class('path', opts.delete(:path), String)
            @webhook = HttpClient::Preconditions.assert_boolean('webhook', opts.delete(:webhook))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpFolder.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :path => path,
              :webhook => webhook,
              :description => description
            }
          end

        end

        class FtpFolderForm

          attr_reader :path, :webhook, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:path], 'FtpFolderForm')
            @path = HttpClient::Preconditions.assert_class('path', opts.delete(:path), String)
            @webhook = HttpClient::Preconditions.assert_boolean('webhook', (x = opts.delete(:webhook); x.nil? ? false : x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpFolderForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :path => path,
              :webhook => webhook,
              :description => description
            }
          end

        end

        # The FTP Organization Settings allows you to enable an FTP Drop Point for an
        # organization, creating the standard set of FTP Folders, credentials, and
        # associated webhooks.
        class FtpOrganizationSettings

          attr_reader :enabled, :emails, :account

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:enabled, :emails], 'FtpOrganizationSettings')
            @enabled = HttpClient::Preconditions.assert_boolean('enabled', opts.delete(:enabled))
            @emails = HttpClient::Preconditions.assert_class('emails', opts.delete(:emails), Array).map { |v| HttpClient::Preconditions.assert_class('emails', v, String) }
            @account = (x = opts.delete(:account); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::FtpAccount) ? x : ::Io::Flow::V0::Models::FtpAccount.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpOrganizationSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :enabled => enabled,
              :emails => emails,
              :account => account.nil? ? nil : account.to_hash
            }
          end

        end

        class FtpOrganizationSettingsForm

          attr_reader :enabled, :emails

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @enabled = HttpClient::Preconditions.assert_boolean('enabled', (x = opts.delete(:enabled); x.nil? ? false : x))
            @emails = HttpClient::Preconditions.assert_class('emails', (x = opts.delete(:emails); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('emails', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpOrganizationSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :enabled => enabled,
              :emails => emails
            }
          end

        end

        class FtpServer

          attr_reader :hostname

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:hostname], 'FtpServer')
            @hostname = HttpClient::Preconditions.assert_class('hostname', opts.delete(:hostname), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpServer.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :hostname => hostname
            }
          end

        end

        class FtpUser

          attr_reader :username, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:username], 'FtpUser')
            @username = HttpClient::Preconditions.assert_class('username', opts.delete(:username), String)
            @password = (x = opts.delete(:password); x.nil? ? nil : HttpClient::Preconditions.assert_class('password', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FtpUser.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :username => username,
              :password => password
            }
          end

        end

        class FuelSurchargeRatecardFee < RatecardFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => RatecardFee::Types::FUEL_SURCHARGE_RATECARD_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'FuelSurchargeRatecardFee')
            @amount = (x = opts.delete(:amount); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FuelSurchargeRatecardFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_hash
            }
          end

        end

        class FuelSurchargeServiceFee < ServiceFee

          attr_reader :percent

          def initialize(incoming={})
            super(:discriminator => ServiceFee::Types::FUEL_SURCHARGE_SERVICE_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:percent], 'FuelSurchargeServiceFee')
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FuelSurchargeServiceFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :percent => percent.to_f.to_s
            }
          end

        end

        # Used to track and manage the fulfillment of an order.
        class Fulfillment

          attr_reader :organization, :key, :number, :items, :center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :key, :number, :items], 'Fulfillment')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FulfillmentItem) ? x : ::Io::Flow::V0::Models::FulfillmentItem.new(x)) }
            @center = (x = opts.delete(:center); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CenterSummary) ? x : ::Io::Flow::V0::Models::CenterSummary.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Fulfillment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :key => key,
              :number => number,
              :items => items.map { |o| o.to_hash },
              :center => center.nil? ? nil : center.to_hash
            }
          end

        end

        # Changing an order for the purpose of cancelling specific line quantities
        class FulfillmentCancellationForm

          attr_reader :change_source, :reason, :lines

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:reason, :lines], 'FulfillmentCancellationForm')
            @change_source = (x = (x = opts.delete(:change_source); x.nil? ? "fulfillment" : x); x.is_a?(::Io::Flow::V0::Models::OrderChangeSource) ? x : ::Io::Flow::V0::Models::OrderChangeSource.apply(x))
            @reason = (x = opts.delete(:reason); x.is_a?(::Io::Flow::V0::Models::CancelReason) ? x : ::Io::Flow::V0::Models::CancelReason.apply(x))
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FulfillmentLineCancelForm) ? x : ::Io::Flow::V0::Models::FulfillmentLineCancelForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentCancellationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :change_source => change_source.value,
              :reason => reason.value,
              :lines => lines.map { |o| o.to_hash }
            }
          end

        end

        # Changing an order for the purpose of completely cancelling all remaining
        # uncancelled, unshipped lines of an order.
        class FulfillmentCompleteCancellationForm

          attr_reader :change_source, :reason

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:reason], 'FulfillmentCompleteCancellationForm')
            @change_source = (x = (x = opts.delete(:change_source); x.nil? ? "fulfillment" : x); x.is_a?(::Io::Flow::V0::Models::OrderChangeSource) ? x : ::Io::Flow::V0::Models::OrderChangeSource.apply(x))
            @reason = (x = opts.delete(:reason); x.is_a?(::Io::Flow::V0::Models::CancelReason) ? x : ::Io::Flow::V0::Models::CancelReason.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentCompleteCancellationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :change_source => change_source.value,
              :reason => reason.value
            }
          end

        end

        class FulfillmentExperienceReference

          attr_reader :id, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :currency], 'FulfillmentExperienceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :currency => currency
            }
          end

        end

        # Used to track and manage the fulfillment of quantities of a sku
        class FulfillmentItem

          attr_reader :item_number, :line_number, :quantities

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :line_number, :quantities], 'FulfillmentItem')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @line_number = HttpClient::Preconditions.assert_class('line_number', opts.delete(:line_number), Integer)
            @quantities = HttpClient::Preconditions.assert_class('quantities', opts.delete(:quantities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FulfillmentItemQuantity) ? x : ::Io::Flow::V0::Models::FulfillmentItemQuantity.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :line_number => line_number,
              :quantities => quantities.map { |o| o.to_hash }
            }
          end

        end

        # Details about how prices were allocated to a fulfillment; use for reporting
        # the value or net value of a line
        class FulfillmentItemAllocationDetails

          attr_reader :item_number, :line_number, :levies, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :line_number, :levies, :total], 'FulfillmentItemAllocationDetails')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @line_number = HttpClient::Preconditions.assert_class('line_number', opts.delete(:line_number), Integer)
            @levies = (x = opts.delete(:levies); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentItemAllocationDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :line_number => line_number,
              :levies => levies.to_hash,
              :total => total.to_hash
            }
          end

        end

        # Fulfillment status of item quantities
        class FulfillmentItemQuantity

          attr_reader :status, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status, :quantity], 'FulfillmentItemQuantity')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::FulfillmentItemQuantityStatus) ? x : ::Io::Flow::V0::Models::FulfillmentItemQuantityStatus.apply(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentItemQuantity.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value,
              :quantity => quantity
            }
          end

        end

        # At least one of item_number, line_number are required. If you can, send both.
        class FulfillmentLineCancelForm

          attr_reader :item_number, :line_number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'FulfillmentLineCancelForm')
            @item_number = (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, String))
            @line_number = (x = opts.delete(:line_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('line_number', x, String))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentLineCancelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :line_number => line_number,
              :quantity => quantity
            }
          end

        end

        # Event indicating insertion or changes to the details of a fully harmonized
        # item. Will be triggered upon any change to the item being harmonized, its
        # duties or taxes. If two changes occur within minutes of each other, it is
        # possible only one upserted event will be produced, aggregating both changes.
        class FullyHarmonizedItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :item_number, :customs_description, :hs6_code, :landed_costs

          def initialize(incoming={})
            super(:discriminator => Event::Types::FULLY_HARMONIZED_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :item_number, :customs_description, :hs6_code, :landed_costs], 'FullyHarmonizedItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @customs_description = HttpClient::Preconditions.assert_class('customs_description', opts.delete(:customs_description), String)
            @hs6_code = HttpClient::Preconditions.assert_class('hs6_code', opts.delete(:hs6_code), String)
            @landed_costs = HttpClient::Preconditions.assert_class('landed_costs', opts.delete(:landed_costs), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LaneLandedCost) ? x : ::Io::Flow::V0::Models::LaneLandedCost.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FullyHarmonizedItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :item_number => item_number,
              :customs_description => customs_description,
              :hs6_code => hs6_code,
              :landed_costs => landed_costs.map { |o| o.to_hash }
            }
          end

        end

        # An error of some type has occurred. The most common error will be validation
        # on input. See messages for details.
        class GenericError

          attr_reader :code, :messages

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages], 'GenericError')
            @code = (x = (x = opts.delete(:code); x.nil? ? "generic_error" : x); x.is_a?(::Io::Flow::V0::Models::GenericErrorCode) ? x : ::Io::Flow::V0::Models::GenericErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            GenericError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages
            }
          end

        end

        class GenericReservationError < ReservationError

          attr_reader :messages

          def initialize(incoming={})
            super(:code => ReservationError::Types::GENERIC_RESERVATION_ERROR)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages], 'GenericReservationError')
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            GenericReservationError.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :messages => messages
            }
          end

        end

        # Form used to update geographic preferences
        class GeoForm

          attr_reader :country, :currency, :language, :locale, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :currency, :language, :locale, :experience], 'GeoForm')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            GeoForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country,
              :currency => currency,
              :language => language,
              :locale => locale,
              :experience => experience
            }
          end

        end

        class GooglePayAuthorizationPayload < AuthorizationPayloadParameters

          attr_reader :payload

          def initialize(incoming={})
            super(:discriminator => AuthorizationPayloadParameters::Types::GOOGLE_PAY_AUTHORIZATION_PAYLOAD)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:payload], 'GooglePayAuthorizationPayload')
            @payload = HttpClient::Preconditions.assert_class('payload', HttpClient::Helper.to_object(opts.delete(:payload)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            GooglePayAuthorizationPayload.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :payload => payload
            }
          end

        end

        class HarmonizationDocument < Document

          attr_reader :code, :categories, :origin

          def initialize(incoming={})
            super(:discriminator => Document::Types::HARMONIZATION_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :categories], 'HarmonizationDocument')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CategorySummary) ? x : ::Io::Flow::V0::Models::CategorySummary.new(x)) }
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :code => code,
              :categories => categories.map { |o| o.to_hash },
              :origin => origin
            }
          end

        end

        # Exports harmonization HS10 codes
        class HarmonizationHs10ExportType < ExportType

          attr_reader :origin, :destination, :numbers, :has_codes, :has_origins, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::HARMONIZATION_HS10_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String))
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @has_codes = (x = opts.delete(:has_codes); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_codes', x))
            @has_origins = (x = opts.delete(:has_origins); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_origins', x))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationHs10ExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :origin => origin,
              :destination => destination,
              :numbers => numbers.nil? ? nil : numbers,
              :has_codes => has_codes,
              :has_origins => has_origins,
              :sort => sort
            }
          end

        end

        # Exports HS6 codes
        class HarmonizationHs6ExportType < ExportType

          attr_reader :numbers, :has_codes, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::HARMONIZATION_HS6_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @has_codes = (x = opts.delete(:has_codes); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_codes', x))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationHs6ExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :has_codes => has_codes,
              :sort => sort
            }
          end

        end

        # Export for landed cost items.
        class HarmonizationLandedCostExportType < ExportType

          attr_reader :items

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::HARMONIZATION_LANDED_COST_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'HarmonizationLandedCostExportType')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LandedCostItem) ? x : ::Io::Flow::V0::Models::LandedCostItem.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationLandedCostExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        # Exports HS10 code overview details
        class HarmonizationOverviewExportType < ExportType

          attr_reader :origin, :destination, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::HARMONIZATION_OVERVIEW_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationOverviewExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :origin => origin,
              :destination => destination,
              :sort => sort
            }
          end

        end

        # Categories optimized for harmonization
        class HarmonizedCategory

          attr_reader :id, :name, :parent

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'HarmonizedCategory')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @parent = (x = opts.delete(:parent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::HarmonizedCategoryReference) ? x : ::Io::Flow::V0::Models::HarmonizedCategoryReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedCategory.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :parent => parent.nil? ? nil : parent.to_hash
            }
          end

        end

        class HarmonizedCategoryReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'HarmonizedCategoryReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedCategoryReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # A harmonized item stores explicit information about this item for the purposes
        # of harmonization / classification. The harmonization process begins by
        # creating a harmonized item; this kicks off the internal processes. Once
        # assigned, codes will be available via the hs6 and hs10 resources
        class HarmonizedItem

          attr_reader :id, :number, :name, :categories, :attributes, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :name], 'HarmonizedItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :name => name,
              :categories => categories,
              :attributes => attributes,
              :description => description
            }
          end

        end

        class HarmonizedItemForm

          attr_reader :name, :number, :currency, :price, :categories, :description, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :number, :currency, :price], 'HarmonizedItemForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :number => number,
              :currency => currency,
              :price => price,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class HarmonizedItemPutForm

          attr_reader :name, :currency, :price, :categories, :description, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :currency, :price], 'HarmonizedItemPutForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class HarmonizedItemReference

          attr_reader :id, :number, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'HarmonizedItemReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :description => description
            }
          end

        end

        # Summary of landed cost data (taxes and duties) for 1 or more items going to a
        # single destination country. Records are unique based on (item.number, country
        # of origin).
        class HarmonizedLandedCost

          attr_reader :address, :items, :tax_registration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :items], 'HarmonizedLandedCost')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::HarmonizedLandedCostItem) ? x : ::Io::Flow::V0::Models::HarmonizedLandedCostItem.new(x)) }
            @tax_registration = (x = opts.delete(:tax_registration); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TaxRegistration) ? x : ::Io::Flow::V0::Models::TaxRegistration.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCost.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :items => items.map { |o| o.to_hash },
              :tax_registration => tax_registration.nil? ? nil : tax_registration.to_hash
            }
          end

        end

        # Allows calculation of duty and tax for multiple items in one API call for
        # items going to a specific destination country
        class HarmonizedLandedCostForm

          attr_reader :address, :item_numbers, :source_address, :order_number, :line_items, :tax_registration_id, :billing_address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :item_numbers], 'HarmonizedLandedCostForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @item_numbers = HttpClient::Preconditions.assert_class('item_numbers', opts.delete(:item_numbers), Array).map { |v| HttpClient::Preconditions.assert_class('item_numbers', v, String) }
            @source_address = (x = opts.delete(:source_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @line_items = (x = opts.delete(:line_items); x.nil? ? nil : HttpClient::Preconditions.assert_class('line_items', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItem) ? x : ::Io::Flow::V0::Models::LineItem.new(x)) })
            @tax_registration_id = (x = opts.delete(:tax_registration_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tax_registration_id', x, String))
            @billing_address = (x = opts.delete(:billing_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCostForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :item_numbers => item_numbers,
              :source_address => source_address.nil? ? nil : source_address.to_hash,
              :order_number => order_number,
              :line_items => line_items.nil? ? nil : line_items.map { |o| o.to_hash },
              :tax_registration_id => tax_registration_id,
              :billing_address => billing_address.nil? ? nil : billing_address.to_hash
            }
          end

        end

        # Duty and tax information for a given item. Note that the internal
        # implementation supports multiple countries of origin.
        class HarmonizedLandedCostItem

          attr_reader :item, :duty, :tax, :tax_applicability

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :duty, :tax], 'HarmonizedLandedCostItem')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x))
            @tax = (x = opts.delete(:tax); x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x))
            @tax_applicability = (x = opts.delete(:tax_applicability); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TaxApplicability) ? x : ::Io::Flow::V0::Models::TaxApplicability.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCostItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :duty => duty.to_hash,
              :tax => tax.to_hash,
              :tax_applicability => tax_applicability.nil? ? nil : tax_applicability.value
            }
          end

        end

        class HarmonizedLandedCostUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :landed_cost

          def initialize(incoming={})
            super(:discriminator => Event::Types::HARMONIZED_LANDED_COST_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :landed_cost], 'HarmonizedLandedCostUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @landed_cost = (x = opts.delete(:landed_cost); x.is_a?(::Io::Flow::V0::Models::HarmonizedLandedCost) ? x : ::Io::Flow::V0::Models::HarmonizedLandedCost.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCostUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :landed_cost => landed_cost.to_hash
            }
          end

        end

        class Header

          attr_reader :name, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :value], 'Header')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Header.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :value => value
            }
          end

        end

        class Healthcheck

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Healthcheck')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Healthcheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        class Hop

          attr_reader :hop_number, :hop_estimate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:hop_number, :hop_estimate], 'Hop')
            @hop_number = HttpClient::Preconditions.assert_class('hop_number', opts.delete(:hop_number), Integer)
            @hop_estimate = (x = opts.delete(:hop_estimate); x.is_a?(::Io::Flow::V0::Models::HopEstimate) ? x : ::Io::Flow::V0::Models::HopEstimate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hop.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :hop_number => hop_number,
              :hop_estimate => hop_estimate.to_hash
            }
          end

        end

        class HopEstimate

          attr_reader :origin_address, :destination_address, :service, :shipment_window, :currency, :amount, :fees, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:origin_address, :destination_address, :service, :shipment_window, :currency, :amount, :fees, :total], 'HopEstimate')
            @origin_address = (x = opts.delete(:origin_address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @destination_address = (x = opts.delete(:destination_address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::RatecardServiceSummary) ? x : ::Io::Flow::V0::Models::RatecardServiceSummary.new(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @fees = HttpClient::Preconditions.assert_class('fees', opts.delete(:fees), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardFee) ? x : ::Io::Flow::V0::Models::RatecardFee.from_json(x)) }
            @total = HttpClient::Preconditions.assert_class('total', opts.delete(:total), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HopEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin_address => origin_address.to_hash,
              :destination_address => destination_address.to_hash,
              :service => service.to_hash,
              :shipment_window => shipment_window.to_hash,
              :currency => currency,
              :amount => amount,
              :fees => fees.map { |o| o.to_hash },
              :total => total
            }
          end

        end

        # The (Harmonized System) HS-10 code assigned to an item with a given
        # origin/destination pair.
        class Hs10

          attr_reader :id, :item, :origin, :destination, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :code], 'Hs10')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :code => code
            }
          end

        end

        # Event raised whenever an HS-10 code is unassigned from an item
        class Hs10CodeDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin, :destination

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS10_CODE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin, :destination], 'Hs10CodeDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10CodeDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin,
              :destination => destination
            }
          end

        end

        # Event raised whenever an HS-10 code is assigned to an item
        class Hs10CodeUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin, :destination, :code

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS10_CODE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin, :destination, :code], 'Hs10CodeUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10CodeUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin,
              :destination => destination,
              :code => code
            }
          end

        end

        class Hs10Version

          attr_reader :id, :timestamp, :type, :hs10

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs10], 'Hs10Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs10 = (x = opts.delete(:hs10); x.is_a?(::Io::Flow::V0::Models::Hs10) ? x : ::Io::Flow::V0::Models::Hs10.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs10 => hs10.to_hash
            }
          end

        end

        # The (Harmonized System) HS-6 code assigned to an item.
        class Hs6

          attr_reader :id, :item, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :code], 'Hs6')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :code => code
            }
          end

        end

        # Event raised whenever an HS-6 code is deleted
        class Hs6CodeDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS6_CODE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number], 'Hs6CodeDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6CodeDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number
            }
          end

        end

        # Event raised whenever an HS-6 code is assigned to an item
        class Hs6CodeUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :code

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS6_CODE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :code], 'Hs6CodeUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6CodeUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :code => code
            }
          end

        end

        class IdentifierForm

          attr_reader :primary

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @primary = (x = opts.delete(:primary); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('primary', x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            IdentifierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :primary => primary
            }
          end

        end

        # The URL to an image, with optional tags. Flow Commerce primarily uses images
        # to enhance the administrative tools (e.g. showing an item image in console)
        class Image

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'Image')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = HttpClient::Preconditions.assert_class('tags', (x = opts.delete(:tags); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageTag) ? x : ::Io::Flow::V0::Models::ImageTag.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Image.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags.map { |o| o.value }
            }
          end

        end

        # Image form defines the data needed to create an image
        class ImageForm

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'ImageForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = (x = opts.delete(:tags); x.nil? ? nil : HttpClient::Preconditions.assert_class('tags', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageTag) ? x : ::Io::Flow::V0::Models::ImageTag.apply(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImageForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags.nil? ? nil : tags.map { |o| o.value }
            }
          end

        end

        # Imports allow you to upload data to Flow via files in batch. Each import
        # fetches data from a given URL. The type of the import determines which file
        # format to expect and what data to update
        class Import

          attr_reader :id, :type, :source_url, :filename, :status, :created_at, :started_at, :completed_at, :results, :deliveries

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :source_url, :filename, :status, :created_at, :deliveries], 'Import')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ImportType) ? x : ::Io::Flow::V0::Models::ImportType.apply(x))
            @source_url = HttpClient::Preconditions.assert_class('source_url', opts.delete(:source_url), String)
            @filename = HttpClient::Preconditions.assert_class('filename', opts.delete(:filename), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ExportStatus) ? x : ::Io::Flow::V0::Models::ExportStatus.apply(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @started_at = (x = opts.delete(:started_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('started_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @completed_at = (x = opts.delete(:completed_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('completed_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @results = (x = opts.delete(:results); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ImportResults) ? x : ::Io::Flow::V0::Models::ImportResults.new(x)))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportDelivery) ? x : ::Io::Flow::V0::Models::ExportDelivery.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Import.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :source_url => source_url,
              :filename => filename,
              :status => status.value,
              :created_at => created_at,
              :started_at => started_at,
              :completed_at => completed_at,
              :results => results.nil? ? nil : results.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash }
            }
          end

        end

        # Import forms create imports. The import type defines both the type of the
        # import (e.g. the CSV File format) and the URL at which the source data are
        # available. If you do not have a URL readily available, you can first upload a
        # file via the Flow API - see the resource named 'Upload'
        class ImportForm

          attr_reader :type, :source_url, :filename, :emails

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :source_url], 'ImportForm')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ImportType) ? x : ::Io::Flow::V0::Models::ImportType.apply(x))
            @source_url = HttpClient::Preconditions.assert_class('source_url', opts.delete(:source_url), String)
            @filename = (x = opts.delete(:filename); x.nil? ? nil : HttpClient::Preconditions.assert_class('filename', x, String))
            @emails = (x = opts.delete(:emails); x.nil? ? nil : HttpClient::Preconditions.assert_class('emails', x, Array).map { |v| HttpClient::Preconditions.assert_class('emails', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :source_url => source_url,
              :filename => filename,
              :emails => emails.nil? ? nil : emails
            }
          end

        end

        class ImportResults

          attr_reader :number_successful, :number_errors, :url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number_successful, :number_errors], 'ImportResults')
            @number_successful = HttpClient::Preconditions.assert_class('number_successful', opts.delete(:number_successful), Integer)
            @number_errors = HttpClient::Preconditions.assert_class('number_errors', opts.delete(:number_errors), Integer)
            @url = (x = opts.delete(:url); x.nil? ? nil : HttpClient::Preconditions.assert_class('url', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportResults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number_successful => number_successful,
              :number_errors => number_errors,
              :url => url
            }
          end

        end

        # An import template provides an organization specific example CSV file of a
        # particular import type.
        class ImportTemplate

          attr_reader :type, :documentation_url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :documentation_url], 'ImportTemplate')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ImportType) ? x : ::Io::Flow::V0::Models::ImportType.apply(x))
            @documentation_url = HttpClient::Preconditions.assert_class('documentation_url', opts.delete(:documentation_url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportTemplate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :documentation_url => documentation_url
            }
          end

        end

        # An import template example provides a link to a real, organization specific
        # example CSV import file.
        class ImportTemplateExample

          attr_reader :url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'ImportTemplateExample')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportTemplateExample.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url
            }
          end

        end

        class ImportTemplateForm

          attr_reader :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'ImportTemplateForm')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ImportType) ? x : ::Io::Flow::V0::Models::ImportType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportTemplateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value
            }
          end

        end

        class ImportVersion

          attr_reader :id, :timestamp, :type, :import

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :import], 'ImportVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @import = (x = opts.delete(:import); x.is_a?(::Io::Flow::V0::Models::Import) ? x : ::Io::Flow::V0::Models::Import.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :import => import.to_hash
            }
          end

        end

        class InboundCartonFee < PartnerCenterFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => PartnerCenterFee::Types::INBOUND_CARTON_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'InboundCartonFee')
            @amount = (x = opts.delete(:amount); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InboundCartonFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_hash
            }
          end

        end

        class IncludedLevies

          attr_reader :key, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :label], 'IncludedLevies')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::IncludedLevyKey) ? x : ::Io::Flow::V0::Models::IncludedLevyKey.apply(x))
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            IncludedLevies.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :label => label
            }
          end

        end

        # Represents an online payment that requires the client token from underlying
        # payment processor before entering their payment information.
        class InlineAuthorizationDetails < OnlineAuthorizationDetails

          attr_reader :id, :client_token, :parameters

          def initialize(incoming={})
            super(:discriminator => OnlineAuthorizationDetails::Types::INLINE_AUTHORIZATION_DETAILS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'InlineAuthorizationDetails')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @client_token = (x = opts.delete(:client_token); x.nil? ? nil : HttpClient::Preconditions.assert_class('client_token', x, String))
            @parameters = (x = opts.delete(:parameters); x.nil? ? nil : HttpClient::Preconditions.assert_class('parameters', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InlineAuthorizationDetails.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :client_token => client_token,
              :parameters => parameters
            }
          end

        end

        # Executes a widget-based payment based on the provided payment method.
        class InlineAuthorizationForm < AuthorizationForm

          attr_reader :method, :issuer, :order_number, :amount, :currency, :billing_address, :key, :attributes, :ip, :payload

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::INLINE_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:method, :order_number, :amount, :currency], 'InlineAuthorizationForm')
            @method = HttpClient::Preconditions.assert_class('method', opts.delete(:method), String)
            @issuer = (x = opts.delete(:issuer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::IssuerReference) ? x : ::Io::Flow::V0::Models::IssuerReference.new(x)))
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @billing_address = (x = opts.delete(:billing_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @payload = (x = opts.delete(:payload); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationPayload) ? x : ::Io::Flow::V0::Models::AuthorizationPayload.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InlineAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :method => method,
              :issuer => issuer.nil? ? nil : issuer.to_hash,
              :order_number => order_number,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :billing_address => billing_address.nil? ? nil : billing_address.to_hash,
              :key => key,
              :attributes => attributes.nil? ? nil : attributes,
              :ip => ip,
              :payload => payload.nil? ? nil : payload.to_hash
            }
          end

        end

        class InputForm

          attr_reader :values

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @values = (x = opts.delete(:values); x.nil? ? nil : HttpClient::Preconditions.assert_class('values', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('values', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InputForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :values => values.nil? ? nil : values
            }
          end

        end

        class InputFormSpecification

          attr_reader :inputs, :limitations

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @inputs = (x = opts.delete(:inputs); x.nil? ? nil : HttpClient::Preconditions.assert_class('inputs', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::InputSpecification) ? x : ::Io::Flow::V0::Models::InputSpecification.new(x)) })
            @limitations = (x = opts.delete(:limitations); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::InputSpecificationLimitations) ? x : ::Io::Flow::V0::Models::InputSpecificationLimitations.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InputFormSpecification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :inputs => inputs.nil? ? nil : inputs.map { |o| o.to_hash },
              :limitations => limitations.nil? ? nil : limitations.to_hash
            }
          end

        end

        class InputSpecification

          attr_reader :type, :name, :display_text

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :name], 'InputSpecification')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::InputSpecificationType) ? x : ::Io::Flow::V0::Models::InputSpecificationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @display_text = (x = opts.delete(:display_text); x.nil? ? nil : HttpClient::Preconditions.assert_class('display_text', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InputSpecification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :name => name,
              :display_text => display_text
            }
          end

        end

        # Represents the maximum number of accepted inputs
        class InputSpecificationLimitationMax < InputSpecificationLimitation

          attr_reader :max

          def initialize(incoming={})
            super(:discriminator => InputSpecificationLimitation::Types::INPUT_SPECIFICATION_LIMITATION_MAX)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:max], 'InputSpecificationLimitationMax')
            @max = HttpClient::Preconditions.assert_class('max', opts.delete(:max), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InputSpecificationLimitationMax.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :max => max
            }
          end

        end

        class InputSpecificationLimitations

          attr_reader :limitations

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @limitations = (x = opts.delete(:limitations); x.nil? ? nil : HttpClient::Preconditions.assert_class('limitations', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::InputSpecificationLimitation) ? x : ::Io::Flow::V0::Models::InputSpecificationLimitation.from_json(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InputSpecificationLimitations.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :limitations => limitations.nil? ? nil : limitations.map { |o| o.to_hash }
            }
          end

        end

        class InstallmentPlanPaymentError

          attr_reader :code, :messages, :codes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages, :codes], 'InstallmentPlanPaymentError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::InstallmentPlanPaymentErrorCode) ? x : ::Io::Flow::V0::Models::InstallmentPlanPaymentErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @codes = HttpClient::Preconditions.assert_class('codes', opts.delete(:codes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::InstallmentPlanPaymentErrorCode) ? x : ::Io::Flow::V0::Models::InstallmentPlanPaymentErrorCode.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InstallmentPlanPaymentError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :codes => codes.map { |o| o.value }
            }
          end

        end

        # The installment payment form is used to create an installment plan for an
        # order, associating the plan immediately with this order.
        class InstallmentPlanPaymentForm

          attr_reader :installment_program_id, :authorization_key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:installment_program_id, :authorization_key], 'InstallmentPlanPaymentForm')
            @installment_program_id = HttpClient::Preconditions.assert_class('installment_program_id', opts.delete(:installment_program_id), String)
            @authorization_key = HttpClient::Preconditions.assert_class('authorization_key', opts.delete(:authorization_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InstallmentPlanPaymentForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :installment_program_id => installment_program_id,
              :authorization_key => authorization_key
            }
          end

        end

        class InstallmentProgramSummary

          attr_reader :id, :name, :initial

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :initial], 'InstallmentProgramSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @initial = (x = opts.delete(:initial); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InstallmentProgramSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :initial => initial.to_hash
            }
          end

        end

        # Enables backorders, setting an optional number of units that we allow for
        # backorder. For example, a backorder w/ quantity 10 will enable selling until
        # the actual inventory quantity is -10.
        class InventoryBackorder < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:discriminator => InventoryStrategy::Types::INVENTORY_BACKORDER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryBackorder')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryBackorder.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        class InventoryCenterReference

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'InventoryCenterReference')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryCenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key
            }
          end

        end

        class InventoryCheckResponse

          attr_reader :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'InventoryCheckResponse')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::InventoryCheckResponseItem) ? x : ::Io::Flow::V0::Models::InventoryCheckResponseItem.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryCheckResponse.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class InventoryCheckResponseItem

          attr_reader :number, :quantity, :inventory_status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity, :inventory_status], 'InventoryCheckResponseItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @inventory_status = (x = opts.delete(:inventory_status); x.is_a?(::Io::Flow::V0::Models::InventoryStatus) ? x : ::Io::Flow::V0::Models::InventoryStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryCheckResponseItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity,
              :inventory_status => inventory_status.value
            }
          end

        end

        class InventoryExperienceReference

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'InventoryExperienceReference')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key
            }
          end

        end

        class InventoryItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'InventoryItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class InventoryRequest

          attr_reader :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'InventoryRequest')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::InventoryRequestItem) ? x : ::Io::Flow::V0::Models::InventoryRequestItem.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRequest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class InventoryRequestItem

          attr_reader :number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'InventoryRequestItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRequestItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity
            }
          end

        end

        # Ordered list of rules to apply, from first to last, to get available quantity.
        # This is unique per organization
        class InventoryRule

          attr_reader :id, :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :position, :query, :strategy], 'InventoryRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleForm

          attr_reader :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:position, :query, :strategy], 'InventoryRuleForm')
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleVersion

          attr_reader :id, :timestamp, :type, :inventory_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_rule], 'InventoryRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_rule = (x = opts.delete(:inventory_rule); x.is_a?(::Io::Flow::V0::Models::InventoryRule) ? x : ::Io::Flow::V0::Models::InventoryRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_rule => inventory_rule.to_hash
            }
          end

        end

        # Inventory snapshot reflects the current quantity and available number of units
        # for a given center / item
        class InventorySnapshot

          attr_reader :id, :available, :center, :item, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :available, :center, :item, :quantity], 'InventorySnapshot')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Integer)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshot.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :available => available,
              :center => center.to_hash,
              :item => item.to_hash,
              :quantity => quantity
            }
          end

        end

        class InventorySnapshotVersion

          attr_reader :id, :timestamp, :type, :inventory_snapshot

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_snapshot], 'InventorySnapshotVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_snapshot = (x = opts.delete(:inventory_snapshot); x.is_a?(::Io::Flow::V0::Models::InventorySnapshot) ? x : ::Io::Flow::V0::Models::InventorySnapshot.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshotVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_snapshot => inventory_snapshot.to_hash
            }
          end

        end

        # Treats inventory as available as long as the actual inventory quantity is >
        # the specified quantity. A common use case is to set quantity to zero to
        # indicate availability as long as there is at least 1 unit available.
        class InventoryStock < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:discriminator => InventoryStrategy::Types::INVENTORY_STOCK)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryStock')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryStock.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Items affected with rules pursuing an unlimited strategy will always be
        # available
        class InventoryUnlimited < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:discriminator => InventoryStrategy::Types::INVENTORY_UNLIMITED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @quantity = HttpClient::Preconditions.assert_class('quantity', (x = opts.delete(:quantity); x.nil? ? "unlimited" : x), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUnlimited.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Represents a single update on inventory quantity
        class InventoryUpdate

          attr_reader :id, :idempotency_key, :center, :item, :notes, :quantity, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :idempotency_key, :center, :item, :notes, :quantity, :type], 'InventoryUpdate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @notes = HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(opts.delete(:notes)), Hash)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :idempotency_key => idempotency_key,
              :center => center.to_hash,
              :item => item.to_hash,
              :notes => notes,
              :quantity => quantity,
              :type => type.value
            }
          end

        end

        # Form used to create an update on inventory. If inventory for center/item has
        # not been previously created, a new row is created for the center/item tuple.
        class InventoryUpdateForm

          attr_reader :center, :idempotency_key, :item_number, :quantity, :type, :notes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:center, :idempotency_key, :item_number, :quantity, :type], 'InventoryUpdateForm')
            @center = HttpClient::Preconditions.assert_class('center', opts.delete(:center), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
            @notes = (x = opts.delete(:notes); x.nil? ? nil : HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :center => center,
              :idempotency_key => idempotency_key,
              :item_number => item_number,
              :quantity => quantity,
              :type => type.value,
              :notes => notes
            }
          end

        end

        class InventoryUpdateVersion

          attr_reader :id, :timestamp, :type, :inventory_update

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_update], 'InventoryUpdateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_update = (x = opts.delete(:inventory_update); x.is_a?(::Io::Flow::V0::Models::InventoryUpdate) ? x : ::Io::Flow::V0::Models::InventoryUpdate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_update => inventory_update.to_hash
            }
          end

        end

        # An invitation via email to a user to join this organization. The user will
        # then walk through a user login/registration process and will immediately
        # become a member of the organization.
        class Invitation

          attr_reader :id, :organization, :email, :name, :role, :roles, :expiration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :email, :name, :expiration], 'Invitation')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @role = (x = opts.delete(:role); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x)))
            @roles = (x = opts.delete(:roles); x.nil? ? nil : HttpClient::Preconditions.assert_class('roles', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) })
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expiration)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Invitation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :email => email,
              :name => name.to_hash,
              :role => role.nil? ? nil : role.value,
              :roles => roles.nil? ? nil : roles.map { |o| o.to_hash },
              :expiration => expiration
            }
          end

        end

        # Returns information as to why a particular invitation could not be accepted.
        class InvitationError

          attr_reader :code, :messages

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'InvitationError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::InvitationErrorCode) ? x : ::Io::Flow::V0::Models::InvitationErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages
            }
          end

        end

        class InvitationForm

          attr_reader :organization, :email, :name, :role, :roles

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :email], 'InvitationForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @roles = (x = opts.delete(:roles); x.nil? ? nil : HttpClient::Preconditions.assert_class('roles', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :role => role.value,
              :roles => roles.nil? ? nil : roles.map { |o| o.to_hash }
            }
          end

        end

        class InvitationVersion

          attr_reader :id, :timestamp, :type, :invitation

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :invitation], 'InvitationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @invitation = (x = opts.delete(:invitation); x.is_a?(::Io::Flow::V0::Models::Invitation) ? x : ::Io::Flow::V0::Models::Invitation.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :invitation => invitation.to_hash
            }
          end

        end

        class InvoiceExport

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'InvoiceExport')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvoiceExport.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class InvoiceExportForm

          attr_reader :date_from, :date_to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @date_from = (x = opts.delete(:date_from); x.nil? ? nil : HttpClient::Preconditions.assert_class('date_from', HttpClient::Helper.to_date_iso8601(x), Date))
            @date_to = (x = opts.delete(:date_to); x.nil? ? nil : HttpClient::Preconditions.assert_class('date_to', HttpClient::Helper.to_date_iso8601(x), Date))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvoiceExportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :date_from => date_from,
              :date_to => date_to
            }
          end

        end

        class IssuerReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'IssuerReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            IssuerReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class IssuerSummary

          attr_reader :iin, :name, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:iin], 'IssuerSummary')
            @iin = HttpClient::Preconditions.assert_class('iin', opts.delete(:iin), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            IssuerSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :iin => iin,
              :name => name,
              :country => country
            }
          end

        end

        class IssuerV1

          attr_reader :iin, :card_brand, :card_type, :name, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:iin, :card_brand], 'IssuerV1')
            @iin = HttpClient::Preconditions.assert_class('iin', opts.delete(:iin), String)
            @card_brand = HttpClient::Preconditions.assert_class('card_brand', opts.delete(:card_brand), String)
            @card_type = (x = opts.delete(:card_type); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_type', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            IssuerV1.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :iin => iin,
              :card_brand => card_brand,
              :card_type => card_type,
              :name => name,
              :country => country
            }
          end

        end

        # The Flow item defines a specific item that can be purchased by a consumer. For
        # many clients, this will map to a Sku.
        class Item

          attr_reader :id, :number, :locale, :name, :price, :categories, :description, :attributes, :dimensions, :images, :local

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :locale, :name, :price, :dimensions], 'Item')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x))
            @images = HttpClient::Preconditions.assert_class('images', (x = opts.delete(:images); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)) }
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Local) ? x : ::Io::Flow::V0::Models::Local.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :locale => locale,
              :name => name,
              :price => price.to_hash,
              :categories => categories,
              :description => description,
              :attributes => attributes,
              :dimensions => dimensions.to_hash,
              :images => images.map { |o| o.to_hash },
              :local => local.nil? ? nil : local.to_hash
            }
          end

        end

        class ItemAttributesPatchForm

          attr_reader :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemAttributesPatchForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :attributes => attributes
            }
          end

        end

        # The item form defines the data required to create an item.
        class ItemForm

          attr_reader :number, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :locale, :name, :currency, :price], 'ItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @dimensions = (x = opts.delete(:dimensions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x)))
            @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageForm) ? x : ::Io::Flow::V0::Models::ImageForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes,
              :dimensions => dimensions.nil? ? nil : dimensions.to_hash,
              :images => images.nil? ? nil : images.map { |o| o.to_hash }
            }
          end

        end

        # The item form overlay defines data to merge into an item form.
        class ItemFormOverlay

          attr_reader :id, :number, :key, :position, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :key, :position], 'ItemFormOverlay')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @dimensions = (x = opts.delete(:dimensions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x)))
            @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageForm) ? x : ::Io::Flow::V0::Models::ImageForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFormOverlay.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :key => key,
              :position => position,
              :price => price.nil? ? nil : price.to_hash,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes,
              :dimensions => dimensions.nil? ? nil : dimensions.to_hash,
              :images => images.nil? ? nil : images.map { |o| o.to_hash }
            }
          end

        end

        class ItemFormOverlayForm

          attr_reader :number, :price, :currency, :position, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ItemFormOverlayForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @price = (x = opts.delete(:price); x.nil? ? nil : HttpClient::Preconditions.assert_class('price', x, Numeric))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @dimensions = (x = opts.delete(:dimensions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x)))
            @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageForm) ? x : ::Io::Flow::V0::Models::ImageForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFormOverlayForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :price => price,
              :currency => currency,
              :position => position,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes,
              :dimensions => dimensions.nil? ? nil : dimensions.to_hash,
              :images => images.nil? ? nil : images.map { |o| o.to_hash }
            }
          end

        end

        # Defines a fixed and percent margin to apply to items matching a query.
        class ItemMargin

          attr_reader :id, :key, :name, :q, :fixed, :percent, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name, :q, :fixed, :percent, :position], 'ItemMargin')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(opts.delete(:fixed)), BigDecimal)
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMargin.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :q => q,
              :fixed => fixed.to_f.to_s,
              :percent => percent.to_f.to_s,
              :position => position
            }
          end

        end

        class ItemMarginDeleted < Event

          attr_reader :event_id, :timestamp, :item_margin_id, :organization_id, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_MARGIN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_margin_id, :organization_id, :experience_key], 'ItemMarginDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_margin_id = HttpClient::Preconditions.assert_class('item_margin_id', opts.delete(:item_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_margin_id => item_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key
            }
          end

        end

        # A percent and/or fixed margin to apply to items based on query.
        class ItemMarginPostForm

          attr_reader :name, :q, :key, :fixed, :percent, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :q], 'ItemMarginPostForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @fixed = (x = opts.delete(:fixed); x.nil? ? nil : HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @percent = (x = opts.delete(:percent); x.nil? ? nil : HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginPostForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :q => q,
              :key => key,
              :fixed => fixed.to_f.to_s,
              :percent => percent.to_f.to_s,
              :position => position
            }
          end

        end

        # A percent and/or fixed margin to apply to items based on query.
        class ItemMarginPutForm

          attr_reader :name, :q, :fixed, :percent, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :q], 'ItemMarginPutForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = (x = opts.delete(:fixed); x.nil? ? nil : HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @percent = (x = opts.delete(:percent); x.nil? ? nil : HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :q => q,
              :fixed => fixed.to_f.to_s,
              :percent => percent.to_f.to_s,
              :position => position
            }
          end

        end

        class ItemMarginUpserted < Event

          attr_reader :event_id, :timestamp, :item_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position, :key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_MARGIN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position], 'ItemMarginUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_margin_id = HttpClient::Preconditions.assert_class('item_margin_id', opts.delete(:item_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(opts.delete(:fixed)), BigDecimal)
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_margin_id => item_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key,
              :name => name,
              :q => q,
              :fixed => fixed.to_f.to_s,
              :percent => percent.to_f.to_s,
              :position => position,
              :key => key
            }
          end

        end

        class ItemMarginVersion

          attr_reader :id, :timestamp, :type, :item_margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item_margin], 'ItemMarginVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item_margin = (x = opts.delete(:item_margin); x.is_a?(::Io::Flow::V0::Models::ItemMargin) ? x : ::Io::Flow::V0::Models::ItemMargin.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item_margin => item_margin.to_hash
            }
          end

        end

        class ItemOriginDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_ORIGIN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin], 'ItemOriginDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemOriginDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin
            }
          end

        end

        # Event raised whenever an item is assigned a country of origin. Note that one
        # item may have multiple countries of origin.
        class ItemOriginUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_ORIGIN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin], 'ItemOriginUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemOriginUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin
            }
          end

        end

        class ItemPriceUpdatePutForm

          attr_reader :currency, :price, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :price], 'ItemPriceUpdatePutForm')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', HttpClient::Helper.to_big_decimal(opts.delete(:price)), BigDecimal)
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemPriceUpdatePutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :price => price.to_f.to_s,
              :attributes => attributes
            }
          end

        end

        class ItemQuerySuggestion

          attr_reader :q, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q], 'ItemQuerySuggestion')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @count = (x = opts.delete(:count); x.nil? ? nil : HttpClient::Preconditions.assert_class('count', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemQuerySuggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :count => count
            }
          end

        end

        class ItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class ItemSalesMarginDeleted < Event

          attr_reader :event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_SALES_MARGIN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key], 'ItemSalesMarginDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_sales_margin_id = HttpClient::Preconditions.assert_class('item_sales_margin_id', opts.delete(:item_sales_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemSalesMarginDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_sales_margin_id => item_sales_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key
            }
          end

        end

        class ItemSalesMarginUpserted < Event

          attr_reader :event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_SALES_MARGIN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position], 'ItemSalesMarginUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_sales_margin_id = HttpClient::Preconditions.assert_class('item_sales_margin_id', opts.delete(:item_sales_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(opts.delete(:fixed)), BigDecimal)
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemSalesMarginUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_sales_margin_id => item_sales_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key,
              :name => name,
              :q => q,
              :fixed => fixed.to_f.to_s,
              :percent => percent.to_f.to_s,
              :position => position
            }
          end

        end

        # Available shipping price(s) a customer sees. This can be used for targetted
        # ads on Google or to display shipping price(s) on a PDP.
        class ItemShippingPricing

          attr_reader :min, :max

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:min], 'ItemShippingPricing')
            @min = (x = opts.delete(:min); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @max = (x = opts.delete(:max); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemShippingPricing.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :min => min.to_hash,
              :max => max.nil? ? nil : max.to_hash
            }
          end

        end

        # Statistics covering product catalog item information, including total catalog
        # item count, number of distinct categories, etc.
        class ItemStatistics

          attr_reader :items, :categories

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :categories], 'ItemStatistics')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Integer)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items,
              :categories => categories
            }
          end

        end

        class ItemVersion

          attr_reader :id, :timestamp, :type, :item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item], 'ItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item => item.to_hash
            }
          end

        end

        # The jsonp_response defines the schema for all Flow APIs calls made over JSONP,
        # providing access to the specific response status, headers, and body from the
        # underlying service.  See https://docs.flow.io/#jsonp for details
        class JsonpResponse

          attr_reader :status, :headers, :body

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status, :headers, :body], 'JsonpResponse')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), Integer)
            @headers = HttpClient::Preconditions.assert_class('headers', opts.delete(:headers), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('headers', d[1], Array).map { |v| HttpClient::Preconditions.assert_class('headers', v, String) }; h }
            @body = HttpClient::Preconditions.assert_class('body', HttpClient::Helper.to_object(opts.delete(:body)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            JsonpResponse.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status,
              :headers => headers.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1]; hash },
              :body => body
            }
          end

        end

        class KlaviyoLineItem

          attr_reader :content, :quantity, :price, :line_price

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:content, :quantity, :price, :line_price], 'KlaviyoLineItem')
            @content = (x = opts.delete(:content); x.is_a?(::Io::Flow::V0::Models::CheckoutItemContent) ? x : ::Io::Flow::V0::Models::CheckoutItemContent.new(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @line_price = (x = opts.delete(:line_price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            KlaviyoLineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :content => content.to_hash,
              :quantity => quantity,
              :price => price.to_hash,
              :line_price => line_price.to_hash
            }
          end

        end

        class KlaviyoOrderContent

          attr_reader :line_items, :prices, :checkout_url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:line_items, :prices, :checkout_url], 'KlaviyoOrderContent')
            @line_items = HttpClient::Preconditions.assert_class('line_items', opts.delete(:line_items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::KlaviyoLineItem) ? x : ::Io::Flow::V0::Models::KlaviyoLineItem.new(x)) }
            @prices = (x = opts.delete(:prices); x.is_a?(::Io::Flow::V0::Models::KlaviyoOrderPrices) ? x : ::Io::Flow::V0::Models::KlaviyoOrderPrices.new(x))
            @checkout_url = HttpClient::Preconditions.assert_class('checkout_url', opts.delete(:checkout_url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            KlaviyoOrderContent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :line_items => line_items.map { |o| o.to_hash },
              :prices => prices.to_hash,
              :checkout_url => checkout_url
            }
          end

        end

        # Contains cart related data.
        class KlaviyoOrderPrices

          attr_reader :subtotal, :vat, :duty, :discount, :shipping, :insurance, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:subtotal, :total], 'KlaviyoOrderPrices')
            @subtotal = (x = opts.delete(:subtotal); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @vat = (x = opts.delete(:vat); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @insurance = (x = opts.delete(:insurance); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            KlaviyoOrderPrices.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :subtotal => subtotal.to_hash,
              :vat => vat.nil? ? nil : vat.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :shipping => shipping.nil? ? nil : shipping.to_hash,
              :insurance => insurance.nil? ? nil : insurance.to_hash,
              :total => total.to_hash
            }
          end

        end

        class LabelFormatDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::LABEL_FORMAT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key], 'LabelFormatDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelFormatDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key
            }
          end

        end

        class LabelFormatUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key, :format

          def initialize(incoming={})
            super(:discriminator => Event::Types::LABEL_FORMAT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key, :format], 'LabelFormatUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @format = HttpClient::Preconditions.assert_class('format', opts.delete(:format), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelFormatUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key,
              :format => format
            }
          end

        end

        class LabelOrderSummary

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'LabelOrderSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelOrderSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class LabelUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :label_id, :carrier_tracking_number, :commercial_invoice, :flow_tracking_number, :destination, :origin, :carrier, :service, :zpl, :pdf, :png, :order, :carrier_tracking_number_url, :flow_tracking_number_url, :center_key, :recipient, :package, :order_identifier, :fulfillment_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::LABEL_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :label_id, :carrier_tracking_number, :commercial_invoice, :flow_tracking_number, :destination, :origin, :carrier, :service], 'LabelUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @label_id = HttpClient::Preconditions.assert_class('label_id', opts.delete(:label_id), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @commercial_invoice = HttpClient::Preconditions.assert_class('commercial_invoice', opts.delete(:commercial_invoice), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @png = (x = opts.delete(:png); x.nil? ? nil : HttpClient::Preconditions.assert_class('png', x, String))
            @order = (x = opts.delete(:order); x.nil? ? nil : HttpClient::Preconditions.assert_class('order', x, String))
            @carrier_tracking_number_url = (x = opts.delete(:carrier_tracking_number_url); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number_url', x, String))
            @flow_tracking_number_url = (x = opts.delete(:flow_tracking_number_url); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number_url', x, String))
            @center_key = (x = opts.delete(:center_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('center_key', x, String))
            @recipient = (x = opts.delete(:recipient); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShipmentRecipient) ? x : ::Io::Flow::V0::Models::ShipmentRecipient.apply(x)))
            @package = (x = opts.delete(:package); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x)))
            @order_identifier = (x = opts.delete(:order_identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_identifier', x, String))
            @fulfillment_key = (x = opts.delete(:fulfillment_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('fulfillment_key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :label_id => label_id,
              :carrier_tracking_number => carrier_tracking_number,
              :commercial_invoice => commercial_invoice,
              :flow_tracking_number => flow_tracking_number,
              :destination => destination.to_hash,
              :origin => origin.to_hash,
              :carrier => carrier,
              :service => service,
              :zpl => zpl,
              :pdf => pdf,
              :png => png,
              :order => order,
              :carrier_tracking_number_url => carrier_tracking_number_url,
              :flow_tracking_number_url => flow_tracking_number_url,
              :center_key => center_key,
              :recipient => recipient.nil? ? nil : recipient.value,
              :package => package.nil? ? nil : package.to_hash,
              :order_identifier => order_identifier,
              :fulfillment_key => fulfillment_key
            }
          end

        end

        # Tuple of item number, origin (from) country and destination (to) country
        class LandedCostItem

          attr_reader :number, :origin, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :origin, :destination], 'LandedCostItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LandedCostItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :origin => origin,
              :destination => destination
            }
          end

        end

        # The tariff codes, duty rates and tax rates associated with an
        # origin/destination pair. Does not take into account sales province
        class LaneLandedCost

          attr_reader :origin, :destination, :tariff_code, :effective_duty, :tax

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:origin, :destination, :tariff_code, :effective_duty, :tax], 'LaneLandedCost')
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @tariff_code = HttpClient::Preconditions.assert_class('tariff_code', opts.delete(:tariff_code), String)
            @effective_duty = (x = opts.delete(:effective_duty); x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x))
            @tax = (x = opts.delete(:tax); x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneLandedCost.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin => origin,
              :destination => destination,
              :tariff_code => tariff_code,
              :effective_duty => effective_duty.to_hash,
              :tax => tax.to_hash
            }
          end

        end

        # ISO 639 2-character language code. See https://api.flow.io/reference/languages
        class Language

          attr_reader :name, :iso_639_2

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_639_2], 'Language')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_639_2 = HttpClient::Preconditions.assert_class('iso_639_2', opts.delete(:iso_639_2), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Language.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_639_2 => iso_639_2
            }
          end

        end

        # Provides display data for a line item.
        class Line

          attr_reader :item_number, :quantity, :price, :total, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :quantity, :price, :total], 'Line')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Line.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :quantity => quantity,
              :price => price.to_hash,
              :total => total.to_hash,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # Line items represent the items a consumer is purchasing, including additional
        # information to complete the transaction. Note that you may pass in as many
        # line items as you like - including repeating item numbers across line items.
        class LineItem

          attr_reader :number, :quantity, :price, :attributes, :center, :discount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity, :price, :attributes], 'LineItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity,
              :price => price.to_hash,
              :attributes => attributes,
              :center => center,
              :discount => discount.nil? ? nil : discount.to_hash
            }
          end

        end

        # Line items represent the items a consumer is purchasing, including additional
        # information to complete the transaction. Note that you may pass in as many
        # line items as you like - including repeating item numbers across line items.
        class LineItemForm

          attr_reader :number, :quantity, :shipment_estimate, :price, :attributes, :center, :discount, :discounts

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'LineItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @shipment_estimate = (x = opts.delete(:shipment_estimate); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @discounts = (x = opts.delete(:discounts); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DiscountsForm) ? x : ::Io::Flow::V0::Models::DiscountsForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LineItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity,
              :shipment_estimate => shipment_estimate.nil? ? nil : shipment_estimate.to_hash,
              :price => price.nil? ? nil : price.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :center => center,
              :discount => discount.nil? ? nil : discount.to_hash,
              :discounts => discounts.nil? ? nil : discounts.to_hash
            }
          end

        end

        class Link

          attr_reader :url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'Link')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Link.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url
            }
          end

        end

        class Local

          attr_reader :experience, :prices, :rates, :spot_rates, :status, :attributes, :price_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:experience, :prices, :rates, :spot_rates], 'Local')
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x))
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.from_json(x)) }
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x)) }
            @spot_rates = HttpClient::Preconditions.assert_class('spot_rates', opts.delete(:spot_rates), Array).map { |v| HttpClient::Preconditions.assert_class('spot_rates', HttpClient::Helper.to_object(v), Hash) }
            @status = (x = (x = opts.delete(:status); x.nil? ? "included" : x); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @price_attributes = (x = opts.delete(:price_attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('price_attributes', x, Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Local.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :experience => experience.to_hash,
              :prices => prices.map { |o| o.to_hash },
              :rates => rates.map { |o| o.to_hash },
              :spot_rates => spot_rates,
              :status => status.value,
              :attributes => attributes.nil? ? nil : attributes,
              :price_attributes => price_attributes.nil? ? nil : price_attributes.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        # The Local Item represents all of the data for a given item that is localized
        # to a given experience.
        class LocalItem

          attr_reader :id, :experience, :center, :item, :pricing, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :item, :pricing, :status], 'LocalItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x))
            @center = (x = opts.delete(:center); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CenterSummary) ? x : ::Io::Flow::V0::Models::CenterSummary.new(x)))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::CatalogItemReference) ? x : ::Io::Flow::V0::Models::CatalogItemReference.new(x))
            @pricing = (x = opts.delete(:pricing); x.is_a?(::Io::Flow::V0::Models::LocalItemPricing) ? x : ::Io::Flow::V0::Models::LocalItemPricing.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :center => center.nil? ? nil : center.to_hash,
              :item => item.to_hash,
              :pricing => pricing.to_hash,
              :status => status.value
            }
          end

        end

        class LocalItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :local_item

          def initialize(incoming={})
            super(:discriminator => Event::Types::LOCAL_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :local_item], 'LocalItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @local_item = (x = opts.delete(:local_item); x.is_a?(::Io::Flow::V0::Models::LocalItem) ? x : ::Io::Flow::V0::Models::LocalItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :local_item => local_item.to_hash
            }
          end

        end

        # Localized item pricing information
        class LocalItemPricing

          attr_reader :price, :vat, :duty, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price, :attributes], 'LocalItemPricing')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::LocalizedItemPrice) ? x : ::Io::Flow::V0::Models::LocalizedItemPrice.new(x))
            @vat = (x = opts.delete(:vat); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedItemVat) ? x : ::Io::Flow::V0::Models::LocalizedItemVat.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedItemDuty) ? x : ::Io::Flow::V0::Models::LocalizedItemDuty.new(x)))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalItemPricing.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price => price.to_hash,
              :vat => vat.nil? ? nil : vat.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash,
              :attributes => attributes.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        class LocalItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :local_item

          def initialize(incoming={})
            super(:discriminator => Event::Types::LOCAL_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :local_item], 'LocalItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @local_item = (x = opts.delete(:local_item); x.is_a?(::Io::Flow::V0::Models::LocalItem) ? x : ::Io::Flow::V0::Models::LocalItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :local_item => local_item.to_hash
            }
          end

        end

        class LocalPriceDetails

          attr_reader :base, :local, :discount, :local_before_discount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :local], 'LocalPriceDetails')
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::PriceDetails) ? x : ::Io::Flow::V0::Models::PriceDetails.new(x))
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::PriceDetails) ? x : ::Io::Flow::V0::Models::PriceDetails.new(x))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x)))
            @local_before_discount = (x = opts.delete(:local_before_discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalPriceDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base.to_hash,
              :local => local.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :local_before_discount => local_before_discount.nil? ? nil : local_before_discount.to_hash
            }
          end

        end

        # If we found an experience for the given session, the localized information
        # will be presented here
        class LocalSession

          attr_reader :country, :currency, :language, :locale, :experience, :experiment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :currency, :language, :locale, :experience], 'LocalSession')
            @country = (x = opts.delete(:country); x.is_a?(::Io::Flow::V0::Models::Country) ? x : ::Io::Flow::V0::Models::Country.new(x))
            @currency = (x = opts.delete(:currency); x.is_a?(::Io::Flow::V0::Models::Currency) ? x : ::Io::Flow::V0::Models::Currency.new(x))
            @language = (x = opts.delete(:language); x.is_a?(::Io::Flow::V0::Models::Language) ? x : ::Io::Flow::V0::Models::Language.new(x))
            @locale = (x = opts.delete(:locale); x.is_a?(::Io::Flow::V0::Models::Locale) ? x : ::Io::Flow::V0::Models::Locale.new(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceGeo) ? x : ::Io::Flow::V0::Models::ExperienceGeo.new(x))
            @experiment = (x = opts.delete(:experiment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionExperiment) ? x : ::Io::Flow::V0::Models::SessionExperiment.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalSession.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country.to_hash,
              :currency => currency.to_hash,
              :language => language.to_hash,
              :locale => locale.to_hash,
              :experience => experience.to_hash,
              :experiment => experiment.nil? ? nil : experiment.to_hash
            }
          end

        end

        # Locales defines standard conventions for presentation of content. See
        # https://api.flow.io/reference/locales
        class Locale

          attr_reader :id, :name, :country, :language, :numbers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :country, :language, :numbers], 'Locale')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @numbers = (x = opts.delete(:numbers); x.is_a?(::Io::Flow::V0::Models::LocaleNumbers) ? x : ::Io::Flow::V0::Models::LocaleNumbers.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Locale.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :country => country,
              :language => language,
              :numbers => numbers.to_hash
            }
          end

        end

        # Number formats defined for a given locale
        class LocaleNumbers

          attr_reader :decimal, :group

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:decimal, :group], 'LocaleNumbers')
            @decimal = HttpClient::Preconditions.assert_class('decimal', opts.delete(:decimal), String)
            @group = HttpClient::Preconditions.assert_class('group', opts.delete(:group), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocaleNumbers.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :decimal => decimal,
              :group => group
            }
          end

        end

        class LocalizedAdjustment

          attr_reader :currency, :amount, :label, :base, :reason

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base, :reason], 'LocalizedAdjustment')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @reason = (x = opts.delete(:reason); x.is_a?(::Io::Flow::V0::Models::AdjustmentReason) ? x : ::Io::Flow::V0::Models::AdjustmentReason.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedAdjustment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :reason => reason.to_hash
            }
          end

        end

        class LocalizedItemDuty < LocalizedPrice

          attr_reader :currency, :amount, :label, :base, :adjustment, :basis

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_ITEM_DUTY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base], 'LocalizedItemDuty')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @adjustment = (x = opts.delete(:adjustment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedAdjustment) ? x : ::Io::Flow::V0::Models::LocalizedAdjustment.new(x)))
            @basis = (x = opts.delete(:basis); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MoneyWithBase) ? x : ::Io::Flow::V0::Models::MoneyWithBase.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemDuty.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :adjustment => adjustment.nil? ? nil : adjustment.to_hash,
              :basis => basis.nil? ? nil : basis.to_hash
            }
          end

        end

        class LocalizedItemPrice < LocalizedPrice

          attr_reader :currency, :amount, :label, :base, :includes

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_ITEM_PRICE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base], 'LocalizedItemPrice')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @includes = (x = opts.delete(:includes); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::IncludedLevies) ? x : ::Io::Flow::V0::Models::IncludedLevies.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemPrice.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :includes => includes.nil? ? nil : includes.to_hash
            }
          end

        end

        # Exports localized item prices data
        class LocalizedItemPricesExportType < ExportType

          attr_reader :since

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::LOCALIZED_ITEM_PRICES_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @since = (x = opts.delete(:since); x.nil? ? nil : HttpClient::Preconditions.assert_class('since', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemPricesExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :since => since
            }
          end

        end

        class LocalizedItemVat < LocalizedPrice

          attr_reader :currency, :amount, :label, :base, :name, :adjustment, :accuracy, :basis

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_ITEM_VAT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base, :name], 'LocalizedItemVat')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @adjustment = (x = opts.delete(:adjustment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedAdjustment) ? x : ::Io::Flow::V0::Models::LocalizedAdjustment.new(x)))
            @accuracy = (x = (x = opts.delete(:accuracy); x.nil? ? "calculated" : x); x.is_a?(::Io::Flow::V0::Models::PriceAccuracy) ? x : ::Io::Flow::V0::Models::PriceAccuracy.apply(x))
            @basis = (x = opts.delete(:basis); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MoneyWithBase) ? x : ::Io::Flow::V0::Models::MoneyWithBase.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemVat.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :name => name,
              :adjustment => adjustment.nil? ? nil : adjustment.to_hash,
              :accuracy => accuracy.value,
              :basis => basis.nil? ? nil : basis.to_hash
            }
          end

        end

        # Line items on the order, with localized pricing information
        class LocalizedLineItem

          attr_reader :number, :name, :quantity, :center, :price, :discount, :discounts, :attributes, :local, :shipment_estimate, :price_source

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :quantity, :local], 'LocalizedLineItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedLineItemDiscount) ? x : ::Io::Flow::V0::Models::LocalizedLineItemDiscount.new(x)))
            @discounts = (x = opts.delete(:discounts); x.nil? ? nil : HttpClient::Preconditions.assert_class('discounts', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedLineItemDiscount) ? x : ::Io::Flow::V0::Models::LocalizedLineItemDiscount.new(x)) })
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::Local) ? x : ::Io::Flow::V0::Models::Local.new(x))
            @shipment_estimate = (x = opts.delete(:shipment_estimate); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @price_source = (x = opts.delete(:price_source); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceSource) ? x : ::Io::Flow::V0::Models::PriceSource.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedLineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :name => name,
              :quantity => quantity,
              :center => center,
              :price => price.nil? ? nil : price.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :discounts => discounts.nil? ? nil : discounts.map { |o| o.to_hash },
              :attributes => attributes.nil? ? nil : attributes,
              :local => local.to_hash,
              :shipment_estimate => shipment_estimate.nil? ? nil : shipment_estimate.to_hash,
              :price_source => price_source.nil? ? nil : price_source.to_hash
            }
          end

        end

        # Represents the requested, base, and localized amounts for a discount on a
        # given line item. It applies to the entire line regardless of quantity.
        class LocalizedLineItemDiscount

          attr_reader :amount, :currency, :label, :base, :requested, :discount_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'LocalizedLineItemDiscount')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @requested = (x = opts.delete(:requested); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @discount_label = (x = opts.delete(:discount_label); x.nil? ? nil : HttpClient::Preconditions.assert_class('discount_label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedLineItemDiscount.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency,
              :label => label,
              :base => base.nil? ? nil : base.to_hash,
              :requested => requested.nil? ? nil : requested.to_hash,
              :discount_label => discount_label
            }
          end

        end

        class LocalizedTotal < LocalizedPrice

          attr_reader :currency, :amount, :label, :base

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_TOTAL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base], 'LocalizedTotal')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedTotal.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash
            }
          end

        end

        # Localized translation of a given province/region/country
        class LocalizedTranslation

          attr_reader :locale, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:locale, :name], 'LocalizedTranslation')
            @locale = (x = opts.delete(:locale); x.is_a?(::Io::Flow::V0::Models::Locale) ? x : ::Io::Flow::V0::Models::Locale.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedTranslation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :locale => locale.to_hash,
              :name => name
            }
          end

        end

        class LocationError

          attr_reader :code, :messages

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'LocationError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::LocationErrorCode) ? x : ::Io::Flow::V0::Models::LocationErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocationError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages
            }
          end

        end

        class LogisticsSettings

          attr_reader :shipping_configuration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:shipping_configuration], 'LogisticsSettings')
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationReference) ? x : ::Io::Flow::V0::Models::ShippingConfigurationReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LogisticsSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :shipping_configuration => shipping_configuration.to_hash
            }
          end

        end

        # Represents closeout of a group of labels that have been transferred to the
        # carrier for shipping
        class Manifest

          attr_reader :id, :timestamp, :shipping_labels, :pdf, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :shipping_labels], 'Manifest')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @shipping_labels = HttpClient::Preconditions.assert_class('shipping_labels', opts.delete(:shipping_labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingLabelSummary) ? x : ::Io::Flow::V0::Models::ShippingLabelSummary.new(x)) }
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @service = (x = opts.delete(:service); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Manifest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :shipping_labels => shipping_labels.map { |o| o.to_hash },
              :pdf => pdf,
              :service => service.nil? ? nil : service.to_hash
            }
          end

        end

        class ManifestForm

          attr_reader :tracking_numbers, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_numbers], 'ManifestForm')
            @tracking_numbers = HttpClient::Preconditions.assert_class('tracking_numbers', opts.delete(:tracking_numbers), Array).map { |v| HttpClient::Preconditions.assert_class('tracking_numbers', v, String) }
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ManifestForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_numbers => tracking_numbers,
              :service => service
            }
          end

        end

        class ManifestedLabelDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::MANIFESTED_LABEL_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'ManifestedLabelDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ManifestedLabelDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class ManifestedLabelUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :manifest_id, :label_id, :flow_tracking_number, :carrier_tracking_number, :order_identifier, :fulfillment_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::MANIFESTED_LABEL_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :manifest_id, :label_id, :flow_tracking_number, :carrier_tracking_number], 'ManifestedLabelUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @manifest_id = HttpClient::Preconditions.assert_class('manifest_id', opts.delete(:manifest_id), String)
            @label_id = HttpClient::Preconditions.assert_class('label_id', opts.delete(:label_id), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @order_identifier = (x = opts.delete(:order_identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_identifier', x, String))
            @fulfillment_key = (x = opts.delete(:fulfillment_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('fulfillment_key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ManifestedLabelUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :manifest_id => manifest_id,
              :label_id => label_id,
              :flow_tracking_number => flow_tracking_number,
              :carrier_tracking_number => carrier_tracking_number,
              :order_identifier => order_identifier,
              :fulfillment_key => fulfillment_key
            }
          end

        end

        class Margin

          attr_reader :type, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :value], 'Margin')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::MarginType) ? x : ::Io::Flow::V0::Models::MarginType.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Margin.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :value => value.to_f.to_s
            }
          end

        end

        class Measurement

          attr_reader :value, :units

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :units], 'Measurement')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            @units = (x = opts.delete(:units); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Measurement.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value,
              :units => units.value
            }
          end

        end

        # Represents the users that are part of this organization. Primary purpose is to
        # manage which users have access to the organization's data and to provide a
        # simple user interface to assign roles and permissions to each member of the
        # organization
        class Membership

          attr_reader :id, :organization, :user, :role, :roles

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :user, :roles], 'Membership')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::ExpandableUser) ? x : ::Io::Flow::V0::Models::ExpandableUser.from_json(x))
            @role = (x = opts.delete(:role); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x)))
            @roles = HttpClient::Preconditions.assert_class('roles', opts.delete(:roles), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Membership.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :user => user.to_hash,
              :role => role.nil? ? nil : role.value,
              :roles => roles.map { |o| o.to_hash }
            }
          end

        end

        class MembershipDeletedV2 < Event

          attr_reader :event_id, :timestamp, :membership

          def initialize(incoming={})
            super(:discriminator => Event::Types::MEMBERSHIP_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :membership], 'MembershipDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @membership = (x = opts.delete(:membership); x.is_a?(::Io::Flow::V0::Models::Membership) ? x : ::Io::Flow::V0::Models::Membership.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :membership => membership.to_hash
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipForm

          attr_reader :organization, :user, :role, :roles

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :user], 'MembershipForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @user = HttpClient::Preconditions.assert_class('user', opts.delete(:user), String)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @roles = HttpClient::Preconditions.assert_class('roles', (x = opts.delete(:roles); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :user => user,
              :role => role.value,
              :roles => roles.map { |o| o.to_hash }
            }
          end

        end

        # Top level resource to update a membership.
        class MembershipPutForm

          attr_reader :role, :roles

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @roles = HttpClient::Preconditions.assert_class('roles', (x = opts.delete(:roles); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value,
              :roles => roles.map { |o| o.to_hash }
            }
          end

        end

        class MembershipUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :membership

          def initialize(incoming={})
            super(:discriminator => Event::Types::MEMBERSHIP_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :membership], 'MembershipUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @membership = (x = opts.delete(:membership); x.is_a?(::Io::Flow::V0::Models::Membership) ? x : ::Io::Flow::V0::Models::Membership.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :membership => membership.to_hash
            }
          end

        end

        class MembershipVersion

          attr_reader :id, :timestamp, :type, :membership

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :membership], 'MembershipVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @membership = (x = opts.delete(:membership); x.is_a?(::Io::Flow::V0::Models::Membership) ? x : ::Io::Flow::V0::Models::Membership.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :membership => membership.to_hash
            }
          end

        end

        class MerchantGiftCardBalance

          attr_reader :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'MerchantGiftCardBalance')
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantGiftCardBalance.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount.to_f.to_s,
              :currency => currency
            }
          end

        end

        class MerchantGiftCardBalanceForm

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'MerchantGiftCardBalanceForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantGiftCardBalanceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class MerchantGiftCardError

          attr_reader :code, :messages

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'MerchantGiftCardError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::MerchantGiftCardErrorCode) ? x : ::Io::Flow::V0::Models::MerchantGiftCardErrorCode.apply(x))
            @messages = (x = opts.delete(:messages); x.nil? ? nil : HttpClient::Preconditions.assert_class('messages', x, Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantGiftCardError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages.nil? ? nil : messages
            }
          end

        end

        class MerchantGiftCardRedemption

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'MerchantGiftCardRedemption')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantGiftCardRedemption.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class MerchantGiftCardRedemptionForm

          attr_reader :number, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :amount, :currency], 'MerchantGiftCardRedemptionForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantGiftCardRedemptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :amount => amount.to_f.to_s,
              :currency => currency
            }
          end

        end

        class MerchantGiftCardReversal

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'MerchantGiftCardReversal')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantGiftCardReversal.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class MerchantGiftCardReversalForm

          attr_reader :number, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :amount, :currency], 'MerchantGiftCardReversalForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantGiftCardReversalForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :amount => amount.to_f.to_s,
              :currency => currency
            }
          end

        end

        # Creates an authorization for a transaction for which Flow is the merchant of
        # record. In this case, you must provide your order number for a valid Flow
        # order. An authorization is used to check and reserve funds w/ a given payment
        # method. No funds are actually transferred; once you have you an authorization,
        # you can capture up to the amount of the authorization
        class MerchantOfRecordAuthorizationForm < AuthorizationForm

          attr_reader :token, :order_number, :amount, :currency, :key, :cvv, :attributes, :ip, :options, :redirect_urls, :installment_program_id, :browser_info

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::MERCHANT_OF_RECORD_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :order_number], 'MerchantOfRecordAuthorizationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @options = (x = opts.delete(:options); x.nil? ? nil : HttpClient::Preconditions.assert_class('options', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AuthorizationOption) ? x : ::Io::Flow::V0::Models::AuthorizationOption.apply(x)) })
            @redirect_urls = (x = opts.delete(:redirect_urls); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PostPaymentRedirectUrls) ? x : ::Io::Flow::V0::Models::PostPaymentRedirectUrls.new(x)))
            @installment_program_id = (x = opts.delete(:installment_program_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('installment_program_id', x, String))
            @browser_info = (x = opts.delete(:browser_info); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BrowserInfo) ? x : ::Io::Flow::V0::Models::BrowserInfo.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantOfRecordAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :token => token,
              :order_number => order_number,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :key => key,
              :cvv => cvv,
              :attributes => attributes.nil? ? nil : attributes,
              :ip => ip,
              :options => options.nil? ? nil : options.map { |o| o.value },
              :redirect_urls => redirect_urls.nil? ? nil : redirect_urls.to_hash,
              :installment_program_id => installment_program_id,
              :browser_info => browser_info.nil? ? nil : browser_info.to_hash
            }
          end

        end

        # The merchant of record entity provides the legal name and address of the
        # specific Flow entity serving as merchant of record.
        class MerchantOfRecordEntity

          attr_reader :organization, :name, :vat, :streets, :city, :province, :postal, :country, :phone, :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :name, :vat, :streets, :city, :country], 'MerchantOfRecordEntity')
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @vat = (x = opts.delete(:vat); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntityRegistration) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntityRegistration.new(x))
            @streets = HttpClient::Preconditions.assert_class('streets', opts.delete(:streets), Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) }
            @city = HttpClient::Preconditions.assert_class('city', opts.delete(:city), String)
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantOfRecordEntity.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization.to_hash,
              :name => name,
              :vat => vat.to_hash,
              :streets => streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :phone => phone,
              :email => email
            }
          end

        end

        class MerchantOfRecordEntityRegistration

          attr_reader :number, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :country], 'MerchantOfRecordEntityRegistration')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantOfRecordEntityRegistration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :country => country
            }
          end

        end

        # Creates an online payment
        class MerchantOfRecordPaymentForm < PaymentForm

          attr_reader :method, :order_number, :amount, :currency

          def initialize(incoming={})
            super(:discriminator => PaymentForm::Types::MERCHANT_OF_RECORD_PAYMENT_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:method, :order_number, :amount, :currency], 'MerchantOfRecordPaymentForm')
            @method = HttpClient::Preconditions.assert_class('method', opts.delete(:method), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantOfRecordPaymentForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :method => method,
              :order_number => order_number,
              :amount => amount.to_f.to_s,
              :currency => currency
            }
          end

        end

        # Money represents an amount in a given currency
        class Money

          attr_reader :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'Money')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Money.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency
            }
          end

        end

        class MoneyWithBase

          attr_reader :currency, :amount, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :base], 'MoneyWithBase')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MoneyWithBase.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :amount => amount,
              :base => base.to_hash
            }
          end

        end

        # Used to migrate older models to have a base value, without breaking
        # compatibility
        class MoneyWithOptionalBase

          attr_reader :currency, :amount, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount], 'MoneyWithOptionalBase')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MoneyWithOptionalBase.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :amount => amount,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        class Name

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Name.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        class NameForm

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NameForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        class NoInventoryReservationError < ReservationError

          attr_reader :messages, :items

          def initialize(incoming={})
            super(:code => ReservationError::Types::NO_INVENTORY_RESERVATION_ERROR)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages, :items], 'NoInventoryReservationError')
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::NoInventoryReservationErrorItem) ? x : ::Io::Flow::V0::Models::NoInventoryReservationErrorItem.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NoInventoryReservationError.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :messages => messages,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class NoInventoryReservationErrorItem

          attr_reader :number, :requested_quantity, :available_quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :requested_quantity, :available_quantity], 'NoInventoryReservationErrorItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @requested_quantity = HttpClient::Preconditions.assert_class('requested_quantity', opts.delete(:requested_quantity), Integer)
            @available_quantity = HttpClient::Preconditions.assert_class('available_quantity', opts.delete(:available_quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NoInventoryReservationErrorItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :requested_quantity => requested_quantity,
              :available_quantity => available_quantity
            }
          end

        end

        class NotificationDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :package

          def initialize(incoming={})
            super(:discriminator => Event::Types::NOTIFICATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :package], 'NotificationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @notification_id = HttpClient::Preconditions.assert_class('notification_id', opts.delete(:notification_id), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NotificationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :notification_id => notification_id,
              :carrier_tracking_number => carrier_tracking_number,
              :flow_tracking_number => flow_tracking_number,
              :destination => destination.to_hash,
              :origin => origin.to_hash,
              :carrier => carrier,
              :service => service,
              :order => order,
              :package => package.to_hash
            }
          end

        end

        class NotificationUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :order_identifier, :fulfillment_key, :package

          def initialize(incoming={})
            super(:discriminator => Event::Types::NOTIFICATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :package], 'NotificationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @notification_id = HttpClient::Preconditions.assert_class('notification_id', opts.delete(:notification_id), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
            @order_identifier = (x = opts.delete(:order_identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_identifier', x, String))
            @fulfillment_key = (x = opts.delete(:fulfillment_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('fulfillment_key', x, String))
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NotificationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :notification_id => notification_id,
              :carrier_tracking_number => carrier_tracking_number,
              :flow_tracking_number => flow_tracking_number,
              :destination => destination.to_hash,
              :origin => origin.to_hash,
              :carrier => carrier,
              :service => service,
              :order => order,
              :order_identifier => order_identifier,
              :fulfillment_key => fulfillment_key,
              :package => package.to_hash
            }
          end

        end

        class NumberRange

          attr_reader :min, :max

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:min, :max], 'NumberRange')
            @min = HttpClient::Preconditions.assert_class('min', opts.delete(:min), Integer)
            @max = HttpClient::Preconditions.assert_class('max', opts.delete(:max), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NumberRange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :min => min,
              :max => max
            }
          end

        end

        class OnlineAuthorization < Authorization

          attr_reader :id, :key, :method, :merchant_of_record, :details, :payment, :amount, :currency, :requested, :customer, :attributes, :destination, :billing_address, :order, :ip, :result, :created_at, :expires_at, :base

          def initialize(incoming={})
            super(:discriminator => Authorization::Types::ONLINE_AUTHORIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :amount, :currency, :customer, :attributes, :result, :created_at], 'OnlineAuthorization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @method = (x = opts.delete(:method); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PaymentMethod) ? x : ::Io::Flow::V0::Models::PaymentMethod.new(x)))
            @merchant_of_record = (x = (x = opts.delete(:merchant_of_record); x.nil? ? "flow" : x); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecord) ? x : ::Io::Flow::V0::Models::MerchantOfRecord.apply(x))
            @details = (x = opts.delete(:details); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OnlineAuthorizationDetails) ? x : ::Io::Flow::V0::Models::OnlineAuthorizationDetails.from_json(x)))
            @payment = (x = opts.delete(:payment); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment', HttpClient::Helper.to_object(x), Hash))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @requested = (x = opts.delete(:requested); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::OrderCustomer) ? x : ::Io::Flow::V0::Models::OrderCustomer.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @billing_address = (x = opts.delete(:billing_address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationOrderReference) ? x : ::Io::Flow::V0::Models::AuthorizationOrderReference.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @result = (x = opts.delete(:result); x.is_a?(::Io::Flow::V0::Models::AuthorizationResult) ? x : ::Io::Flow::V0::Models::AuthorizationResult.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @expires_at = (x = opts.delete(:expires_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OnlineAuthorization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :method => method.nil? ? nil : method.to_hash,
              :merchant_of_record => merchant_of_record.value,
              :details => details.nil? ? nil : details.to_hash,
              :payment => payment,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :requested => requested.nil? ? nil : requested.to_hash,
              :customer => customer.to_hash,
              :attributes => attributes,
              :destination => destination.nil? ? nil : destination.to_hash,
              :billing_address => billing_address.nil? ? nil : billing_address.to_hash,
              :order => order.nil? ? nil : order.to_hash,
              :ip => ip,
              :result => result.to_hash,
              :created_at => created_at,
              :expires_at => expires_at,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        class OnlineAuthorizationDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::ONLINE_AUTHORIZATION_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :authorization], 'OnlineAuthorizationDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::OnlineAuthorization) ? x : ::Io::Flow::V0::Models::OnlineAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OnlineAuthorizationDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :authorization => authorization.to_hash
            }
          end

        end

        # Represents an authorization for a card payment method
        class OnlineAuthorizationUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::ONLINE_AUTHORIZATION_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :authorization], 'OnlineAuthorizationUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::OnlineAuthorization) ? x : ::Io::Flow::V0::Models::OnlineAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OnlineAuthorizationUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :authorization => authorization.to_hash
            }
          end

        end

        class OptinResponse

          attr_reader :key, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :value], 'OptinResponse')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @value = (x = opts.delete(:value); x.is_a?(::Io::Flow::V0::Models::OptinResponseType) ? x : ::Io::Flow::V0::Models::OptinResponseType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OptinResponse.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :value => value.value
            }
          end

        end

        class OptionWeightEstimates

          attr_reader :gravitational, :dimensional

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:gravitational, :dimensional], 'OptionWeightEstimates')
            @gravitational = (x = opts.delete(:gravitational); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
            @dimensional = (x = opts.delete(:dimensional); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OptionWeightEstimates.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :gravitational => gravitational.to_hash,
              :dimensional => dimensional.to_hash
            }
          end

        end

        # Flags to indicate whether a feature is enabled/disabled on a particular model
        # (e.g. show/do not show attribute as a column in harmonization table view of
        # items)
        class Options

          attr_reader :required, :show_in_catalog, :show_in_harmonization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @required = HttpClient::Preconditions.assert_boolean('required', (x = opts.delete(:required); x.nil? ? false : x))
            @show_in_catalog = HttpClient::Preconditions.assert_boolean('show_in_catalog', (x = opts.delete(:show_in_catalog); x.nil? ? false : x))
            @show_in_harmonization = HttpClient::Preconditions.assert_boolean('show_in_harmonization', (x = opts.delete(:show_in_harmonization); x.nil? ? false : x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Options.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :required => required,
              :show_in_catalog => show_in_catalog,
              :show_in_harmonization => show_in_harmonization
            }
          end

        end

        # An order represents all of the information about a particular set of line
        # items, including pricing, currency rates, delivery options, etc. All
        # information in an order is guaranteed by Flow - if an order is submitted
        # before its expiration. The intended use case is to create an order as a
        # consumer enters checkout, then to submit that order as part of the user
        # submitting their order. Note that Flow will automatically mark an order
        # submitted if we see payment authorization(s) covering the full balance of an
        # order.
        class Order < ExpandableOrder

          attr_reader :id, :number, :merchant_of_record, :experience, :customer, :delivered_duty, :destination, :expires_at, :items, :deliveries, :selections, :prices, :total, :attributes, :submitted_at, :lines, :identifiers, :promotions, :payments, :balance, :rules, :tax_registration, :geo

          def initialize(incoming={})
            super(:discriminator => ExpandableOrder::Types::ORDER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :customer, :delivered_duty, :destination, :expires_at, :items, :deliveries, :selections, :prices, :total, :attributes], 'Order')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @merchant_of_record = (x = opts.delete(:merchant_of_record); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderMerchantOfRecord) ? x : ::Io::Flow::V0::Models::OrderMerchantOfRecord.apply(x)))
            @experience = (x = opts.delete(:experience); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExpandableExperience) ? x : ::Io::Flow::V0::Models::ExpandableExperience.from_json(x)))
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::OrderCustomer) ? x : ::Io::Flow::V0::Models::OrderCustomer.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedLineItem) ? x : ::Io::Flow::V0::Models::LocalizedLineItem.new(x)) }
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.from_json(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetail) ? x : ::Io::Flow::V0::Models::OrderPriceDetail.new(x)) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @submitted_at = (x = opts.delete(:submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @lines = (x = opts.delete(:lines); x.nil? ? nil : HttpClient::Preconditions.assert_class('lines', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Line) ? x : ::Io::Flow::V0::Models::Line.new(x)) })
            @identifiers = (x = opts.delete(:identifiers); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifiers', x, Array).map { |v| HttpClient::Preconditions.assert_class('identifiers', v, String) })
            @promotions = (x = opts.delete(:promotions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Promotions) ? x : ::Io::Flow::V0::Models::Promotions.new(x)))
            @payments = (x = opts.delete(:payments); x.nil? ? nil : HttpClient::Preconditions.assert_class('payments', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPayment) ? x : ::Io::Flow::V0::Models::OrderPayment.new(x)) })
            @balance = (x = opts.delete(:balance); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x)))
            @rules = (x = opts.delete(:rules); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderRulesSummary) ? x : ::Io::Flow::V0::Models::OrderRulesSummary.new(x)))
            @tax_registration = (x = opts.delete(:tax_registration); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TaxRegistration) ? x : ::Io::Flow::V0::Models::TaxRegistration.new(x)))
            @geo = (x = opts.delete(:geo); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderGeo) ? x : ::Io::Flow::V0::Models::OrderGeo.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Order.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :number => number,
              :merchant_of_record => merchant_of_record.nil? ? nil : merchant_of_record.value,
              :experience => experience.nil? ? nil : experience.to_hash,
              :customer => customer.to_hash,
              :delivered_duty => delivered_duty.value,
              :destination => destination.to_hash,
              :expires_at => expires_at,
              :items => items.map { |o| o.to_hash },
              :deliveries => deliveries.map { |o| o.to_hash },
              :selections => selections,
              :prices => prices.map { |o| o.to_hash },
              :total => total.to_hash,
              :attributes => attributes,
              :submitted_at => submitted_at,
              :lines => lines.nil? ? nil : lines.map { |o| o.to_hash },
              :identifiers => identifiers.nil? ? nil : identifiers,
              :promotions => promotions.nil? ? nil : promotions.to_hash,
              :payments => payments.nil? ? nil : payments.map { |o| o.to_hash },
              :balance => balance.nil? ? nil : balance.to_hash,
              :rules => rules.nil? ? nil : rules.to_hash,
              :tax_registration => tax_registration.nil? ? nil : tax_registration.to_hash,
              :geo => geo.nil? ? nil : geo.to_hash
            }
          end

        end

        class OrderAddress

          attr_reader :text, :streets, :city, :province, :postal, :country, :latitude, :longitude, :contact

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @latitude = (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String))
            @longitude = (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            @contact = (x = opts.delete(:contact); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderAddress.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :text => text,
              :streets => streets.nil? ? nil : streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :latitude => latitude,
              :longitude => longitude,
              :contact => contact.nil? ? nil : contact.to_hash
            }
          end

        end

        # The Order Builder model is used to incrementally build up an order until it is
        # complete and can be submitted.
        class OrderBuilder

          attr_reader :order, :errors

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x)))
            @errors = (x = opts.delete(:errors); x.nil? ? nil : HttpClient::Preconditions.assert_class('errors', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderError) ? x : ::Io::Flow::V0::Models::OrderError.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBuilder.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order.nil? ? nil : order.to_hash,
              :errors => errors.nil? ? nil : errors.map { |o| o.to_hash }
            }
          end

        end

        class OrderBuilderAttributesForm

          attr_reader :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:attributes], 'OrderBuilderAttributesForm')
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBuilderAttributesForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :attributes => attributes
            }
          end

        end

        class OrderBuilderCustomerInvoiceAddressForm

          attr_reader :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address], 'OrderBuilderCustomerInvoiceAddressForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBuilderCustomerInvoiceAddressForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash
            }
          end

        end

        class OrderBuilderDeliveredDutyForm

          attr_reader :delivered_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivered_duty], 'OrderBuilderDeliveredDutyForm')
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBuilderDeliveredDutyForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivered_duty => delivered_duty.value
            }
          end

        end

        class OrderBuilderDestinationCountryForm

          attr_reader :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country], 'OrderBuilderDestinationCountryForm')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBuilderDestinationCountryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country
            }
          end

        end

        class OrderBuilderDestinationForm

          attr_reader :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination], 'OrderBuilderDestinationForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBuilderDestinationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash
            }
          end

        end

        # A customer represents the actual person purchasing from you. This information
        # is needed primarily to support logistics (delivery to this person), fraud
        # management (verification of who the person is), and reporting. We also
        # recommend including your customer number whenever possible as doing so will
        # allow Flow to link up transactions for this customer making customer service
        # easier.
        class OrderCustomer

          attr_reader :name, :number, :phone, :email, :address, :invoice

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'OrderCustomer')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @invoice = (x = opts.delete(:invoice); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CustomerInvoice) ? x : ::Io::Flow::V0::Models::CustomerInvoice.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderCustomer.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :number => number,
              :phone => phone,
              :email => email,
              :address => address.nil? ? nil : address.to_hash,
              :invoice => invoice.nil? ? nil : invoice.to_hash
            }
          end

        end

        class OrderCustomerForm

          attr_reader :name, :number, :phone, :email, :address, :invoice

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @invoice = (x = opts.delete(:invoice); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CustomerInvoice) ? x : ::Io::Flow::V0::Models::CustomerInvoice.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderCustomerForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.nil? ? nil : name.to_hash,
              :number => number,
              :phone => phone,
              :email => email,
              :address => address.nil? ? nil : address.to_hash,
              :invoice => invoice.nil? ? nil : invoice.to_hash
            }
          end

        end

        class OrderDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number], 'OrderDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number
            }
          end

        end

        class OrderDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :order

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :order], 'OrderDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :order => order.to_hash
            }
          end

        end

        # Purpose-built form specifically for only address-related changes to
        # destination on an order
        class OrderDestinationPutForm

          attr_reader :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination], 'OrderDestinationPutForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderDestinationPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash
            }
          end

        end

        class OrderError

          attr_reader :code, :messages, :numbers, :destination_country, :threshold

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'OrderError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::OrderErrorCode) ? x : ::Io::Flow::V0::Models::OrderErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @destination_country = (x = opts.delete(:destination_country); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Country) ? x : ::Io::Flow::V0::Models::Country.new(x)))
            @threshold = (x = opts.delete(:threshold); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ValueThresholdExceededDetails) ? x : ::Io::Flow::V0::Models::ValueThresholdExceededDetails.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :numbers => numbers.nil? ? nil : numbers,
              :destination_country => destination_country.nil? ? nil : destination_country.to_hash,
              :threshold => threshold.nil? ? nil : threshold.to_hash
            }
          end

        end

        # Lightweight estimate for a group of items without any customer-related
        # information. This will contain available estimates on shipping, taxes, and
        # duties.
        class OrderEstimate

          attr_reader :id, :items, :destination, :deliveries, :prices, :selections, :total, :lines, :promotions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :destination, :deliveries, :prices, :selections, :total], 'OrderEstimate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedLineItem) ? x : ::Io::Flow::V0::Models::LocalizedLineItem.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.from_json(x)) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetail) ? x : ::Io::Flow::V0::Models::OrderPriceDetail.new(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x))
            @lines = (x = opts.delete(:lines); x.nil? ? nil : HttpClient::Preconditions.assert_class('lines', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Line) ? x : ::Io::Flow::V0::Models::Line.new(x)) })
            @promotions = (x = opts.delete(:promotions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Promotions) ? x : ::Io::Flow::V0::Models::Promotions.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :prices => prices.map { |o| o.to_hash },
              :selections => selections,
              :total => total.to_hash,
              :lines => lines.nil? ? nil : lines.map { |o| o.to_hash },
              :promotions => promotions.nil? ? nil : promotions.to_hash
            }
          end

        end

        # Form to get a lightweight estimate of an order.
        class OrderEstimateForm

          attr_reader :items, :destination, :selections

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'OrderEstimateForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x)))
            @selections = (x = opts.delete(:selections); x.nil? ? nil : HttpClient::Preconditions.assert_class('selections', x, Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderEstimateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :destination => destination.nil? ? nil : destination.to_hash,
              :selections => selections.nil? ? nil : selections
            }
          end

        end

        # Exports orders
        class OrderExportType < ExportType

          attr_reader :numbers, :min_hours_since_submitted_at, :submitted_on_or_before, :submitted_on_or_after, :status, :has_tracking_label, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::ORDER_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @min_hours_since_submitted_at = (x = opts.delete(:min_hours_since_submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('min_hours_since_submitted_at', x, Integer))
            @submitted_on_or_before = (x = opts.delete(:submitted_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @submitted_on_or_after = (x = opts.delete(:submitted_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderStatus) ? x : ::Io::Flow::V0::Models::OrderStatus.apply(x)))
            @has_tracking_label = (x = opts.delete(:has_tracking_label); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_tracking_label', x))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :min_hours_since_submitted_at => min_hours_since_submitted_at,
              :submitted_on_or_before => submitted_on_or_before,
              :submitted_on_or_after => submitted_on_or_after,
              :status => status.nil? ? nil : status.value,
              :has_tracking_label => has_tracking_label,
              :sort => sort
            }
          end

        end

        # The order form is used to create an open order, providing the details on
        # pricing and delivery options for destination and items/quantities specified
        class OrderForm

          attr_reader :customer, :items, :delivered_duty, :number, :destination, :discount, :discounts, :attributes, :authorization_keys

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'OrderForm')
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderCustomerForm) ? x : ::Io::Flow::V0::Models::OrderCustomerForm.new(x)))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @discounts = (x = opts.delete(:discounts); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DiscountsForm) ? x : ::Io::Flow::V0::Models::DiscountsForm.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @authorization_keys = (x = opts.delete(:authorization_keys); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_keys', x, Array).map { |v| HttpClient::Preconditions.assert_class('authorization_keys', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :customer => customer.nil? ? nil : customer.to_hash,
              :items => items.map { |o| o.to_hash },
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :number => number,
              :destination => destination.nil? ? nil : destination.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :discounts => discounts.nil? ? nil : discounts.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :authorization_keys => authorization_keys.nil? ? nil : authorization_keys
            }
          end

        end

        # The fraud status for an order.
        class OrderFraudStatus

          attr_reader :order, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order, :status], 'OrderFraudStatus')
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderReference) ? x : ::Io::Flow::V0::Models::OrderReference.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::FraudStatus) ? x : ::Io::Flow::V0::Models::FraudStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderFraudStatus.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order.to_hash,
              :status => status.value
            }
          end

        end

        # The geolocated information for an order
        class OrderGeo

          attr_reader :ip, :country, :currency, :language

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country], 'OrderGeo')
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderGeo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ip => ip,
              :country => country,
              :currency => currency,
              :language => language
            }
          end

        end

        # Represents alternate identifiers that can be used to lookup an order. Common
        # use cases are to support attaching a primary identifier (e.g. a nice order
        # number) post order submission or attaching IDs that are used by the warehouse
        # to ship the orders.
        class OrderIdentifier

          attr_reader :id, :order, :identifier, :primary, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order, :identifier, :primary], 'OrderIdentifier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderReference) ? x : ::Io::Flow::V0::Models::OrderReference.new(x))
            @identifier = HttpClient::Preconditions.assert_class('identifier', opts.delete(:identifier), String)
            @primary = HttpClient::Preconditions.assert_boolean('primary', opts.delete(:primary))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :order => order.to_hash,
              :identifier => identifier,
              :primary => primary,
              :number => number
            }
          end

        end

        class OrderIdentifierDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_IDENTIFIER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'OrderIdentifierDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class OrderIdentifierDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_IDENTIFIER_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'OrderIdentifierDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class OrderIdentifierForm

          attr_reader :order, :identifier, :number, :primary

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order], 'OrderIdentifierForm')
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
            @identifier = (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, String))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @primary = (x = opts.delete(:primary); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('primary', x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order,
              :identifier => identifier,
              :number => number,
              :primary => primary
            }
          end

        end

        class OrderIdentifierPutForm

          attr_reader :order, :primary

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order], 'OrderIdentifierPutForm')
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
            @primary = (x = opts.delete(:primary); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('primary', x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order,
              :primary => primary
            }
          end

        end

        class OrderIdentifierUpserted < Event

          attr_reader :event_id, :timestamp, :id, :organization, :number, :order_number

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_IDENTIFIER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :organization, :number, :order_number], 'OrderIdentifierUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :organization => organization,
              :number => number,
              :order_number => order_number
            }
          end

        end

        class OrderIdentifierUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :order_number, :identifier, :primary

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_IDENTIFIER_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :order_number, :identifier, :primary], 'OrderIdentifierUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @identifier = HttpClient::Preconditions.assert_class('identifier', opts.delete(:identifier), String)
            @primary = HttpClient::Preconditions.assert_boolean('primary', opts.delete(:primary))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :order_number => order_number,
              :identifier => identifier,
              :primary => primary
            }
          end

        end

        class OrderIdentifierUpsertedV3 < Event

          attr_reader :event_id, :timestamp, :organization, :identifier

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_IDENTIFIER_UPSERTED_V3)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :identifier], 'OrderIdentifierUpsertedV3')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @identifier = (x = opts.delete(:identifier); x.is_a?(::Io::Flow::V0::Models::OrderIdentifier) ? x : ::Io::Flow::V0::Models::OrderIdentifier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierUpsertedV3.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :identifier => identifier.to_hash
            }
          end

        end

        class OrderIdentifierVersion

          attr_reader :id, :timestamp, :type, :order_identifier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :order_identifier], 'OrderIdentifierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @order_identifier = (x = opts.delete(:order_identifier); x.is_a?(::Io::Flow::V0::Models::OrderIdentifier) ? x : ::Io::Flow::V0::Models::OrderIdentifier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :order_identifier => order_identifier.to_hash
            }
          end

        end

        class OrderNumberGeneratorDefaults

          attr_reader :starts_with, :min_hex_length, :min_starts_with

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @starts_with = HttpClient::Preconditions.assert_class('starts_with', (x = opts.delete(:starts_with); x.nil? ? 1001 : x), Integer)
            @min_hex_length = HttpClient::Preconditions.assert_class('min_hex_length', (x = opts.delete(:min_hex_length); x.nil? ? 6 : x), Integer)
            @min_starts_with = HttpClient::Preconditions.assert_class('min_starts_with', (x = opts.delete(:min_starts_with); x.nil? ? 1 : x), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderNumberGeneratorDefaults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :starts_with => starts_with,
              :min_hex_length => min_hex_length,
              :min_starts_with => min_starts_with
            }
          end

        end

        class OrderNumberGeneratorFixedLength

          attr_reader :length, :padding

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:length, :padding], 'OrderNumberGeneratorFixedLength')
            @length = HttpClient::Preconditions.assert_class('length', opts.delete(:length), Integer)
            @padding = HttpClient::Preconditions.assert_class('padding', opts.delete(:padding), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderNumberGeneratorFixedLength.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :length => length,
              :padding => padding
            }
          end

        end

        # Hexadecimal generator generates a random string, starting with a letter, of a
        # given length
        class OrderNumberGeneratorHexadecimal < OrderNumberGenerator

          attr_reader :length

          def initialize(incoming={})
            super(:discriminator => OrderNumberGenerator::Types::ORDER_NUMBER_GENERATOR_HEXADECIMAL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:length], 'OrderNumberGeneratorHexadecimal')
            @length = HttpClient::Preconditions.assert_class('length', opts.delete(:length), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderNumberGeneratorHexadecimal.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :length => length
            }
          end

        end

        # Generator with an optional prefix, followed by an integer and an optional
        # suffix
        class OrderNumberGeneratorPrefixSuffix < OrderNumberGenerator

          attr_reader :prefix, :starts_with, :suffix, :fixed_length

          def initialize(incoming={})
            super(:discriminator => OrderNumberGenerator::Types::ORDER_NUMBER_GENERATOR_PREFIX_SUFFIX)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @prefix = (x = opts.delete(:prefix); x.nil? ? nil : HttpClient::Preconditions.assert_class('prefix', x, String))
            @starts_with = (x = opts.delete(:starts_with); x.nil? ? nil : HttpClient::Preconditions.assert_class('starts_with', x, Integer))
            @suffix = (x = opts.delete(:suffix); x.nil? ? nil : HttpClient::Preconditions.assert_class('suffix', x, String))
            @fixed_length = (x = opts.delete(:fixed_length); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderNumberGeneratorFixedLength) ? x : ::Io::Flow::V0::Models::OrderNumberGeneratorFixedLength.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderNumberGeneratorPrefixSuffix.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :prefix => prefix,
              :starts_with => starts_with,
              :suffix => suffix,
              :fixed_length => fixed_length.nil? ? nil : fixed_length.to_hash
            }
          end

        end

        # Generates an order number based on a UUID (no dashes or other formatting).
        # This is the default for Flow orders (with order number prefixed by ord-)
        class OrderNumberGeneratorUuid < OrderNumberGenerator

          attr_reader :prefix

          def initialize(incoming={})
            super(:discriminator => OrderNumberGenerator::Types::ORDER_NUMBER_GENERATOR_UUID)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @prefix = HttpClient::Preconditions.assert_class('prefix', (x = opts.delete(:prefix); x.nil? ? "ord-" : x), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderNumberGeneratorUuid.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :prefix => prefix
            }
          end

        end

        class OrderNumberReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'OrderNumberReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderNumberReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        # An Order Payment represents an individual payment applied to an order. The
        # type of the payment can be used to further lookup transaction level detail
        class OrderPayment

          attr_reader :id, :type, :merchant_of_record, :reference, :description, :total, :address, :date, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :reference, :description, :total], 'OrderPayment')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::OrderPaymentType) ? x : ::Io::Flow::V0::Models::OrderPaymentType.apply(x))
            @merchant_of_record = (x = (x = opts.delete(:merchant_of_record); x.nil? ? "flow" : x); x.is_a?(::Io::Flow::V0::Models::MerchantOfRecord) ? x : ::Io::Flow::V0::Models::MerchantOfRecord.apply(x))
            @reference = HttpClient::Preconditions.assert_class('reference', opts.delete(:reference), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::BillingAddress) ? x : ::Io::Flow::V0::Models::BillingAddress.new(x)))
            @date = (x = opts.delete(:date); x.nil? ? nil : HttpClient::Preconditions.assert_class('date', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPayment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :merchant_of_record => merchant_of_record.value,
              :reference => reference,
              :description => description,
              :total => total.to_hash,
              :address => address.nil? ? nil : address.to_hash,
              :date => date,
              :attributes => attributes
            }
          end

        end

        # Sent when an order is submitted, allocations are generated and the total value
        # of the order is accounted for by discounts, subsidies, credits and authorized
        # payments -- but may not ready to fulfill (e.g. pending assignment of a DC or
        # fraud review). Intended to fuel customer feedback and alert merchants that an
        # order is coming.
        class OrderPlaced < Event

          attr_reader :event_id, :timestamp, :organization, :order_number, :order, :allocation

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_PLACED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :order_number, :order, :allocation], 'OrderPlaced')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
            @allocation = (x = opts.delete(:allocation); x.is_a?(::Io::Flow::V0::Models::AllocationV2) ? x : ::Io::Flow::V0::Models::AllocationV2.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPlaced.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :order_number => order_number,
              :order => order.to_hash,
              :allocation => allocation.to_hash
            }
          end

        end

        # Order is submitted, allocations are generated and the total value of the order
        # is accounted for by discounts, subsidies, credits and authorized payments --
        # but may not ready to fulfill (e.g. pending assignment of a DC or fraud
        # review).
        class OrderPlacedDetails

          attr_reader :id, :order, :allocation

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order, :allocation], 'OrderPlacedDetails')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
            @allocation = (x = opts.delete(:allocation); x.is_a?(::Io::Flow::V0::Models::AllocationV2) ? x : ::Io::Flow::V0::Models::AllocationV2.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPlacedDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :order => order.to_hash,
              :allocation => allocation.to_hash
            }
          end

        end

        # Sent when an order is submitted, allocations are generated and the total value
        # of the order is accounted for by discounts, subsidies, credits and authorized
        # payments -- but may not ready to fulfill (e.g. pending assignment of a DC or
        # fraud review). Intended to fuel customer feedback and alert merchants that an
        # order is coming.
        class OrderPlacedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :order_placed

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_PLACED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :order_placed], 'OrderPlacedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @order_placed = (x = opts.delete(:order_placed); x.is_a?(::Io::Flow::V0::Models::OrderPlacedDetails) ? x : ::Io::Flow::V0::Models::OrderPlacedDetails.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPlacedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :order_placed => order_placed.to_hash
            }
          end

        end

        # Represents a top-level order price detail, e.g. 'Subtotal' or 'VAT'.
        class OrderPriceDetail

          attr_reader :key, :currency, :amount, :label, :base, :components, :name, :rate, :accuracy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label, :base, :components], 'OrderPriceDetail')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailKey.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponent) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponent.new(x)) }
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @rate = (x = opts.delete(:rate); x.nil? ? nil : HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @accuracy = (x = (x = opts.delete(:accuracy); x.nil? ? "calculated" : x); x.is_a?(::Io::Flow::V0::Models::PriceAccuracy) ? x : ::Io::Flow::V0::Models::PriceAccuracy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPriceDetail.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :currency => currency,
              :amount => amount.to_f.to_s,
              :label => label,
              :base => base.to_hash,
              :components => components.map { |o| o.to_hash },
              :name => name,
              :rate => rate.to_f.to_s,
              :accuracy => accuracy.value
            }
          end

        end

        class OrderPriceDetailComponent

          attr_reader :key, :currency, :amount, :label, :base, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label, :base], 'OrderPriceDetailComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponentKey.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPriceDetailComponent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :currency => currency,
              :amount => amount.to_f.to_s,
              :label => label,
              :base => base.to_hash,
              :name => name
            }
          end

        end

        class OrderPromotionTrigger

          attr_reader :type, :min

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'OrderPromotionTrigger')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::PromotionTriggerType) ? x : ::Io::Flow::V0::Models::PromotionTriggerType.apply(x))
            @min = (x = opts.delete(:min); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPromotionTrigger.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :min => min.nil? ? nil : min.to_hash
            }
          end

        end

        # The order put form is used to upsert an order, providing the details on
        # pricing and delivery options for destination and items/quantities specified.
        class OrderPutForm

          attr_reader :items, :customer, :delivered_duty, :selections, :destination, :discount, :discounts, :attributes, :authorization_keys

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'OrderPutForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderCustomerForm) ? x : ::Io::Flow::V0::Models::OrderCustomerForm.new(x)))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @selections = (x = opts.delete(:selections); x.nil? ? nil : HttpClient::Preconditions.assert_class('selections', x, Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) })
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @discounts = (x = opts.delete(:discounts); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DiscountsForm) ? x : ::Io::Flow::V0::Models::DiscountsForm.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @authorization_keys = (x = opts.delete(:authorization_keys); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_keys', x, Array).map { |v| HttpClient::Preconditions.assert_class('authorization_keys', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :customer => customer.nil? ? nil : customer.to_hash,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :selections => selections.nil? ? nil : selections,
              :destination => destination.nil? ? nil : destination.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :discounts => discounts.nil? ? nil : discounts.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :authorization_keys => authorization_keys.nil? ? nil : authorization_keys
            }
          end

        end

        class OrderReference < ExpandableOrder

          attr_reader :id, :number

          def initialize(incoming={})
            super(:discriminator => ExpandableOrder::Types::ORDER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'OrderReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class OrderRuleReference

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'OrderRuleReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderRuleReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        class OrderRulesSummary

          attr_reader :applied

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:applied], 'OrderRulesSummary')
            @applied = HttpClient::Preconditions.assert_class('applied', opts.delete(:applied), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderRuleReference) ? x : ::Io::Flow::V0::Models::OrderRuleReference.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderRulesSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :applied => applied.map { |o| o.to_hash }
            }
          end

        end

        # Manual change for a shipping method used for an order. Currently only
        # available to orders with a single calculated delivery.
        class OrderServiceChange

          attr_reader :id, :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :from, :to], 'OrderServiceChange')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @from = (x = opts.delete(:from); x.is_a?(::Io::Flow::V0::Models::CarrierService) ? x : ::Io::Flow::V0::Models::CarrierService.new(x))
            @to = (x = opts.delete(:to); x.is_a?(::Io::Flow::V0::Models::CarrierService) ? x : ::Io::Flow::V0::Models::CarrierService.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderServiceChange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :from => from.to_hash,
              :to => to.to_hash
            }
          end

        end

        # Manual change for a shipping method used for an order. Currently only
        # available to orders with a single calculated delivery. To help with orders
        # with multiple deliveries, we will require verification of both the current
        # service level (from) and the new service level (to).
        class OrderServiceChangeForm

          attr_reader :from_service_id, :to_service_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from_service_id, :to_service_id], 'OrderServiceChangeForm')
            @from_service_id = HttpClient::Preconditions.assert_class('from_service_id', opts.delete(:from_service_id), String)
            @to_service_id = HttpClient::Preconditions.assert_class('to_service_id', opts.delete(:to_service_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderServiceChangeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from_service_id => from_service_id,
              :to_service_id => to_service_id
            }
          end

        end

        class OrderServiceChangeRequest < Event

          attr_reader :event_id, :timestamp, :organization, :request

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_SERVICE_CHANGE_REQUEST)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :request], 'OrderServiceChangeRequest')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @request = (x = opts.delete(:request); x.is_a?(::Io::Flow::V0::Models::OrderServiceChangeRequestData) ? x : ::Io::Flow::V0::Models::OrderServiceChangeRequestData.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderServiceChangeRequest.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :request => request.to_hash
            }
          end

        end

        class OrderServiceChangeRequestData

          attr_reader :id, :source_url, :filename

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :source_url], 'OrderServiceChangeRequestData')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @source_url = HttpClient::Preconditions.assert_class('source_url', opts.delete(:source_url), String)
            @filename = (x = opts.delete(:filename); x.nil? ? nil : HttpClient::Preconditions.assert_class('filename', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderServiceChangeRequestData.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :source_url => source_url,
              :filename => filename
            }
          end

        end

        # Optional data to be processed during order submission
        class OrderSubmissionForm

          attr_reader :identifiers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @identifiers = HttpClient::Preconditions.assert_class('identifiers', (x = opts.delete(:identifiers); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderSubmissionIdentifierForm) ? x : ::Io::Flow::V0::Models::OrderSubmissionIdentifierForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSubmissionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :identifiers => identifiers.map { |o| o.to_hash }
            }
          end

        end

        # Defines the data needed to attach an identifer to each order created by a
        # checkout.
        class OrderSubmissionIdentifierForm

          attr_reader :identifier, :primary

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:identifier], 'OrderSubmissionIdentifierForm')
            @identifier = HttpClient::Preconditions.assert_class('identifier', opts.delete(:identifier), String)
            @primary = (x = opts.delete(:primary); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('primary', x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSubmissionIdentifierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :identifier => identifier,
              :primary => primary
            }
          end

        end

        # The order summary is a view of the order summary object with the order prices
        # flattened to keys.
        class OrderSummary

          attr_reader :number, :subtotal, :shipping, :tax, :duty, :insurance, :discount, :surcharges, :adjustment, :total, :lines

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :subtotal, :total, :lines], 'OrderSummary')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @subtotal = (x = opts.delete(:subtotal); x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x))
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x)))
            @tax = (x = opts.delete(:tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x)))
            @insurance = (x = opts.delete(:insurance); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x)))
            @surcharges = (x = opts.delete(:surcharges); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x)))
            @adjustment = (x = opts.delete(:adjustment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x)))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::OrderSummaryPriceDetail) ? x : ::Io::Flow::V0::Models::OrderSummaryPriceDetail.new(x))
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderSummaryLineItem) ? x : ::Io::Flow::V0::Models::OrderSummaryLineItem.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :subtotal => subtotal.to_hash,
              :shipping => shipping.nil? ? nil : shipping.to_hash,
              :tax => tax.nil? ? nil : tax.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash,
              :insurance => insurance.nil? ? nil : insurance.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :surcharges => surcharges.nil? ? nil : surcharges.to_hash,
              :adjustment => adjustment.nil? ? nil : adjustment.to_hash,
              :total => total.to_hash,
              :lines => lines.map { |o| o.to_hash }
            }
          end

        end

        class OrderSummaryImage

          attr_reader :url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'OrderSummaryImage')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSummaryImage.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url
            }
          end

        end

        class OrderSummaryItem

          attr_reader :number, :name, :description, :attributes, :image, :price, :discount, :tax, :duty, :price_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :attributes, :price, :price_attributes], 'OrderSummaryItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CheckoutItemContentAttribute) ? x : ::Io::Flow::V0::Models::CheckoutItemContentAttribute.new(x)) }
            @image = (x = opts.delete(:image); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryImage) ? x : ::Io::Flow::V0::Models::OrderSummaryImage.new(x)))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @tax = (x = opts.delete(:tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryLevy) ? x : ::Io::Flow::V0::Models::OrderSummaryLevy.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryLevy) ? x : ::Io::Flow::V0::Models::OrderSummaryLevy.new(x)))
            @price_attributes = HttpClient::Preconditions.assert_class('price_attributes', opts.delete(:price_attributes), Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSummaryItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :name => name,
              :description => description,
              :attributes => attributes.map { |o| o.to_hash },
              :image => image.nil? ? nil : image.to_hash,
              :price => price.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :tax => tax.nil? ? nil : tax.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash,
              :price_attributes => price_attributes.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        class OrderSummaryLevy

          attr_reader :rate, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :value], 'OrderSummaryLevy')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @value = (x = opts.delete(:value); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSummaryLevy.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate.to_f.to_s,
              :value => value.to_hash
            }
          end

        end

        class OrderSummaryLineItem

          attr_reader :item, :quantity, :discount, :tax, :duty, :total, :price_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :quantity, :total, :price_attributes], 'OrderSummaryLineItem')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::OrderSummaryItem) ? x : ::Io::Flow::V0::Models::OrderSummaryItem.new(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @tax = (x = opts.delete(:tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryLevy) ? x : ::Io::Flow::V0::Models::OrderSummaryLevy.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderSummaryLevy) ? x : ::Io::Flow::V0::Models::OrderSummaryLevy.new(x)))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @price_attributes = HttpClient::Preconditions.assert_class('price_attributes', opts.delete(:price_attributes), Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSummaryLineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :quantity => quantity,
              :discount => discount.nil? ? nil : discount.to_hash,
              :tax => tax.nil? ? nil : tax.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash,
              :total => total.to_hash,
              :price_attributes => price_attributes.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        # Summaries the io.flow.order.price.v0.models.order_price_detail, removing
        # components and accuracy which are not needed for summary views
        class OrderSummaryPriceDetail

          attr_reader :price, :name, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'OrderSummaryPriceDetail')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @rate = (x = opts.delete(:rate); x.nil? ? nil : HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderSummaryPriceDetail.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price => price.to_hash,
              :name => name,
              :rate => rate.to_f.to_s
            }
          end

        end

        class OrderUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :environment, :experience_id, :expires_at, :customer, :selections, :items, :destination, :deliveries, :prices, :order_id, :payments, :discount, :delivered_duty, :total, :created_at, :updated_at, :submitted_at, :lines, :attributes, :geo, :merchant_of_record, :tax_registration

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :environment, :experience_id, :expires_at, :customer, :selections, :items, :destination, :deliveries, :prices, :total], 'OrderUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @environment = HttpClient::Preconditions.assert_class('environment', opts.delete(:environment), String)
            @experience_id = HttpClient::Preconditions.assert_class('experience_id', opts.delete(:experience_id), String)
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::OrderCustomer) ? x : ::Io::Flow::V0::Models::OrderCustomer.new(x))
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) }
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedLineItem) ? x : ::Io::Flow::V0::Models::LocalizedLineItem.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.from_json(x)) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetail) ? x : ::Io::Flow::V0::Models::OrderPriceDetail.new(x)) }
            @order_id = (x = opts.delete(:order_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_id', x, String))
            @payments = (x = opts.delete(:payments); x.nil? ? nil : HttpClient::Preconditions.assert_class('payments', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPayment) ? x : ::Io::Flow::V0::Models::OrderPayment.new(x)) })
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivered_duty', x, String))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x))
            @created_at = (x = opts.delete(:created_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @updated_at = (x = opts.delete(:updated_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('updated_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @submitted_at = (x = opts.delete(:submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @lines = (x = opts.delete(:lines); x.nil? ? nil : HttpClient::Preconditions.assert_class('lines', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Line) ? x : ::Io::Flow::V0::Models::Line.new(x)) })
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @geo = (x = opts.delete(:geo); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderGeo) ? x : ::Io::Flow::V0::Models::OrderGeo.new(x)))
            @merchant_of_record = (x = opts.delete(:merchant_of_record); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderMerchantOfRecord) ? x : ::Io::Flow::V0::Models::OrderMerchantOfRecord.apply(x)))
            @tax_registration = (x = opts.delete(:tax_registration); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TaxRegistration) ? x : ::Io::Flow::V0::Models::TaxRegistration.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :environment => environment,
              :experience_id => experience_id,
              :expires_at => expires_at,
              :customer => customer.to_hash,
              :selections => selections,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :prices => prices.map { |o| o.to_hash },
              :order_id => order_id,
              :payments => payments.nil? ? nil : payments.map { |o| o.to_hash },
              :discount => discount.nil? ? nil : discount.to_hash,
              :delivered_duty => delivered_duty,
              :total => total.to_hash,
              :created_at => created_at,
              :updated_at => updated_at,
              :submitted_at => submitted_at,
              :lines => lines.nil? ? nil : lines.map { |o| o.to_hash },
              :attributes => attributes.nil? ? nil : attributes,
              :geo => geo.nil? ? nil : geo.to_hash,
              :merchant_of_record => merchant_of_record.nil? ? nil : merchant_of_record.value,
              :tax_registration => tax_registration.nil? ? nil : tax_registration.to_hash
            }
          end

        end

        class OrderUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :order

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :order], 'OrderUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :order => order.to_hash
            }
          end

        end

        class OrderVersion

          attr_reader :id, :timestamp, :type, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :order], 'OrderVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :order => order.to_hash
            }
          end

        end

        # Represents a single organization in the system, and what environment it is
        # currently operating in.
        class Organization < ExpandableOrganization

          attr_reader :id, :name, :environment, :parent, :defaults, :created_at

          def initialize(incoming={})
            super(:discriminator => ExpandableOrganization::Types::ORGANIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :environment], 'Organization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent = (x = opts.delete(:parent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x)))
            @defaults = (x = opts.delete(:defaults); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrganizationDefaults) ? x : ::Io::Flow::V0::Models::OrganizationDefaults.new(x)))
            @created_at = (x = opts.delete(:created_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Organization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent => parent.nil? ? nil : parent.to_hash,
              :defaults => defaults.nil? ? nil : defaults.to_hash,
              :created_at => created_at
            }
          end

        end

        # Defines the data used for broad authorization of user access to org level data
        class OrganizationAuthorization

          attr_reader :role, :environment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:environment], 'OrganizationAuthorization')
            @role = (x = opts.delete(:role); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x)))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationAuthorization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.nil? ? nil : role.value,
              :environment => environment.value
            }
          end

        end

        class OrganizationAuthorizationForm

          attr_reader :organization, :environment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :environment], 'OrganizationAuthorizationForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationAuthorizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :environment => environment.value
            }
          end

        end

        class OrganizationConfigurationReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrganizationConfigurationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationConfigurationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Represents organization-specific currency conversion adjustments.
        class OrganizationCurrencySetting

          attr_reader :id, :base, :target, :margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :base, :target, :margin], 'OrganizationCurrencySetting')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @margin = HttpClient::Preconditions.assert_class('margin', HttpClient::Helper.to_big_decimal(opts.delete(:margin)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :base => base,
              :target => target,
              :margin => margin.to_f.to_s
            }
          end

        end

        # Represents the parts of an organization setting that can be updated.
        class OrganizationCurrencySettingForm

          attr_reader :base, :target, :margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :margin], 'OrganizationCurrencySettingForm')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @margin = HttpClient::Preconditions.assert_class('margin', HttpClient::Helper.to_big_decimal(opts.delete(:margin)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySettingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :margin => margin.to_f.to_s
            }
          end

        end

        class OrganizationCurrencySettingVersion

          attr_reader :id, :timestamp, :type, :organization_currency_setting

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization_currency_setting], 'OrganizationCurrencySettingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization_currency_setting = (x = opts.delete(:organization_currency_setting); x.is_a?(::Io::Flow::V0::Models::OrganizationCurrencySetting) ? x : ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySettingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization_currency_setting => organization_currency_setting.to_hash
            }
          end

        end

        class OrganizationDefaultConfigurations

          attr_reader :id, :checkout_configuration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :checkout_configuration], 'OrganizationDefaultConfigurations')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @checkout_configuration = (x = opts.delete(:checkout_configuration); x.is_a?(::Io::Flow::V0::Models::OrganizationConfigurationReference) ? x : ::Io::Flow::V0::Models::OrganizationConfigurationReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDefaultConfigurations.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :checkout_configuration => checkout_configuration.to_hash
            }
          end

        end

        class OrganizationDefaultConfigurationsDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :default_configurations

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_DEFAULT_CONFIGURATIONS_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :default_configurations], 'OrganizationDefaultConfigurationsDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @default_configurations = (x = opts.delete(:default_configurations); x.is_a?(::Io::Flow::V0::Models::OrganizationDefaultConfigurations) ? x : ::Io::Flow::V0::Models::OrganizationDefaultConfigurations.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDefaultConfigurationsDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :default_configurations => default_configurations.to_hash
            }
          end

        end

        class OrganizationDefaultConfigurationsForm

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrganizationDefaultConfigurationsForm')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDefaultConfigurationsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class OrganizationDefaultConfigurationsUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :default_configurations

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_DEFAULT_CONFIGURATIONS_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :default_configurations], 'OrganizationDefaultConfigurationsUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @default_configurations = (x = opts.delete(:default_configurations); x.is_a?(::Io::Flow::V0::Models::OrganizationDefaultConfigurations) ? x : ::Io::Flow::V0::Models::OrganizationDefaultConfigurations.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDefaultConfigurationsUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :default_configurations => default_configurations.to_hash
            }
          end

        end

        class OrganizationDefaults

          attr_reader :country, :base_currency, :language, :locale, :timezone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :base_currency, :language, :locale, :timezone], 'OrganizationDefaults')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @base_currency = HttpClient::Preconditions.assert_class('base_currency', opts.delete(:base_currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDefaults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country,
              :base_currency => base_currency,
              :language => language,
              :locale => locale,
              :timezone => timezone
            }
          end

        end

        class OrganizationDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'OrganizationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class OrganizationDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization], 'OrganizationDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::Organization) ? x : ::Io::Flow::V0::Models::Organization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization.to_hash
            }
          end

        end

        # Either id or name is required.
        class OrganizationForm

          attr_reader :id, :name, :environment, :parent_id, :defaults

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @id = (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = (x = opts.delete(:environment); x.nil? ? "production" : x); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
            @defaults = (x = opts.delete(:defaults); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrganizationDefaults) ? x : ::Io::Flow::V0::Models::OrganizationDefaults.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent_id => parent_id,
              :defaults => defaults.nil? ? nil : defaults.to_hash
            }
          end

        end

        # Data required to upsert an organization.
        class OrganizationPutForm

          attr_reader :name, :environment, :parent_id, :defaults

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
            @defaults = (x = opts.delete(:defaults); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrganizationDefaults) ? x : ::Io::Flow::V0::Models::OrganizationDefaults.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :environment => environment.nil? ? nil : environment.value,
              :parent_id => parent_id,
              :defaults => defaults.nil? ? nil : defaults.to_hash
            }
          end

        end

        class OrganizationRatesData

          attr_reader :rates

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rates], 'OrganizationRatesData')
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationRatesData.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rates => rates.map { |o| o.to_hash }
            }
          end

        end

        # Represents the full list of exchange rates in effect for an organization. This
        # is a bulk event - meaning any time an individual rate changes, we publish the
        # new complete list of exchange rates. Note this event is published a few
        # minutes after a rate is published, allowing us to aggregate multiple changes
        # in a short period of time to reduce the number of organization_rates_published
        # we publish.
        class OrganizationRatesPublished < Event

          attr_reader :event_id, :timestamp, :organization, :data

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_RATES_PUBLISHED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :data], 'OrganizationRatesPublished')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @data = (x = opts.delete(:data); x.is_a?(::Io::Flow::V0::Models::OrganizationRatesData) ? x : ::Io::Flow::V0::Models::OrganizationRatesData.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationRatesPublished.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :data => data.to_hash
            }
          end

        end

        class OrganizationReference < ExpandableOrganization

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandableOrganization::Types::ORGANIZATION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrganizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        # Represents a session created for an organization. Primary method to select an
        # experience for a given user session and ensure that experience does not change
        # throughout the user's activity. Provides authentication to objects created
        # during this session (e.g. order).
        class OrganizationSession < Session

          attr_reader :id, :organization, :visitor, :visit, :environment, :attributes, :ip, :local, :geo, :experience, :format, :experiment

          def initialize(incoming={})
            super(:discriminator => Session::Types::ORGANIZATION_SESSION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :visitor, :visit, :environment, :attributes], 'OrganizationSession')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @visitor = (x = opts.delete(:visitor); x.is_a?(::Io::Flow::V0::Models::SessionVisitor) ? x : ::Io::Flow::V0::Models::SessionVisitor.new(x))
            @visit = (x = opts.delete(:visit); x.is_a?(::Io::Flow::V0::Models::SessionVisit) ? x : ::Io::Flow::V0::Models::SessionVisit.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalSession) ? x : ::Io::Flow::V0::Models::LocalSession.new(x)))
            @geo = (x = opts.delete(:geo); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionGeo) ? x : ::Io::Flow::V0::Models::SessionGeo.new(x)))
            @experience = (x = opts.delete(:experience); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExperienceGeo) ? x : ::Io::Flow::V0::Models::ExperienceGeo.new(x)))
            @format = (x = opts.delete(:format); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionFormat) ? x : ::Io::Flow::V0::Models::SessionFormat.new(x)))
            @experiment = (x = opts.delete(:experiment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionExperiment) ? x : ::Io::Flow::V0::Models::SessionExperiment.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSession.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :organization => organization,
              :visitor => visitor.to_hash,
              :visit => visit.to_hash,
              :environment => environment.value,
              :attributes => attributes,
              :ip => ip,
              :local => local.nil? ? nil : local.to_hash,
              :geo => geo.nil? ? nil : geo.to_hash,
              :experience => experience.nil? ? nil : experience.to_hash,
              :format => format.nil? ? nil : format.to_hash,
              :experiment => experiment.nil? ? nil : experiment.to_hash
            }
          end

        end

        # Represents a session authorized access to the specified organization's data
        class OrganizationSessionAuthorization < SessionAuthorization

          attr_reader :organization, :environment

          def initialize(incoming={})
            super(:discriminator => SessionAuthorization::Types::ORGANIZATION_SESSION_AUTHORIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :environment], 'OrganizationSessionAuthorization')
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSessionAuthorization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :organization => organization.to_hash,
              :environment => environment.value
            }
          end

        end

        # A short identifier for an organization that is used to setup account IDs,
        # invoice Prefixes, etc.
        class OrganizationShortId

          attr_reader :id, :organization, :short_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :short_id], 'OrganizationShortId')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @short_id = HttpClient::Preconditions.assert_class('short_id', opts.delete(:short_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationShortId.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :short_id => short_id
            }
          end

        end

        class OrganizationShortIdDeleted < Event

          attr_reader :event_id, :timestamp, :organization_short_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_SHORT_ID_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_short_id], 'OrganizationShortIdDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_short_id = (x = opts.delete(:organization_short_id); x.is_a?(::Io::Flow::V0::Models::OrganizationShortId) ? x : ::Io::Flow::V0::Models::OrganizationShortId.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationShortIdDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_short_id => organization_short_id.to_hash
            }
          end

        end

        class OrganizationShortIdUpserted < Event

          attr_reader :event_id, :timestamp, :organization_short_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_SHORT_ID_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_short_id], 'OrganizationShortIdUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_short_id = (x = opts.delete(:organization_short_id); x.is_a?(::Io::Flow::V0::Models::OrganizationShortId) ? x : ::Io::Flow::V0::Models::OrganizationShortId.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationShortIdUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_short_id => organization_short_id.to_hash
            }
          end

        end

        class OrganizationSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'OrganizationSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        # All of the metadata associated with a given token.
        class OrganizationToken < Token

          attr_reader :id, :organization, :user, :environment, :partial, :created_at, :description

          def initialize(incoming={})
            super(:discriminator => Token::Types::ORGANIZATION_TOKEN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :user, :environment, :partial, :created_at], 'OrganizationToken')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @partial = HttpClient::Preconditions.assert_class('partial', opts.delete(:partial), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationToken.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :user => user.to_hash,
              :environment => environment.value,
              :partial => partial,
              :created_at => created_at,
              :description => description
            }
          end

        end

        # Used to create a new token. User making the request must be authorized to
        # create a token for this organization.
        class OrganizationTokenForm

          attr_reader :environment, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:environment], 'OrganizationTokenForm')
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationTokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :environment => environment.value,
              :description => description
            }
          end

        end

        # Summary data for a given token
        class OrganizationTokenReference < TokenReference

          attr_reader :id, :organization, :environment, :user

          def initialize(incoming={})
            super(:discriminator => TokenReference::Types::ORGANIZATION_TOKEN_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :environment, :user], 'OrganizationTokenReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationTokenReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :environment => environment.value,
              :user => user.to_hash
            }
          end

        end

        class OrganizationUpserted < Event

          attr_reader :event_id, :timestamp, :id, :name, :environment, :currencies, :parent_id, :default_base_currency, :default_country, :default_language, :default_locale, :default_timezone

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :name, :environment, :currencies], 'OrganizationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @environment = HttpClient::Preconditions.assert_class('environment', opts.delete(:environment), String)
            @currencies = HttpClient::Preconditions.assert_class('currencies', opts.delete(:currencies), Array).map { |v| HttpClient::Preconditions.assert_class('currencies', v, String) }
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
            @default_base_currency = (x = opts.delete(:default_base_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_base_currency', x, String))
            @default_country = (x = opts.delete(:default_country); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_country', x, String))
            @default_language = (x = opts.delete(:default_language); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_language', x, String))
            @default_locale = (x = opts.delete(:default_locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_locale', x, String))
            @default_timezone = (x = opts.delete(:default_timezone); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_timezone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :name => name,
              :environment => environment,
              :currencies => currencies,
              :parent_id => parent_id,
              :default_base_currency => default_base_currency,
              :default_country => default_country,
              :default_language => default_language,
              :default_locale => default_locale,
              :default_timezone => default_timezone
            }
          end

        end

        class OrganizationUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization], 'OrganizationUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::Organization) ? x : ::Io::Flow::V0::Models::Organization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization.to_hash
            }
          end

        end

        class OrganizationVersion

          attr_reader :id, :timestamp, :type, :organization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization], 'OrganizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::Organization) ? x : ::Io::Flow::V0::Models::Organization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization => organization.to_hash
            }
          end

        end

        # Model representing original and max values and currencies.
        class OriginalPrices

          attr_reader :value, :max

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :max], 'OriginalPrices')
            @value = (x = opts.delete(:value); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @max = (x = opts.delete(:max); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OriginalPrices.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value.to_hash,
              :max => max.to_hash
            }
          end

        end

        class OutboundCartonFee < PartnerCenterFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => PartnerCenterFee::Types::OUTBOUND_CARTON_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'OutboundCartonFee')
            @amount = (x = opts.delete(:amount); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OutboundCartonFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_hash
            }
          end

        end

        class OversizedShipmentRatecardFee < RatecardFee

          attr_reader :weight_threshold, :weight_unit, :margin, :amount

          def initialize(incoming={})
            super(:discriminator => RatecardFee::Types::OVERSIZED_SHIPMENT_RATECARD_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:weight_threshold, :weight_unit], 'OversizedShipmentRatecardFee')
            @weight_threshold = HttpClient::Preconditions.assert_class('weight_threshold', HttpClient::Helper.to_big_decimal(opts.delete(:weight_threshold)), BigDecimal)
            @weight_unit = (x = opts.delete(:weight_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @margin = (x = opts.delete(:margin); x.nil? ? nil : HttpClient::Preconditions.assert_class('margin', x, Numeric))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', x, Numeric))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OversizedShipmentRatecardFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :weight_threshold => weight_threshold.to_f.to_s,
              :weight_unit => weight_unit.value,
              :margin => margin,
              :amount => amount
            }
          end

        end

        # Represents packaging available to ship items
        class Packaging

          attr_reader :dimensions, :name, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:dimensions], 'Packaging')
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Packaging.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :dimensions => dimensions.to_hash,
              :name => name,
              :number => number
            }
          end

        end

        # Represents information about a partner (e.g. external 3PL) running the
        # fulfillment center
        class PartnerCenter

          attr_reader :partner_reference, :number, :fees

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:partner_reference], 'PartnerCenter')
            @partner_reference = (x = opts.delete(:partner_reference); x.is_a?(::Io::Flow::V0::Models::PartnerReference) ? x : ::Io::Flow::V0::Models::PartnerReference.new(x))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @fees = (x = opts.delete(:fees); x.nil? ? nil : HttpClient::Preconditions.assert_class('fees', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PartnerCenterFee) ? x : ::Io::Flow::V0::Models::PartnerCenterFee.from_json(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerCenter.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :partner_reference => partner_reference.to_hash,
              :number => number,
              :fees => fees.nil? ? nil : fees.map { |o| o.to_hash }
            }
          end

        end

        class PartnerCenterForm

          attr_reader :partner_id, :number, :fees

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:partner_id], 'PartnerCenterForm')
            @partner_id = HttpClient::Preconditions.assert_class('partner_id', opts.delete(:partner_id), String)
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @fees = (x = opts.delete(:fees); x.nil? ? nil : HttpClient::Preconditions.assert_class('fees', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PartnerCenterFee) ? x : ::Io::Flow::V0::Models::PartnerCenterFee.from_json(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerCenterForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :partner_id => partner_id,
              :number => number,
              :fees => fees.nil? ? nil : fees.map { |o| o.to_hash }
            }
          end

        end

        class PartnerReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'PartnerReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # All of the metadata associated with a given token.
        class PartnerToken < Token

          attr_reader :id, :partner, :user, :environment, :partial, :created_at, :description

          def initialize(incoming={})
            super(:discriminator => Token::Types::PARTNER_TOKEN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :partner, :user, :environment, :partial, :created_at], 'PartnerToken')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @partner = (x = opts.delete(:partner); x.is_a?(::Io::Flow::V0::Models::TokenPartnerReference) ? x : ::Io::Flow::V0::Models::TokenPartnerReference.new(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @partial = HttpClient::Preconditions.assert_class('partial', opts.delete(:partial), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerToken.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :partner => partner.to_hash,
              :user => user.to_hash,
              :environment => environment.value,
              :partial => partial,
              :created_at => created_at,
              :description => description
            }
          end

        end

        # Used to create a new token. User making the request must be authorized to
        # create a token for this partner.
        class PartnerTokenForm

          attr_reader :environment, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:environment], 'PartnerTokenForm')
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerTokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :environment => environment.value,
              :description => description
            }
          end

        end

        # Summary data for a given token
        class PartnerTokenReference < TokenReference

          attr_reader :id, :partner, :environment, :user

          def initialize(incoming={})
            super(:discriminator => TokenReference::Types::PARTNER_TOKEN_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :partner, :environment, :user], 'PartnerTokenReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @partner = (x = opts.delete(:partner); x.is_a?(::Io::Flow::V0::Models::TokenPartnerReference) ? x : ::Io::Flow::V0::Models::TokenPartnerReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerTokenReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :partner => partner.to_hash,
              :environment => environment.value,
              :user => user.to_hash
            }
          end

        end

        class PasswordChangeForm

          attr_reader :current, :new

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:current, :new], 'PasswordChangeForm')
            @current = HttpClient::Preconditions.assert_class('current', opts.delete(:current), String)
            @new = HttpClient::Preconditions.assert_class('new', opts.delete(:new), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordChangeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :current => current,
              :new => new
            }
          end

        end

        class PasswordResetForm

          attr_reader :token, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :password], 'PasswordResetForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token,
              :password => password
            }
          end

        end

        class PasswordResetRequestForm

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'PasswordResetRequestForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetRequestForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        class PaymentDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::PAYMENT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'PaymentDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Details for why a payment failed
        class PaymentError

          attr_reader :code, :messages, :codes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages, :codes], 'PaymentError')
            @code = HttpClient::Preconditions.assert_class('code', (x = opts.delete(:code); x.nil? ? "payment_error" : x), String)
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @codes = HttpClient::Preconditions.assert_class('codes', opts.delete(:codes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentErrorCode) ? x : ::Io::Flow::V0::Models::PaymentErrorCode.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :messages => messages,
              :codes => codes.map { |o| o.value }
            }
          end

        end

        # Represents a single payment method - e.g VISA or Paypal - and any associated
        # metadata required for processing
        class PaymentMethod

          attr_reader :id, :type, :name, :images, :regions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :name, :images, :regions], 'PaymentMethod')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::PaymentMethodType) ? x : ::Io::Flow::V0::Models::PaymentMethodType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @images = (x = opts.delete(:images); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImages) ? x : ::Io::Flow::V0::Models::PaymentMethodImages.new(x))
            @regions = HttpClient::Preconditions.assert_class('regions', opts.delete(:regions), Array).map { |v| HttpClient::Preconditions.assert_class('regions', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethod.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :name => name,
              :images => images.to_hash,
              :regions => regions
            }
          end

        end

        class PaymentMethodImage

          attr_reader :url, :width, :height

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url, :width, :height], 'PaymentMethodImage')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @width = HttpClient::Preconditions.assert_class('width', opts.delete(:width), Integer)
            @height = HttpClient::Preconditions.assert_class('height', opts.delete(:height), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethodImage.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :width => width,
              :height => height
            }
          end

        end

        class PaymentMethodImages

          attr_reader :small, :medium, :large

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:small, :medium, :large], 'PaymentMethodImages')
            @small = (x = opts.delete(:small); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImage) ? x : ::Io::Flow::V0::Models::PaymentMethodImage.new(x))
            @medium = (x = opts.delete(:medium); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImage) ? x : ::Io::Flow::V0::Models::PaymentMethodImage.new(x))
            @large = (x = opts.delete(:large); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImage) ? x : ::Io::Flow::V0::Models::PaymentMethodImage.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethodImages.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :small => small.to_hash,
              :medium => medium.to_hash,
              :large => large.to_hash
            }
          end

        end

        class PaymentMethodIssuer

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'PaymentMethodIssuer')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethodIssuer.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class PaymentMethodRule

          attr_reader :tags, :payment_method, :display_position, :content, :issuers, :programs, :q

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tags, :payment_method, :display_position, :programs], 'PaymentMethodRule')
            @tags = HttpClient::Preconditions.assert_class('tags', opts.delete(:tags), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentMethodTag) ? x : ::Io::Flow::V0::Models::PaymentMethodTag.from_json(x)) }
            @payment_method = (x = opts.delete(:payment_method); x.is_a?(::Io::Flow::V0::Models::PaymentMethod) ? x : ::Io::Flow::V0::Models::PaymentMethod.new(x))
            @display_position = HttpClient::Preconditions.assert_class('display_position', opts.delete(:display_position), Integer)
            @content = (x = opts.delete(:content); x.nil? ? nil : HttpClient::Preconditions.assert_class('content', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentMethodRuleContent) ? x : ::Io::Flow::V0::Models::PaymentMethodRuleContent.new(x)) })
            @issuers = (x = opts.delete(:issuers); x.nil? ? nil : HttpClient::Preconditions.assert_class('issuers', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentMethodIssuer) ? x : ::Io::Flow::V0::Models::PaymentMethodIssuer.new(x)) })
            @programs = HttpClient::Preconditions.assert_class('programs', opts.delete(:programs), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::InstallmentProgramSummary) ? x : ::Io::Flow::V0::Models::InstallmentProgramSummary.new(x)) }
            @q = (x = opts.delete(:q); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Query) ? x : ::Io::Flow::V0::Models::Query.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethodRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tags => tags.map { |o| o.to_hash },
              :payment_method => payment_method.to_hash,
              :display_position => display_position,
              :content => content.nil? ? nil : content.map { |o| o.to_hash },
              :issuers => issuers.nil? ? nil : issuers.map { |o| o.to_hash },
              :programs => programs.map { |o| o.to_hash },
              :q => q.nil? ? nil : q.to_hash
            }
          end

        end

        class PaymentMethodRuleContent

          attr_reader :key, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :value], 'PaymentMethodRuleContent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::PaymentMethodRuleContentKey) ? x : ::Io::Flow::V0::Models::PaymentMethodRuleContentKey.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethodRuleContent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :value => value
            }
          end

        end

        # Represents an online payment processed through PayPal.
        class PaymentPaypal < Payment

          attr_reader :id, :order, :amount, :currency, :paypal

          def initialize(incoming={})
            super(:discriminator => Payment::Types::PAYMENT_PAYPAL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :amount, :currency, :paypal], 'PaymentPaypal')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationOrderReference) ? x : ::Io::Flow::V0::Models::AuthorizationOrderReference.new(x)))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @paypal = (x = opts.delete(:paypal); x.is_a?(::Io::Flow::V0::Models::PaymentPaypalData) ? x : ::Io::Flow::V0::Models::PaymentPaypalData.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentPaypal.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :order => order.nil? ? nil : order.to_hash,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :paypal => paypal.to_hash
            }
          end

        end

        # Represents on line payment
        class PaymentPaypalData

          attr_reader :payment_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:payment_id], 'PaymentPaypalData')
            @payment_id = HttpClient::Preconditions.assert_class('payment_id', opts.delete(:payment_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentPaypalData.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :payment_id => payment_id
            }
          end

        end

        class PaymentReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'PaymentReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Represents confirmation details & any additional confirmation actions required
        # to execute the payment.
        class PaymentSourceConfirmationAction

          attr_reader :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'PaymentSourceConfirmationAction')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::PaymentSourceConfirmationActionType) ? x : ::Io::Flow::V0::Models::PaymentSourceConfirmationActionType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentSourceConfirmationAction.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value
            }
          end

        end

        class PaymentUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :payment

          def initialize(incoming={})
            super(:discriminator => Event::Types::PAYMENT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :payment], 'PaymentUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @payment = (x = opts.delete(:payment); x.is_a?(::Io::Flow::V0::Models::Payment) ? x : ::Io::Flow::V0::Models::Payment.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :payment => payment.to_hash
            }
          end

        end

        class PaymentVersion

          attr_reader :id, :timestamp, :type, :payment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :payment], 'PaymentVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @payment = (x = opts.delete(:payment); x.is_a?(::Io::Flow::V0::Models::Payment) ? x : ::Io::Flow::V0::Models::Payment.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :payment => payment.to_hash
            }
          end

        end

        # Represents on line payment
        class PaypalAuthorizationDetails < OnlineAuthorizationDetails

          attr_reader :payment_id

          def initialize(incoming={})
            super(:discriminator => OnlineAuthorizationDetails::Types::PAYPAL_AUTHORIZATION_DETAILS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:payment_id], 'PaypalAuthorizationDetails')
            @payment_id = HttpClient::Preconditions.assert_class('payment_id', opts.delete(:payment_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaypalAuthorizationDetails.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :payment_id => payment_id
            }
          end

        end

        # Executes the PayPal payment
        class PaypalAuthorizationForm < AuthorizationForm

          attr_reader :paypal_payment_id, :paypal_payer_id, :key, :attributes, :ip

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::PAYPAL_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:paypal_payment_id, :paypal_payer_id], 'PaypalAuthorizationForm')
            @paypal_payment_id = HttpClient::Preconditions.assert_class('paypal_payment_id', opts.delete(:paypal_payment_id), String)
            @paypal_payer_id = HttpClient::Preconditions.assert_class('paypal_payer_id', opts.delete(:paypal_payer_id), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaypalAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :paypal_payment_id => paypal_payment_id,
              :paypal_payer_id => paypal_payer_id,
              :key => key,
              :attributes => attributes.nil? ? nil : attributes,
              :ip => ip
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin percentage
        class PercentMargin < TierRuleOutcome

          attr_reader :percentage

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::PERCENT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:percentage], 'PercentMargin')
            @percentage = HttpClient::Preconditions.assert_class('percentage', opts.delete(:percentage), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PercentMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :percentage => percentage
            }
          end

        end

        # Returns all known permissions, along with their authorization technique and
        # all of the roles which contain them.
        class PermissionAudit

          attr_reader :routes, :behaviors

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:routes, :behaviors], 'PermissionAudit')
            @routes = HttpClient::Preconditions.assert_class('routes', opts.delete(:routes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RouteAudit) ? x : ::Io::Flow::V0::Models::RouteAudit.new(x)) }
            @behaviors = HttpClient::Preconditions.assert_class('behaviors', opts.delete(:behaviors), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::BehaviorAudit) ? x : ::Io::Flow::V0::Models::BehaviorAudit.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PermissionAudit.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :routes => routes.map { |o| o.to_hash },
              :behaviors => behaviors.map { |o| o.to_hash }
            }
          end

        end

        # Used to test an integration's permissions, including identifying the
        # authentication technique that will be used for similar requests.
        class PermissionCheck

          attr_reader :authentication_technique, :user, :roles, :behaviors, :routes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authentication_technique, :roles, :behaviors, :routes], 'PermissionCheck')
            @authentication_technique = (x = opts.delete(:authentication_technique); x.is_a?(::Io::Flow::V0::Models::AuthenticationTechnique) ? x : ::Io::Flow::V0::Models::AuthenticationTechnique.apply(x))
            @user = (x = opts.delete(:user); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExpandableUser) ? x : ::Io::Flow::V0::Models::ExpandableUser.from_json(x)))
            @roles = HttpClient::Preconditions.assert_class('roles', opts.delete(:roles), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) }
            @behaviors = HttpClient::Preconditions.assert_class('behaviors', opts.delete(:behaviors), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowBehavior) ? x : ::Io::Flow::V0::Models::FlowBehavior.apply(x)) }
            @routes = HttpClient::Preconditions.assert_class('routes', opts.delete(:routes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PermittedRoute) ? x : ::Io::Flow::V0::Models::PermittedRoute.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PermissionCheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :authentication_technique => authentication_technique.value,
              :user => user.nil? ? nil : user.to_hash,
              :roles => roles.map { |o| o.to_hash },
              :behaviors => behaviors.map { |o| o.value },
              :routes => routes.map { |o| o.to_hash }
            }
          end

        end

        # Returned if no permissions are available for a request.
        class PermissionError

          attr_reader :code, :messages, :granting_roles, :admin_users

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'PermissionError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::GenericErrorCode) ? x : ::Io::Flow::V0::Models::GenericErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @granting_roles = (x = opts.delete(:granting_roles); x.nil? ? nil : HttpClient::Preconditions.assert_class('granting_roles', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) })
            @admin_users = (x = opts.delete(:admin_users); x.nil? ? nil : HttpClient::Preconditions.assert_class('admin_users', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::User) ? x : ::Io::Flow::V0::Models::User.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PermissionError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :granting_roles => granting_roles.nil? ? nil : granting_roles.map { |o| o.to_hash },
              :admin_users => admin_users.nil? ? nil : admin_users.map { |o| o.to_hash }
            }
          end

        end

        # A Flow API route and method.
        class PermittedRoute

          attr_reader :method, :path

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:method, :path], 'PermittedRoute')
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::PermittedHttpMethod) ? x : ::Io::Flow::V0::Models::PermittedHttpMethod.apply(x))
            @path = HttpClient::Preconditions.assert_class('path', opts.delete(:path), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PermittedRoute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :method => method.value,
              :path => path
            }
          end

        end

        class PfsInventoryCheckResponse

          attr_reader :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'PfsInventoryCheckResponse')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::PfsInventoryCheckResponseItem) ? x : ::Io::Flow::V0::Models::PfsInventoryCheckResponseItem.new(x)); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PfsInventoryCheckResponse.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        class PfsInventoryCheckResponseItem

          attr_reader :number, :ats, :in_stock

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :ats, :in_stock], 'PfsInventoryCheckResponseItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @ats = HttpClient::Preconditions.assert_class('ats', opts.delete(:ats), Integer)
            @in_stock = HttpClient::Preconditions.assert_boolean('in_stock', opts.delete(:in_stock))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PfsInventoryCheckResponseItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :ats => ats,
              :in_stock => in_stock
            }
          end

        end

        class PfsInventoryStatus

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'PfsInventoryStatus')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PfsInventoryStatus.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class PhysicalDelivery < Delivery

          attr_reader :id, :key, :center, :items, :options, :special_services, :prices, :total, :goods_supply

          def initialize(incoming={})
            super(:discriminator => Delivery::Types::PHYSICAL_DELIVERY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :options], 'PhysicalDelivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @center = (x = opts.delete(:center); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CenterSummary) ? x : ::Io::Flow::V0::Models::CenterSummary.new(x)))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryItem) ? x : ::Io::Flow::V0::Models::DeliveryItem.new(x)) }
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOption) ? x : ::Io::Flow::V0::Models::DeliveryOption.new(x)) }
            @special_services = (x = opts.delete(:special_services); x.nil? ? nil : HttpClient::Preconditions.assert_class('special_services', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PhysicalDeliverySpecialSerivce) ? x : ::Io::Flow::V0::Models::PhysicalDeliverySpecialSerivce.apply(x)) })
            @prices = (x = opts.delete(:prices); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetail) ? x : ::Io::Flow::V0::Models::OrderPriceDetail.new(x)) })
            @total = (x = opts.delete(:total); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x)))
            @goods_supply = (x = opts.delete(:goods_supply); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::GoodsSupply) ? x : ::Io::Flow::V0::Models::GoodsSupply.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PhysicalDelivery.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :center => center.nil? ? nil : center.to_hash,
              :items => items.map { |o| o.to_hash },
              :options => options.map { |o| o.to_hash },
              :special_services => special_services.nil? ? nil : special_services.map { |o| o.value },
              :prices => prices.nil? ? nil : prices.map { |o| o.to_hash },
              :total => total.nil? ? nil : total.to_hash,
              :goods_supply => goods_supply.nil? ? nil : goods_supply.value
            }
          end

        end

        # The URLs to which the customer will be redirected based on the authorization
        # status.
        class PostPaymentRedirectUrls

          attr_reader :success, :failure

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:success], 'PostPaymentRedirectUrls')
            @success = HttpClient::Preconditions.assert_class('success', opts.delete(:success), String)
            @failure = (x = opts.delete(:failure); x.nil? ? nil : HttpClient::Preconditions.assert_class('failure', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PostPaymentRedirectUrls.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :success => success,
              :failure => failure
            }
          end

        end

        # Represents an amount-currency pair for a basic price
        class Price

          attr_reader :amount, :currency, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency, :label], 'Price')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Price.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency,
              :label => label
            }
          end

        end

        # Represents a list of target prices in a specific currency that can override
        # any subset of item prices within an experience.
        class PriceBook

          attr_reader :id, :key, :currency, :name, :includes, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :currency, :name, :includes, :status], 'PriceBook')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @includes = (x = opts.delete(:includes); x.is_a?(::Io::Flow::V0::Models::IncludedLevies) ? x : ::Io::Flow::V0::Models::IncludedLevies.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::PriceBookStatus) ? x : ::Io::Flow::V0::Models::PriceBookStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBook.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :currency => currency,
              :name => name,
              :includes => includes.to_hash,
              :status => status.value
            }
          end

        end

        class PriceBookDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICE_BOOK_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'PriceBookDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Represents a price book for a specific currency that can override any subset
        # of item prices within an experience.
        class PriceBookForm

          attr_reader :currency, :name, :includes, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :name, :includes], 'PriceBookForm')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @includes = (x = opts.delete(:includes); x.is_a?(::Io::Flow::V0::Models::IncludedLevyKey) ? x : ::Io::Flow::V0::Models::IncludedLevyKey.apply(x))
            @status = (x = (x = opts.delete(:status); x.nil? ? "draft" : x); x.is_a?(::Io::Flow::V0::Models::PriceBookStatus) ? x : ::Io::Flow::V0::Models::PriceBookStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :name => name,
              :includes => includes.value,
              :status => status.value
            }
          end

        end

        # Represents the price of a single item within a price book.
        class PriceBookItem

          attr_reader :id, :key, :price_book, :price, :item_number, :schedule, :item_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :price_book, :price, :item_number, :schedule], 'PriceBookItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @price_book = (x = opts.delete(:price_book); x.is_a?(::Io::Flow::V0::Models::PriceBookReference) ? x : ::Io::Flow::V0::Models::PriceBookReference.new(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::PriceBookItemSchedule) ? x : ::Io::Flow::V0::Models::PriceBookItemSchedule.new(x))
            @item_attributes = (x = opts.delete(:item_attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('item_attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :price_book => price_book.to_hash,
              :price => price.to_hash,
              :item_number => item_number,
              :schedule => schedule.to_hash,
              :item_attributes => item_attributes.nil? ? nil : item_attributes
            }
          end

        end

        class PriceBookItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICE_BOOK_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'PriceBookItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Defines the filters that can be applied when requesting a price book item data
        # export
        class PriceBookItemExportType < ExportType

          attr_reader :price_book_key, :item_numbers, :start_date, :end_date

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::PRICE_BOOK_ITEM_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @price_book_key = (x = opts.delete(:price_book_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('price_book_key', x, String))
            @item_numbers = (x = opts.delete(:item_numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_numbers', v, String) })
            @start_date = (x = opts.delete(:start_date); x.nil? ? nil : HttpClient::Preconditions.assert_class('start_date', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @end_date = (x = opts.delete(:end_date); x.nil? ? nil : HttpClient::Preconditions.assert_class('end_date', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookItemExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price_book_key => price_book_key,
              :item_numbers => item_numbers.nil? ? nil : item_numbers,
              :start_date => start_date,
              :end_date => end_date
            }
          end

        end

        # Represents the form to create an item in a pricebook.
        class PriceBookItemForm

          attr_reader :price_book_key, :item_number, :amount, :schedule, :item_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price_book_key, :item_number, :amount], 'PriceBookItemForm')
            @price_book_key = HttpClient::Preconditions.assert_class('price_book_key', opts.delete(:price_book_key), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @schedule = (x = opts.delete(:schedule); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceBookItemSchedule) ? x : ::Io::Flow::V0::Models::PriceBookItemSchedule.new(x)))
            @item_attributes = (x = opts.delete(:item_attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('item_attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price_book_key => price_book_key,
              :item_number => item_number,
              :amount => amount.to_f.to_s,
              :schedule => schedule.nil? ? nil : schedule.to_hash,
              :item_attributes => item_attributes.nil? ? nil : item_attributes
            }
          end

        end

        # Used to create price book items for multiple items matching a query
        class PriceBookItemQueryForm

          attr_reader :price_book_key, :item_query, :amount, :schedule, :item_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price_book_key, :item_query, :amount], 'PriceBookItemQueryForm')
            @price_book_key = HttpClient::Preconditions.assert_class('price_book_key', opts.delete(:price_book_key), String)
            @item_query = HttpClient::Preconditions.assert_class('item_query', opts.delete(:item_query), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @schedule = (x = opts.delete(:schedule); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceBookItemSchedule) ? x : ::Io::Flow::V0::Models::PriceBookItemSchedule.new(x)))
            @item_attributes = (x = opts.delete(:item_attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('item_attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookItemQueryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price_book_key => price_book_key,
              :item_query => item_query,
              :amount => amount.to_f.to_s,
              :schedule => schedule.nil? ? nil : schedule.to_hash,
              :item_attributes => item_attributes.nil? ? nil : item_attributes
            }
          end

        end

        # Represents schedule applied to a price book item
        class PriceBookItemSchedule

          attr_reader :starts_at, :ends_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:starts_at], 'PriceBookItemSchedule')
            @starts_at = HttpClient::Preconditions.assert_class('starts_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:starts_at)), DateTime)
            @ends_at = (x = opts.delete(:ends_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('ends_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookItemSchedule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :starts_at => starts_at,
              :ends_at => ends_at
            }
          end

        end

        class PriceBookItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :price_book_item

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICE_BOOK_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :price_book_item], 'PriceBookItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @price_book_item = (x = opts.delete(:price_book_item); x.is_a?(::Io::Flow::V0::Models::PriceBookItem) ? x : ::Io::Flow::V0::Models::PriceBookItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :price_book_item => price_book_item.to_hash
            }
          end

        end

        class PriceBookReference

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'PriceBookReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        class PriceBookUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :price_book

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICE_BOOK_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :price_book], 'PriceBookUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @price_book = (x = opts.delete(:price_book); x.is_a?(::Io::Flow::V0::Models::PriceBook) ? x : ::Io::Flow::V0::Models::PriceBook.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceBookUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :price_book => price_book.to_hash
            }
          end

        end

        class PriceCheck

          attr_reader :display, :final

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:display, :final], 'PriceCheck')
            @display = (x = opts.delete(:display); x.is_a?(::Io::Flow::V0::Models::LocalPriceDetails) ? x : ::Io::Flow::V0::Models::LocalPriceDetails.new(x))
            @final = (x = opts.delete(:final); x.is_a?(::Io::Flow::V0::Models::LocalPriceDetails) ? x : ::Io::Flow::V0::Models::LocalPriceDetails.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceCheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :display => display.to_hash,
              :final => final.to_hash
            }
          end

        end

        # Represents a top-level price detail, e.g. 'Subtotal' or 'VAT'.
        class PriceDetail

          attr_reader :key, :components, :amount, :label, :name, :basis

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :components, :amount, :label], 'PriceDetail')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::PriceDetailKey) ? x : ::Io::Flow::V0::Models::PriceDetailKey.apply(x))
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PriceDetailComponent) ? x : ::Io::Flow::V0::Models::PriceDetailComponent.new(x)) }
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @basis = (x = opts.delete(:basis); x.nil? ? nil : HttpClient::Preconditions.assert_class('basis', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceDetail.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :components => components.map { |o| o.to_hash },
              :amount => amount.to_f.to_s,
              :label => label,
              :name => name,
              :basis => basis.to_f.to_s
            }
          end

        end

        class PriceDetailComponent

          attr_reader :key, :amount, :label, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :amount, :label], 'PriceDetailComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::PriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::PriceDetailComponentKey.apply(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceDetailComponent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :amount => amount.to_f.to_s,
              :label => label,
              :name => name
            }
          end

        end

        # Detailed information for the pricing of a given item within an experience.
        class PriceDetails

          attr_reader :currency, :item_price, :margins, :vat, :duty, :rounding, :price, :total, :adjustment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :item_price, :margins, :vat, :duty, :rounding, :price, :total], 'PriceDetails')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @item_price = (x = opts.delete(:item_price); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @margins = (x = opts.delete(:margins); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @vat = (x = opts.delete(:vat); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @rounding = (x = opts.delete(:rounding); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @adjustment = (x = opts.delete(:adjustment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :item_price => item_price.to_hash,
              :margins => margins.to_hash,
              :vat => vat.to_hash,
              :duty => duty.to_hash,
              :rounding => rounding.to_hash,
              :price => price.to_hash,
              :total => total.to_hash,
              :adjustment => adjustment.nil? ? nil : adjustment.to_hash
            }
          end

        end

        class PriceEquation

          attr_reader :contracted_rate, :rate, :pricing, :base_price, :discount, :fixed_margin, :percent_margin, :insurance, :freight, :duty, :tax, :percent_sales_margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contracted_rate, :rate, :pricing, :base_price, :discount, :fixed_margin, :percent_margin, :insurance, :freight], 'PriceEquation')
            @contracted_rate = HttpClient::Preconditions.assert_class('contracted_rate', HttpClient::Helper.to_big_decimal(opts.delete(:contracted_rate)), BigDecimal)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @pricing = (x = opts.delete(:pricing); x.is_a?(::Io::Flow::V0::Models::Pricing) ? x : ::Io::Flow::V0::Models::Pricing.new(x))
            @base_price = HttpClient::Preconditions.assert_class('base_price', HttpClient::Helper.to_big_decimal(opts.delete(:base_price)), BigDecimal)
            @discount = HttpClient::Preconditions.assert_class('discount', HttpClient::Helper.to_big_decimal(opts.delete(:discount)), BigDecimal)
            @fixed_margin = HttpClient::Preconditions.assert_class('fixed_margin', HttpClient::Helper.to_big_decimal(opts.delete(:fixed_margin)), BigDecimal)
            @percent_margin = HttpClient::Preconditions.assert_class('percent_margin', HttpClient::Helper.to_big_decimal(opts.delete(:percent_margin)), BigDecimal)
            @insurance = HttpClient::Preconditions.assert_class('insurance', HttpClient::Helper.to_big_decimal(opts.delete(:insurance)), BigDecimal)
            @freight = HttpClient::Preconditions.assert_class('freight', HttpClient::Helper.to_big_decimal(opts.delete(:freight)), BigDecimal)
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x)))
            @tax = (x = opts.delete(:tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x)))
            @percent_sales_margin = HttpClient::Preconditions.assert_class('percent_sales_margin', HttpClient::Helper.to_big_decimal((x = opts.delete(:percent_sales_margin); x.nil? ? 0 : x)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceEquation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contracted_rate => contracted_rate.to_f.to_s,
              :rate => rate.to_f.to_s,
              :pricing => pricing.to_hash,
              :base_price => base_price.to_f.to_s,
              :discount => discount.to_f.to_s,
              :fixed_margin => fixed_margin.to_f.to_s,
              :percent_margin => percent_margin.to_f.to_s,
              :insurance => insurance.to_f.to_s,
              :freight => freight.to_f.to_s,
              :duty => duty.nil? ? nil : duty.to_hash,
              :tax => tax.nil? ? nil : tax.to_hash,
              :percent_sales_margin => percent_sales_margin.to_f.to_s
            }
          end

        end

        # Amount-currency paid for a basic price to be used in model forms, before a
        # price label is created. Label in the main price model is created by the
        # implementing api.
        class PriceForm

          attr_reader :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'PriceForm')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency
            }
          end

        end

        class PriceSourceCatalog < PriceSource

          attr_reader :price

          def initialize(incoming={})
            super(:discriminator => PriceSource::Types::PRICE_SOURCE_CATALOG)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'PriceSourceCatalog')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceSourceCatalog.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        class PriceSourcePriceBook < PriceSource

          attr_reader :price, :includes, :price_book_reference

          def initialize(incoming={})
            super(:discriminator => PriceSource::Types::PRICE_SOURCE_PRICE_BOOK)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price, :includes, :price_book_reference], 'PriceSourcePriceBook')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @includes = (x = opts.delete(:includes); x.is_a?(::Io::Flow::V0::Models::IncludedLevies) ? x : ::Io::Flow::V0::Models::IncludedLevies.new(x))
            @price_book_reference = (x = opts.delete(:price_book_reference); x.is_a?(::Io::Flow::V0::Models::PriceSourcePriceBookReference) ? x : ::Io::Flow::V0::Models::PriceSourcePriceBookReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceSourcePriceBook.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash,
              :includes => includes.to_hash,
              :price_book_reference => price_book_reference.to_hash
            }
          end

        end

        class PriceSourcePriceBookReference

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'PriceSourcePriceBookReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceSourcePriceBookReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        class PriceSourceProvided < PriceSource

          attr_reader :price

          def initialize(incoming={})
            super(:discriminator => PriceSource::Types::PRICE_SOURCE_PROVIDED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'PriceSourceProvided')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceSourceProvided.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        class PriceWithBase

          attr_reader :currency, :amount, :label, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label], 'PriceWithBase')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceWithBase.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        class PriceWithBaseAndDetails

          attr_reader :currency, :amount, :label, :base, :details

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label], 'PriceWithBaseAndDetails')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
            @details = (x = opts.delete(:details); x.nil? ? nil : HttpClient::Preconditions.assert_class('details', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOptionCostDetail) ? x : ::Io::Flow::V0::Models::DeliveryOptionCostDetail.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceWithBaseAndDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.nil? ? nil : base.to_hash,
              :details => details.nil? ? nil : details.map { |o| o.to_hash }
            }
          end

        end

        # Pricing determines how the item price is calculated when items are requests
        # via the experience.
        class Pricing

          attr_reader :vat, :duty, :rounding

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:vat, :duty], 'Pricing')
            @vat = (x = opts.delete(:vat); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
            @rounding = (x = opts.delete(:rounding); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Pricing.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :vat => vat.value,
              :duty => duty.value,
              :rounding => rounding.nil? ? nil : rounding.to_hash
            }
          end

        end

        class PricingDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICING_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key], 'PricingDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PricingDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key
            }
          end

        end

        class PricingSettings

          attr_reader :editable, :default_tax_display, :default_duty_display

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:editable, :default_tax_display, :default_duty_display], 'PricingSettings')
            @editable = HttpClient::Preconditions.assert_boolean('editable', opts.delete(:editable))
            @default_tax_display = (x = opts.delete(:default_tax_display); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
            @default_duty_display = (x = opts.delete(:default_duty_display); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PricingSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :editable => editable,
              :default_tax_display => default_tax_display.value,
              :default_duty_display => default_duty_display.value
            }
          end

        end

        class PricingUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key, :vat, :duty, :rounding_type, :rounding_method, :rounding_value

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICING_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key, :vat, :duty], 'PricingUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @vat = HttpClient::Preconditions.assert_class('vat', opts.delete(:vat), String)
            @duty = HttpClient::Preconditions.assert_class('duty', opts.delete(:duty), String)
            @rounding_type = (x = opts.delete(:rounding_type); x.nil? ? nil : HttpClient::Preconditions.assert_class('rounding_type', x, String))
            @rounding_method = (x = opts.delete(:rounding_method); x.nil? ? nil : HttpClient::Preconditions.assert_class('rounding_method', x, String))
            @rounding_value = (x = opts.delete(:rounding_value); x.nil? ? nil : HttpClient::Preconditions.assert_class('rounding_value', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PricingUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key,
              :vat => vat,
              :duty => duty,
              :rounding_type => rounding_type,
              :rounding_method => rounding_method,
              :rounding_value => rounding_value.to_f.to_s
            }
          end

        end

        class ProcessingEstimate

          attr_reader :location, :min_date, :max_date, :source

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:location, :min_date, :max_date, :source], 'ProcessingEstimate')
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowLocation) ? x : ::Io::Flow::V0::Models::DeliveryWindowLocation.apply(x))
            @min_date = HttpClient::Preconditions.assert_class('min_date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:min_date)), DateTime)
            @max_date = HttpClient::Preconditions.assert_class('max_date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:max_date)), DateTime)
            @source = (x = opts.delete(:source); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowComponentSource) ? x : ::Io::Flow::V0::Models::DeliveryWindowComponentSource.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ProcessingEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :location => location.value,
              :min_date => min_date,
              :max_date => max_date,
              :source => source.value
            }
          end

        end

        class PromotionTrigger

          attr_reader :type, :min, :remaining

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :min, :remaining], 'PromotionTrigger')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::PromotionTriggerType) ? x : ::Io::Flow::V0::Models::PromotionTriggerType.apply(x))
            @min = (x = opts.delete(:min); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @remaining = (x = opts.delete(:remaining); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PromotionTrigger.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :min => min.to_hash,
              :remaining => remaining.to_hash
            }
          end

        end

        class PromotionTriggerForm

          attr_reader :type, :min

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'PromotionTriggerForm')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::PromotionTriggerType) ? x : ::Io::Flow::V0::Models::PromotionTriggerType.apply(x))
            @min = (x = opts.delete(:min); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceForm) ? x : ::Io::Flow::V0::Models::PriceForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PromotionTriggerForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :min => min.nil? ? nil : min.to_hash
            }
          end

        end

        class Promotions

          attr_reader :applied, :available

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:applied, :available], 'Promotions')
            @applied = HttpClient::Preconditions.assert_class('applied', opts.delete(:applied), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Promotion) ? x : ::Io::Flow::V0::Models::Promotion.from_json(x)) }
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Promotion) ? x : ::Io::Flow::V0::Models::Promotion.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Promotions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :applied => applied.map { |o| o.to_hash },
              :available => available.map { |o| o.to_hash }
            }
          end

        end

        # A subdivision/province/state within a country. These conform to the ISO 3166-2
        # standard for country subdivisions. See https://api.flow.io/reference/provinces
        class Province

          attr_reader :id, :iso_3166_2, :name, :country, :province_type, :translations

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :iso_3166_2, :name, :country, :province_type], 'Province')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @iso_3166_2 = HttpClient::Preconditions.assert_class('iso_3166_2', opts.delete(:iso_3166_2), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @province_type = (x = opts.delete(:province_type); x.is_a?(::Io::Flow::V0::Models::ProvinceType) ? x : ::Io::Flow::V0::Models::ProvinceType.apply(x))
            @translations = (x = opts.delete(:translations); x.nil? ? nil : HttpClient::Preconditions.assert_class('translations', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedTranslation) ? x : ::Io::Flow::V0::Models::LocalizedTranslation.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Province.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :iso_3166_2 => iso_3166_2,
              :name => name,
              :country => country,
              :province_type => province_type.value,
              :translations => translations.nil? ? nil : translations.map { |o| o.to_hash }
            }
          end

        end

        # A public key is used to encrypt cards client side prior to submitting to the
        # Flow vault.
        class PublicKey

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'PublicKey')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PublicKey.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # The query model is used to present a query to a user, containing both the raw
        # query as well as the filter representation of the query.
        class Query

          attr_reader :q, :filters

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :filters], 'Query')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @filters = HttpClient::Preconditions.assert_class('filters', opts.delete(:filters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::QueryFilter) ? x : ::Io::Flow::V0::Models::QueryFilter.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Query.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :filters => filters.map { |o| o.to_hash }
            }
          end

        end

        # The query builder model is used to build a query using structured filters. The
        # end result is a single 'q' string - e.g. 'category:jewelry and brand:Flow'
        class QueryBuilder

          attr_reader :q, :filters, :available

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :filters, :available], 'QueryBuilder')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @filters = HttpClient::Preconditions.assert_class('filters', opts.delete(:filters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::QueryFilter) ? x : ::Io::Flow::V0::Models::QueryFilter.from_json(x)) }
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableFilter) ? x : ::Io::Flow::V0::Models::AvailableFilter.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryBuilder.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :filters => filters.map { |o| o.to_hash },
              :available => available.map { |o| o.to_hash }
            }
          end

        end

        class QueryBuilderFilterForm < QueryBuilderForm

          attr_reader :filters

          def initialize(incoming={})
            super(:discriminator => QueryBuilderForm::Types::QUERY_BUILDER_FILTER_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:filters], 'QueryBuilderFilterForm')
            @filters = HttpClient::Preconditions.assert_class('filters', opts.delete(:filters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::QueryFilterForm) ? x : ::Io::Flow::V0::Models::QueryFilterForm.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryBuilderFilterForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :filters => filters.map { |o| o.to_hash }
            }
          end

        end

        class QueryBuilderQueryForm < QueryBuilderForm

          attr_reader :q

          def initialize(incoming={})
            super(:discriminator => QueryBuilderForm::Types::QUERY_BUILDER_QUERY_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q], 'QueryBuilderQueryForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryBuilderQueryForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :q => q
            }
          end

        end

        class QueryFilterStructured < QueryFilter

          attr_reader :q, :field, :operator, :values

          def initialize(incoming={})
            super(:discriminator => QueryFilter::Types::QUERY_FILTER_STRUCTURED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :field, :operator, :values], 'QueryFilterStructured')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @field = HttpClient::Preconditions.assert_class('field', opts.delete(:field), String)
            @operator = HttpClient::Preconditions.assert_class('operator', opts.delete(:operator), String)
            @values = HttpClient::Preconditions.assert_class('values', opts.delete(:values), Array).map { |v| HttpClient::Preconditions.assert_class('values', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryFilterStructured.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :q => q,
              :field => field,
              :operator => operator,
              :values => values
            }
          end

        end

        class QueryFilterStructuredForm < QueryFilterForm

          attr_reader :field, :operator, :values

          def initialize(incoming={})
            super(:discriminator => QueryFilterForm::Types::QUERY_FILTER_STRUCTURED_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:field, :operator, :values], 'QueryFilterStructuredForm')
            @field = HttpClient::Preconditions.assert_class('field', opts.delete(:field), String)
            @operator = HttpClient::Preconditions.assert_class('operator', opts.delete(:operator), String)
            @values = HttpClient::Preconditions.assert_class('values', opts.delete(:values), Array).map { |v| HttpClient::Preconditions.assert_class('values', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryFilterStructuredForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :field => field,
              :operator => operator,
              :values => values
            }
          end

        end

        class QueryFilterUnstructured < QueryFilter

          attr_reader :q

          def initialize(incoming={})
            super(:discriminator => QueryFilter::Types::QUERY_FILTER_UNSTRUCTURED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q], 'QueryFilterUnstructured')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryFilterUnstructured.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :q => q
            }
          end

        end

        class QueryFilterUnstructuredForm < QueryFilterForm

          attr_reader :q

          def initialize(incoming={})
            super(:discriminator => QueryFilterForm::Types::QUERY_FILTER_UNSTRUCTURED_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q], 'QueryFilterUnstructuredForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryFilterUnstructuredForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :q => q
            }
          end

        end

        # Represents a collection of deliveries and available options for fulfillment of
        # that delivery
        class Quote

          attr_reader :id, :destination, :deliveries, :selections, :delivered_duty, :delivered_duties

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination, :deliveries, :selections, :delivered_duties], 'Quote')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.from_json(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOptionReference) ? x : ::Io::Flow::V0::Models::DeliveryOptionReference.new(x)) }
            @delivered_duty = (x = (x = opts.delete(:delivered_duty); x.nil? ? "paid" : x); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @delivered_duties = HttpClient::Preconditions.assert_class('delivered_duties', opts.delete(:delivered_duties), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Quote.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :selections => selections.map { |o| o.to_hash },
              :delivered_duty => delivered_duty.value,
              :delivered_duties => delivered_duties.map { |o| o.value }
            }
          end

        end

        class QuoteError

          attr_reader :code, :messages, :item_numbers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'QuoteError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::QuoteErrorCode) ? x : ::Io::Flow::V0::Models::QuoteErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @item_numbers = (x = opts.delete(:item_numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_numbers', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :item_numbers => item_numbers.nil? ? nil : item_numbers
            }
          end

        end

        class QuoteForm

          attr_reader :destination, :experience, :items, :delivered_duty, :delivered_duties, :direction

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :experience, :items], 'QuoteForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::QuoteLineItemForm) ? x : ::Io::Flow::V0::Models::QuoteLineItemForm.new(x)) }
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @delivered_duties = (x = opts.delete(:delivered_duties); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivered_duties', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)) })
            @direction = (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LaneDirection) ? x : ::Io::Flow::V0::Models::LaneDirection.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :experience => experience,
              :items => items.map { |o| o.to_hash },
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :delivered_duties => delivered_duties.nil? ? nil : delivered_duties.map { |o| o.value },
              :direction => direction.nil? ? nil : direction.value
            }
          end

        end

        # Line items and relevant attributes. Similar to common.line_item_form, but
        # price is a money_with_optional_base
        class QuoteLineItemForm

          attr_reader :number, :quantity, :shipment_estimate, :price, :attributes, :center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity, :price], 'QuoteLineItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @shipment_estimate = (x = opts.delete(:shipment_estimate); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::MoneyWithBase) ? x : ::Io::Flow::V0::Models::MoneyWithBase.new(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteLineItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity,
              :shipment_estimate => shipment_estimate.nil? ? nil : shipment_estimate.to_hash,
              :price => price.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :center => center
            }
          end

        end

        class QuoteSummary

          attr_reader :id, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination], 'QuoteSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash
            }
          end

        end

        class QuoteVersion

          attr_reader :id, :timestamp, :type, :quote

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :quote], 'QuoteVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @quote = (x = opts.delete(:quote); x.is_a?(::Io::Flow::V0::Models::QuoteSummary) ? x : ::Io::Flow::V0::Models::QuoteSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :quote => quote.to_hash
            }
          end

        end

        # Represents an organization-specific currency conversion rate at a point in
        # time.
        class Rate

          attr_reader :id, :base, :target, :effective_at, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :base, :target, :effective_at, :value], 'Rate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :base => base,
              :target => target,
              :effective_at => effective_at,
              :value => value.to_f.to_s
            }
          end

        end

        class RateDeleted < Event

          attr_reader :event_id, :timestamp, :rate_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :rate_id], 'RateDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @rate_id = HttpClient::Preconditions.assert_class('rate_id', opts.delete(:rate_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :rate_id => rate_id
            }
          end

        end

        class RateDeletedV3 < Event

          attr_reader :event_id, :timestamp, :organization, :rate

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATE_DELETED_V3)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :rate], 'RateDeletedV3')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @rate = (x = opts.delete(:rate); x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateDeletedV3.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :rate => rate.to_hash
            }
          end

        end

        # Represents the parts of an organization rate that can be updated.
        class RateForm

          attr_reader :base, :target, :effective_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :effective_at], 'RateForm')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :effective_at => effective_at
            }
          end

        end

        class RateUpserted < Event

          attr_reader :event_id, :timestamp, :rate_id, :organization_id, :base, :target, :effective_at, :value

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :rate_id, :organization_id, :base, :target, :effective_at, :value], 'RateUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @rate_id = HttpClient::Preconditions.assert_class('rate_id', opts.delete(:rate_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :rate_id => rate_id,
              :organization_id => organization_id,
              :base => base,
              :target => target,
              :effective_at => effective_at,
              :value => value.to_f.to_s
            }
          end

        end

        class RateUpsertedV3 < Event

          attr_reader :event_id, :timestamp, :organization, :rate

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATE_UPSERTED_V3)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :rate], 'RateUpsertedV3')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @rate = (x = opts.delete(:rate); x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateUpsertedV3.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :rate => rate.to_hash
            }
          end

        end

        class RateVersion

          attr_reader :id, :timestamp, :type, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :rate], 'RateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @rate = (x = opts.delete(:rate); x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :rate => rate.to_hash
            }
          end

        end

        # Snapshot of all lanes and rows across all service levels of an organization
        class Ratecard

          attr_reader :id, :direction, :effective_at, :origination_zones, :service, :number, :published_at, :ratecard_owner

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :direction, :effective_at, :origination_zones, :service], 'Ratecard')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @direction = (x = opts.delete(:direction); x.is_a?(::Io::Flow::V0::Models::Direction) ? x : ::Io::Flow::V0::Models::Direction.apply(x))
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @origination_zones = HttpClient::Preconditions.assert_class('origination_zones', opts.delete(:origination_zones), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x)) }
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::RatecardServiceSummary) ? x : ::Io::Flow::V0::Models::RatecardServiceSummary.new(x))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @published_at = (x = opts.delete(:published_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('published_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @ratecard_owner = (x = opts.delete(:ratecard_owner); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::RatecardOwner) ? x : ::Io::Flow::V0::Models::RatecardOwner.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Ratecard.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :direction => direction.value,
              :effective_at => effective_at,
              :origination_zones => origination_zones.map { |o| o.to_hash },
              :service => service.to_hash,
              :number => number,
              :published_at => published_at,
              :ratecard_owner => ratecard_owner.nil? ? nil : ratecard_owner.value
            }
          end

        end

        class RatecardCarrierSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'RatecardCarrierSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardCarrierSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class RatecardDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :ratecard

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATECARD_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :ratecard], 'RatecardDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @ratecard = (x = opts.delete(:ratecard); x.is_a?(::Io::Flow::V0::Models::Ratecard) ? x : ::Io::Flow::V0::Models::Ratecard.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :ratecard => ratecard.to_hash
            }
          end

        end

        class RatecardEstimateFormV1 < RatecardEstimateForm

          attr_reader :origin, :destination, :weight_unit, :distance_unit, :service, :weight, :length, :width, :depth, :delivered_duty, :line_items

          def initialize(incoming={})
            super(:discriminator => RatecardEstimateForm::Types::RATECARD_ESTIMATE_FORM_V1)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String))
            @weight_unit = (x = opts.delete(:weight_unit); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x)))
            @distance_unit = (x = opts.delete(:distance_unit); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x)))
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : HttpClient::Preconditions.assert_class('weight', x, Numeric))
            @length = (x = opts.delete(:length); x.nil? ? nil : HttpClient::Preconditions.assert_class('length', x, Numeric))
            @width = (x = opts.delete(:width); x.nil? ? nil : HttpClient::Preconditions.assert_class('width', x, Numeric))
            @depth = (x = opts.delete(:depth); x.nil? ? nil : HttpClient::Preconditions.assert_class('depth', x, Numeric))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @line_items = (x = opts.delete(:line_items); x.nil? ? nil : HttpClient::Preconditions.assert_class('line_items', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardEstimateFormV1.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :origin => origin,
              :destination => destination,
              :weight_unit => weight_unit.nil? ? nil : weight_unit.value,
              :distance_unit => distance_unit.nil? ? nil : distance_unit.value,
              :service => service,
              :weight => weight,
              :length => length,
              :width => width,
              :depth => depth,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :line_items => line_items.nil? ? nil : line_items.map { |o| o.to_hash }
            }
          end

        end

        class RatecardEstimateFormV2 < RatecardEstimateForm

          attr_reader :origin_address, :destination_address, :weight_unit, :distance_unit, :service, :weight, :length, :width, :depth, :delivered_duty, :line_items, :center_id

          def initialize(incoming={})
            super(:discriminator => RatecardEstimateForm::Types::RATECARD_ESTIMATE_FORM_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:origin_address, :destination_address], 'RatecardEstimateFormV2')
            @origin_address = (x = opts.delete(:origin_address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @destination_address = (x = opts.delete(:destination_address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @weight_unit = (x = opts.delete(:weight_unit); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x)))
            @distance_unit = (x = opts.delete(:distance_unit); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x)))
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : HttpClient::Preconditions.assert_class('weight', x, Numeric))
            @length = (x = opts.delete(:length); x.nil? ? nil : HttpClient::Preconditions.assert_class('length', x, Numeric))
            @width = (x = opts.delete(:width); x.nil? ? nil : HttpClient::Preconditions.assert_class('width', x, Numeric))
            @depth = (x = opts.delete(:depth); x.nil? ? nil : HttpClient::Preconditions.assert_class('depth', x, Numeric))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @line_items = (x = opts.delete(:line_items); x.nil? ? nil : HttpClient::Preconditions.assert_class('line_items', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) })
            @center_id = (x = opts.delete(:center_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('center_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardEstimateFormV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :origin_address => origin_address.to_hash,
              :destination_address => destination_address.to_hash,
              :weight_unit => weight_unit.nil? ? nil : weight_unit.value,
              :distance_unit => distance_unit.nil? ? nil : distance_unit.value,
              :service => service,
              :weight => weight,
              :length => length,
              :width => width,
              :depth => depth,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :line_items => line_items.nil? ? nil : line_items.map { |o| o.to_hash },
              :center_id => center_id
            }
          end

        end

        class RatecardEstimateSummaryForm

          attr_reader :origin, :destination, :service, :center_key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String))
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            @center_key = (x = opts.delete(:center_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('center_key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardEstimateSummaryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin => origin,
              :destination => destination,
              :service => service,
              :center_key => center_key
            }
          end

        end

        # Represents a summary of a cost estimate based on rate card data for an
        # origin/destination and weight, either gravitational or dimensional
        class RatecardEstimateV1 < RatecardEstimate

          attr_reader :service, :shipment_window, :currency, :amount, :fees, :total, :delivered_duty, :dimensional_weight, :gravitational_weight, :line_items

          def initialize(incoming={})
            super(:discriminator => RatecardEstimate::Types::RATECARD_ESTIMATE_V1)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :shipment_window, :currency, :amount, :fees, :total, :delivered_duty], 'RatecardEstimateV1')
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::RatecardServiceSummary) ? x : ::Io::Flow::V0::Models::RatecardServiceSummary.new(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @fees = HttpClient::Preconditions.assert_class('fees', opts.delete(:fees), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardFee) ? x : ::Io::Flow::V0::Models::RatecardFee.from_json(x)) }
            @total = HttpClient::Preconditions.assert_class('total', opts.delete(:total), Numeric)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @dimensional_weight = (x = opts.delete(:dimensional_weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @gravitational_weight = (x = opts.delete(:gravitational_weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @line_items = (x = opts.delete(:line_items); x.nil? ? nil : HttpClient::Preconditions.assert_class('line_items', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardEstimateV1.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :service => service.to_hash,
              :shipment_window => shipment_window.to_hash,
              :currency => currency,
              :amount => amount,
              :fees => fees.map { |o| o.to_hash },
              :total => total,
              :delivered_duty => delivered_duty.value,
              :dimensional_weight => dimensional_weight.nil? ? nil : dimensional_weight.to_hash,
              :gravitational_weight => gravitational_weight.nil? ? nil : gravitational_weight.to_hash,
              :line_items => line_items.nil? ? nil : line_items.map { |o| o.to_hash }
            }
          end

        end

        # Represents a summary of a cost estimate based on rate card data for an
        # origin/destination and weight, either gravitational or dimensional
        class RatecardEstimateV2 < RatecardEstimate

          attr_reader :hops, :delivered_duty, :dimensional_weight, :gravitational_weight, :line_items, :ratecard_owner

          def initialize(incoming={})
            super(:discriminator => RatecardEstimate::Types::RATECARD_ESTIMATE_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:hops, :delivered_duty], 'RatecardEstimateV2')
            @hops = HttpClient::Preconditions.assert_class('hops', opts.delete(:hops), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Hop) ? x : ::Io::Flow::V0::Models::Hop.new(x)) }
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @dimensional_weight = (x = opts.delete(:dimensional_weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @gravitational_weight = (x = opts.delete(:gravitational_weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @line_items = (x = opts.delete(:line_items); x.nil? ? nil : HttpClient::Preconditions.assert_class('line_items', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) })
            @ratecard_owner = (x = opts.delete(:ratecard_owner); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::RatecardOwner) ? x : ::Io::Flow::V0::Models::RatecardOwner.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardEstimateV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :hops => hops.map { |o| o.to_hash },
              :delivered_duty => delivered_duty.value,
              :dimensional_weight => dimensional_weight.nil? ? nil : dimensional_weight.to_hash,
              :gravitational_weight => gravitational_weight.nil? ? nil : gravitational_weight.to_hash,
              :line_items => line_items.nil? ? nil : line_items.map { |o| o.to_hash },
              :ratecard_owner => ratecard_owner.nil? ? nil : ratecard_owner.value
            }
          end

        end

        class RatecardForm

          attr_reader :direction, :effective_at, :origination_zones, :service, :number, :ratecard_owner

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:direction, :effective_at, :origination_zones, :service], 'RatecardForm')
            @direction = (x = opts.delete(:direction); x.is_a?(::Io::Flow::V0::Models::Direction) ? x : ::Io::Flow::V0::Models::Direction.apply(x))
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @origination_zones = HttpClient::Preconditions.assert_class('origination_zones', opts.delete(:origination_zones), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x)) }
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @ratecard_owner = (x = (x = opts.delete(:ratecard_owner); x.nil? ? "flow" : x); x.is_a?(::Io::Flow::V0::Models::RatecardOwner) ? x : ::Io::Flow::V0::Models::RatecardOwner.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :direction => direction.value,
              :effective_at => effective_at,
              :origination_zones => origination_zones.map { |o| o.to_hash },
              :service => service,
              :number => number,
              :ratecard_owner => ratecard_owner.value
            }
          end

        end

        # Describe list of rates applicable for a lane on the ratecard - defined by
        # origin and destination zone
        class RatecardLane

          attr_reader :id, :ratecard, :currency, :delivered_duty, :shipment_window, :destination, :dim_factor, :fees, :origin, :service, :rates, :rounding, :weight_unit, :distance_unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :ratecard, :currency, :delivered_duty, :shipment_window, :destination, :dim_factor, :fees, :origin, :service, :rates, :rounding, :weight_unit, :distance_unit], 'RatecardLane')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @ratecard = (x = opts.delete(:ratecard); x.is_a?(::Io::Flow::V0::Models::RatecardReference) ? x : ::Io::Flow::V0::Models::RatecardReference.new(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @dim_factor = HttpClient::Preconditions.assert_class('dim_factor', opts.delete(:dim_factor), Numeric)
            @fees = HttpClient::Preconditions.assert_class('fees', opts.delete(:fees), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardFee) ? x : ::Io::Flow::V0::Models::RatecardFee.from_json(x)) }
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::RatecardServiceSummary) ? x : ::Io::Flow::V0::Models::RatecardServiceSummary.new(x))
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardRate) ? x : ::Io::Flow::V0::Models::RatecardRate.new(x)) }
            @rounding = (x = opts.delete(:rounding); x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x))
            @weight_unit = (x = opts.delete(:weight_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @distance_unit = (x = opts.delete(:distance_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLane.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :ratecard => ratecard.to_hash,
              :currency => currency,
              :delivered_duty => delivered_duty.value,
              :shipment_window => shipment_window.to_hash,
              :destination => destination.to_hash,
              :dim_factor => dim_factor,
              :fees => fees.map { |o| o.to_hash },
              :origin => origin.to_hash,
              :service => service.to_hash,
              :rates => rates.map { |o| o.to_hash },
              :rounding => rounding.to_hash,
              :weight_unit => weight_unit.value,
              :distance_unit => distance_unit.value
            }
          end

        end

        class RatecardLaneDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATECARD_LANE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'RatecardLaneDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLaneDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class RatecardLaneForm

          attr_reader :ratecard_id, :currency, :destination, :shipment_window, :delivered_duty, :dim_factor, :fees, :origin, :rounding, :rates, :weight_unit, :distance_unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:ratecard_id, :currency, :destination, :shipment_window, :delivered_duty, :dim_factor, :fees, :origin, :rounding, :rates, :weight_unit, :distance_unit], 'RatecardLaneForm')
            @ratecard_id = HttpClient::Preconditions.assert_class('ratecard_id', opts.delete(:ratecard_id), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @dim_factor = HttpClient::Preconditions.assert_class('dim_factor', opts.delete(:dim_factor), Numeric)
            @fees = HttpClient::Preconditions.assert_class('fees', opts.delete(:fees), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardFee) ? x : ::Io::Flow::V0::Models::RatecardFee.from_json(x)) }
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @rounding = (x = opts.delete(:rounding); x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x))
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardRateForm) ? x : ::Io::Flow::V0::Models::RatecardRateForm.new(x)) }
            @weight_unit = (x = opts.delete(:weight_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @distance_unit = (x = opts.delete(:distance_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLaneForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ratecard_id => ratecard_id,
              :currency => currency,
              :destination => destination.to_hash,
              :shipment_window => shipment_window.to_hash,
              :delivered_duty => delivered_duty.value,
              :dim_factor => dim_factor,
              :fees => fees.map { |o| o.to_hash },
              :origin => origin.to_hash,
              :rounding => rounding.to_hash,
              :rates => rates.map { |o| o.to_hash },
              :weight_unit => weight_unit.value,
              :distance_unit => distance_unit.value
            }
          end

        end

        # Represents a line in a ratecard lane import file to be used with bulk CSV
        # imports of multiple ratecard lanes across different services in a single
        # import file. This would represent a row in each file.
        class RatecardLaneImportForm

          attr_reader :ratecard_owner, :service, :currency, :delivered_duty, :origin, :destination, :shipment_window, :dim_factor, :weight_unit, :distance_unit, :rates

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:ratecard_owner, :service, :currency, :delivered_duty, :origin, :destination, :shipment_window, :dim_factor, :weight_unit, :distance_unit, :rates], 'RatecardLaneImportForm')
            @ratecard_owner = (x = opts.delete(:ratecard_owner); x.is_a?(::Io::Flow::V0::Models::RatecardOwner) ? x : ::Io::Flow::V0::Models::RatecardOwner.apply(x))
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @dim_factor = HttpClient::Preconditions.assert_class('dim_factor', HttpClient::Helper.to_big_decimal(opts.delete(:dim_factor)), BigDecimal)
            @weight_unit = (x = opts.delete(:weight_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @distance_unit = (x = opts.delete(:distance_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardRateForm) ? x : ::Io::Flow::V0::Models::RatecardRateForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLaneImportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ratecard_owner => ratecard_owner.value,
              :service => service,
              :currency => currency,
              :delivered_duty => delivered_duty.value,
              :origin => origin.to_hash,
              :destination => destination.to_hash,
              :shipment_window => shipment_window.to_hash,
              :dim_factor => dim_factor.to_f.to_s,
              :weight_unit => weight_unit.value,
              :distance_unit => distance_unit.value,
              :rates => rates.map { |o| o.to_hash }
            }
          end

        end

        class RatecardLaneUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :ratecard_lane

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATECARD_LANE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :ratecard_lane], 'RatecardLaneUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @ratecard_lane = (x = opts.delete(:ratecard_lane); x.is_a?(::Io::Flow::V0::Models::RatecardLane) ? x : ::Io::Flow::V0::Models::RatecardLane.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLaneUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :ratecard_lane => ratecard_lane.to_hash
            }
          end

        end

        class RatecardLaneVersion

          attr_reader :id, :timestamp, :type, :ratecard_lane

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :ratecard_lane], 'RatecardLaneVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @ratecard_lane = (x = opts.delete(:ratecard_lane); x.is_a?(::Io::Flow::V0::Models::RatecardLane) ? x : ::Io::Flow::V0::Models::RatecardLane.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLaneVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :ratecard_lane => ratecard_lane.to_hash
            }
          end

        end

        class RatecardLanesImportRequestData

          attr_reader :id, :source_url, :filename

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :source_url], 'RatecardLanesImportRequestData')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @source_url = HttpClient::Preconditions.assert_class('source_url', opts.delete(:source_url), String)
            @filename = (x = opts.delete(:filename); x.nil? ? nil : HttpClient::Preconditions.assert_class('filename', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLanesImportRequestData.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :source_url => source_url,
              :filename => filename
            }
          end

        end

        # Specific line item in a ratecard lane with information on a weight threshold
        # and corresponding amount to charge
        class RatecardRate

          attr_reader :id, :amount, :weight

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :amount, :weight], 'RatecardRate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @weight = HttpClient::Preconditions.assert_class('weight', opts.delete(:weight), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardRate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :amount => amount,
              :weight => weight
            }
          end

        end

        class RatecardRateForm

          attr_reader :amount, :weight

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :weight], 'RatecardRateForm')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @weight = HttpClient::Preconditions.assert_class('weight', opts.delete(:weight), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardRateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :weight => weight
            }
          end

        end

        class RatecardRateVersion

          attr_reader :id, :timestamp, :type, :ratecard_rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :ratecard_rate], 'RatecardRateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @ratecard_rate = (x = opts.delete(:ratecard_rate); x.is_a?(::Io::Flow::V0::Models::RatecardRate) ? x : ::Io::Flow::V0::Models::RatecardRate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardRateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :ratecard_rate => ratecard_rate.to_hash
            }
          end

        end

        class RatecardReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'RatecardReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class RatecardServiceSummary

          attr_reader :id, :name, :carrier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :carrier], 'RatecardServiceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::RatecardCarrierSummary) ? x : ::Io::Flow::V0::Models::RatecardCarrierSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardServiceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :carrier => carrier.to_hash
            }
          end

        end

        class RatecardUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :ratecard

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATECARD_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :ratecard], 'RatecardUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @ratecard = (x = opts.delete(:ratecard); x.is_a?(::Io::Flow::V0::Models::Ratecard) ? x : ::Io::Flow::V0::Models::Ratecard.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :ratecard => ratecard.to_hash
            }
          end

        end

        class RatecardVersion

          attr_reader :id, :timestamp, :type, :ratecard

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :ratecard], 'RatecardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @ratecard = (x = opts.delete(:ratecard); x.is_a?(::Io::Flow::V0::Models::Ratecard) ? x : ::Io::Flow::V0::Models::Ratecard.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :ratecard => ratecard.to_hash
            }
          end

        end

        # Sent when an order is assigned to a fulfillment center in whole or in part.
        # All assigned fulfillments for all centers will be included on the message.
        class ReadyToFulfill < Event

          attr_reader :event_id, :timestamp, :organization, :order_number, :order, :fulfillments, :fulfillment_item_allocation_details

          def initialize(incoming={})
            super(:discriminator => Event::Types::READY_TO_FULFILL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :order_number, :order], 'ReadyToFulfill')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
            @fulfillments = (x = opts.delete(:fulfillments); x.nil? ? nil : HttpClient::Preconditions.assert_class('fulfillments', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Fulfillment) ? x : ::Io::Flow::V0::Models::Fulfillment.new(x)) })
            @fulfillment_item_allocation_details = (x = opts.delete(:fulfillment_item_allocation_details); x.nil? ? nil : HttpClient::Preconditions.assert_class('fulfillment_item_allocation_details', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FulfillmentItemAllocationDetails) ? x : ::Io::Flow::V0::Models::FulfillmentItemAllocationDetails.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReadyToFulfill.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :order_number => order_number,
              :order => order.to_hash,
              :fulfillments => fulfillments.nil? ? nil : fulfillments.map { |o| o.to_hash },
              :fulfillment_item_allocation_details => fulfillment_item_allocation_details.nil? ? nil : fulfillment_item_allocation_details.map { |o| o.to_hash }
            }
          end

        end

        # Represents an online payment that requires the user to redirect to another
        # site before entering their payment information.
        class RedirectAuthorizationDetails < OnlineAuthorizationDetails

          attr_reader :id, :payment_redirect_url, :confirmation_details

          def initialize(incoming={})
            super(:discriminator => OnlineAuthorizationDetails::Types::REDIRECT_AUTHORIZATION_DETAILS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :payment_redirect_url], 'RedirectAuthorizationDetails')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @payment_redirect_url = HttpClient::Preconditions.assert_class('payment_redirect_url', opts.delete(:payment_redirect_url), String)
            @confirmation_details = (x = opts.delete(:confirmation_details); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ConfirmationDetails) ? x : ::Io::Flow::V0::Models::ConfirmationDetails.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RedirectAuthorizationDetails.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :payment_redirect_url => payment_redirect_url,
              :confirmation_details => confirmation_details.nil? ? nil : confirmation_details.to_hash
            }
          end

        end

        # Executes a redirect-based payment based on the provided payment method.
        class RedirectAuthorizationForm < AuthorizationForm

          attr_reader :method, :issuer, :order_number, :amount, :currency, :redirect_urls, :key, :attributes, :ip

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::REDIRECT_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:method, :order_number, :amount, :currency, :redirect_urls], 'RedirectAuthorizationForm')
            @method = HttpClient::Preconditions.assert_class('method', opts.delete(:method), String)
            @issuer = (x = opts.delete(:issuer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::IssuerReference) ? x : ::Io::Flow::V0::Models::IssuerReference.new(x)))
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @redirect_urls = (x = opts.delete(:redirect_urls); x.is_a?(::Io::Flow::V0::Models::PostPaymentRedirectUrls) ? x : ::Io::Flow::V0::Models::PostPaymentRedirectUrls.new(x))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RedirectAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :method => method,
              :issuer => issuer.nil? ? nil : issuer.to_hash,
              :order_number => order_number,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :redirect_urls => redirect_urls.to_hash,
              :key => key,
              :attributes => attributes.nil? ? nil : attributes,
              :ip => ip
            }
          end

        end

        # Refunds can be created against either a specific capture or an authorization
        # (in which case we will select 1 or more specific captures against which to
        # execute the refund).
        class Refund

          attr_reader :id, :key, :authorization, :amount, :currency, :requested, :captures, :created_at, :attributes, :status, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :authorization, :amount, :currency, :captures, :created_at], 'Refund')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @requested = (x = opts.delete(:requested); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @captures = HttpClient::Preconditions.assert_class('captures', opts.delete(:captures), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RefundCaptureSummary) ? x : ::Io::Flow::V0::Models::RefundCaptureSummary.new(x)) }
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @status = (x = (x = opts.delete(:status); x.nil? ? "succeeded" : x); x.is_a?(::Io::Flow::V0::Models::RefundStatus) ? x : ::Io::Flow::V0::Models::RefundStatus.apply(x))
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Refund.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :authorization => authorization.to_hash,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :requested => requested.nil? ? nil : requested.to_hash,
              :captures => captures.map { |o| o.to_hash },
              :created_at => created_at,
              :attributes => attributes.nil? ? nil : attributes,
              :status => status.value,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        # Refund captures provide the detailed information on the amount refunded
        # against a specific capture
        class RefundCapture

          attr_reader :id, :refund, :capture, :amount, :currency, :base, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :refund, :capture, :amount, :currency, :base], 'RefundCapture')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @status = (x = (x = opts.delete(:status); x.nil? ? "succeeded" : x); x.is_a?(::Io::Flow::V0::Models::RefundStatus) ? x : ::Io::Flow::V0::Models::RefundStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundCapture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :refund => refund.to_hash,
              :capture => capture.to_hash,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :base => base.to_hash,
              :status => status.value
            }
          end

        end

        # Refund captures provide the detailed information on the amount refunded
        # against a specific capture
        class RefundCaptureSummary

          attr_reader :capture, :amount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:capture, :amount], 'RefundCaptureSummary')
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundCaptureSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :capture => capture.to_hash,
              :amount => amount.to_f.to_s
            }
          end

        end

        class RefundCaptureUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :refund_capture

          def initialize(incoming={})
            super(:discriminator => Event::Types::REFUND_CAPTURE_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :refund_capture], 'RefundCaptureUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @refund_capture = (x = opts.delete(:refund_capture); x.is_a?(::Io::Flow::V0::Models::RefundCapture) ? x : ::Io::Flow::V0::Models::RefundCapture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundCaptureUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :refund_capture => refund_capture.to_hash
            }
          end

        end

        class RefundDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :refund

          def initialize(incoming={})
            super(:discriminator => Event::Types::REFUND_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :refund], 'RefundDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :refund => refund.to_hash
            }
          end

        end

        class RefundError

          attr_reader :code, :messages, :decline_code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages, :decline_code], 'RefundError')
            @code = (x = (x = opts.delete(:code); x.nil? ? "generic_error" : x); x.is_a?(::Io::Flow::V0::Models::GenericErrorCode) ? x : ::Io::Flow::V0::Models::GenericErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @decline_code = (x = opts.delete(:decline_code); x.is_a?(::Io::Flow::V0::Models::RefundDeclineCode) ? x : ::Io::Flow::V0::Models::RefundDeclineCode.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :decline_code => decline_code.value
            }
          end

        end

        # Refund actually transfers funds. You can refund as many times as you'd like up
        # until the total amount of captured funds has been refunded. Note when creating
        # a refund you can specify either an order authorization id, a capture id, or an
        # order number (or all of them as long as they match).
        class RefundForm

          attr_reader :authorization_id, :capture_id, :order_number, :key, :amount, :currency, :rma_key, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @authorization_id = (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String))
            @capture_id = (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, String))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @rma_key = (x = opts.delete(:rma_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('rma_key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :authorization_id => authorization_id,
              :capture_id => capture_id,
              :order_number => order_number,
              :key => key,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :rma_key => rma_key,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class RefundIdentifier

          attr_reader :id, :refund, :identifier, :primary

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :refund, :identifier, :primary], 'RefundIdentifier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::RefundReference) ? x : ::Io::Flow::V0::Models::RefundReference.new(x))
            @identifier = HttpClient::Preconditions.assert_class('identifier', opts.delete(:identifier), String)
            @primary = HttpClient::Preconditions.assert_boolean('primary', opts.delete(:primary))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundIdentifier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :refund => refund.to_hash,
              :identifier => identifier,
              :primary => primary
            }
          end

        end

        class RefundIdentifierDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :identifier

          def initialize(incoming={})
            super(:discriminator => Event::Types::REFUND_IDENTIFIER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :identifier], 'RefundIdentifierDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @identifier = (x = opts.delete(:identifier); x.is_a?(::Io::Flow::V0::Models::RefundIdentifier) ? x : ::Io::Flow::V0::Models::RefundIdentifier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundIdentifierDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :identifier => identifier.to_hash
            }
          end

        end

        class RefundIdentifierUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :identifier

          def initialize(incoming={})
            super(:discriminator => Event::Types::REFUND_IDENTIFIER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :identifier], 'RefundIdentifierUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @identifier = (x = opts.delete(:identifier); x.is_a?(::Io::Flow::V0::Models::RefundIdentifier) ? x : ::Io::Flow::V0::Models::RefundIdentifier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundIdentifierUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :identifier => identifier.to_hash
            }
          end

        end

        # For merchant of record authorizations, we provide a summary of refund
        # information primarily to support customer service workflow.
        class RefundOrderSummary

          attr_reader :order_number, :currency, :captured, :refunded, :amounts

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order_number, :currency, :captured, :refunded, :amounts], 'RefundOrderSummary')
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @captured = HttpClient::Preconditions.assert_class('captured', HttpClient::Helper.to_big_decimal(opts.delete(:captured)), BigDecimal)
            @refunded = HttpClient::Preconditions.assert_class('refunded', HttpClient::Helper.to_big_decimal(opts.delete(:refunded)), BigDecimal)
            @amounts = (x = opts.delete(:amounts); x.is_a?(::Io::Flow::V0::Models::RefundOrderSummaryAmounts) ? x : ::Io::Flow::V0::Models::RefundOrderSummaryAmounts.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundOrderSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order_number => order_number,
              :currency => currency,
              :captured => captured.to_f.to_s,
              :refunded => refunded.to_f.to_s,
              :amounts => amounts.to_hash
            }
          end

        end

        # Detailed examples of amount to refund following common e-commerce use cases.
        class RefundOrderSummaryAmounts

          attr_reader :balance, :balance_excluding_shipping, :shipping

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:balance], 'RefundOrderSummaryAmounts')
            @balance = HttpClient::Preconditions.assert_class('balance', HttpClient::Helper.to_big_decimal(opts.delete(:balance)), BigDecimal)
            @balance_excluding_shipping = (x = opts.delete(:balance_excluding_shipping); x.nil? ? nil : HttpClient::Preconditions.assert_class('balance_excluding_shipping', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipping', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundOrderSummaryAmounts.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :balance => balance.to_f.to_s,
              :balance_excluding_shipping => balance_excluding_shipping.to_f.to_s,
              :shipping => shipping.to_f.to_s
            }
          end

        end

        class RefundReference

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'RefundReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        class RefundUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :refund

          def initialize(incoming={})
            super(:discriminator => Event::Types::REFUND_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :refund], 'RefundUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :refund => refund.to_hash
            }
          end

        end

        class RefundVersion

          attr_reader :id, :timestamp, :type, :refund

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :refund], 'RefundVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :refund => refund.to_hash
            }
          end

        end

        # A region represents a geographic area of the world. Regions can be countries,
        # continents or other political areas (like the Eurozone). See
        # https://api.flow.io/reference/regions
        class Region

          attr_reader :id, :name, :countries, :currencies, :languages, :measurement_systems, :timezones

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :countries, :currencies, :languages, :measurement_systems, :timezones], 'Region')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
            @currencies = HttpClient::Preconditions.assert_class('currencies', opts.delete(:currencies), Array).map { |v| HttpClient::Preconditions.assert_class('currencies', v, String) }
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_systems = HttpClient::Preconditions.assert_class('measurement_systems', opts.delete(:measurement_systems), Array).map { |v| HttpClient::Preconditions.assert_class('measurement_systems', v, String) }
            @timezones = HttpClient::Preconditions.assert_class('timezones', opts.delete(:timezones), Array).map { |v| HttpClient::Preconditions.assert_class('timezones', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Region.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :countries => countries,
              :currencies => currencies,
              :languages => languages,
              :measurement_systems => measurement_systems,
              :timezones => timezones
            }
          end

        end

        class RegionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'RegionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RegionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class RegionSetting

          attr_reader :id, :region, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :region, :status], 'RegionSetting')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @region = HttpClient::Preconditions.assert_class('region', opts.delete(:region), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::AvailabilityStatus) ? x : ::Io::Flow::V0::Models::AvailabilityStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RegionSetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :region => region,
              :status => status.value
            }
          end

        end

        class RegionSettingForm

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'RegionSettingForm')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::AvailabilityStatus) ? x : ::Io::Flow::V0::Models::AvailabilityStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RegionSettingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value
            }
          end

        end

        class RemoteAreaRatecardFee < RatecardFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => RatecardFee::Types::REMOTE_AREA_RATECARD_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'RemoteAreaRatecardFee')
            @amount = (x = opts.delete(:amount); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RemoteAreaRatecardFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_hash
            }
          end

        end

        class RemoteAreaServiceFee < ServiceFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => ServiceFee::Types::REMOTE_AREA_SERVICE_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'RemoteAreaServiceFee')
            @amount = (x = opts.delete(:amount); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RemoteAreaServiceFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_hash
            }
          end

        end

        class RepeatDaily < RepeatSchedule

          attr_reader :interval

          def initialize(incoming={})
            super(:discriminator => RepeatSchedule::Types::REPEAT_DAILY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:interval], 'RepeatDaily')
            @interval = HttpClient::Preconditions.assert_class('interval', opts.delete(:interval), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RepeatDaily.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :interval => interval
            }
          end

        end

        class RepeatHourly < RepeatSchedule

          attr_reader :interval

          def initialize(incoming={})
            super(:discriminator => RepeatSchedule::Types::REPEAT_HOURLY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:interval], 'RepeatHourly')
            @interval = HttpClient::Preconditions.assert_class('interval', opts.delete(:interval), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RepeatHourly.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :interval => interval
            }
          end

        end

        # Monthly on the {day} of each {interval} month. Note if you specify a day > 28
        # and the month does not have that day, the repeat schedule is assumed to be the
        # last day of the month. Common examples are: Monthly on the 1st, monthly on the
        # 15th and 31st, every 3 months on the 1st, etc.
        class RepeatMonthly < RepeatSchedule

          attr_reader :interval, :days

          def initialize(incoming={})
            super(:discriminator => RepeatSchedule::Types::REPEAT_MONTHLY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:interval, :days], 'RepeatMonthly')
            @interval = HttpClient::Preconditions.assert_class('interval', opts.delete(:interval), Integer)
            @days = HttpClient::Preconditions.assert_class('days', opts.delete(:days), Array).map { |v| HttpClient::Preconditions.assert_class('days', v, Integer) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RepeatMonthly.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :interval => interval,
              :days => days
            }
          end

        end

        class RepeatWeekly < RepeatSchedule

          attr_reader :interval, :days_of_week

          def initialize(incoming={})
            super(:discriminator => RepeatSchedule::Types::REPEAT_WEEKLY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:interval, :days_of_week], 'RepeatWeekly')
            @interval = HttpClient::Preconditions.assert_class('interval', opts.delete(:interval), Integer)
            @days_of_week = HttpClient::Preconditions.assert_class('days_of_week', opts.delete(:days_of_week), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DayOfWeek) ? x : ::Io::Flow::V0::Models::DayOfWeek.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RepeatWeekly.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :interval => interval,
              :days_of_week => days_of_week.map { |o| o.value }
            }
          end

        end

        # Inventory reservation for a set of items in organization that potentially
        # expires at specified date/time
        class Reservation

          attr_reader :id, :key, :order, :items, :reserved_until

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :items], 'Reservation')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ReservationOrderReference) ? x : ::Io::Flow::V0::Models::ReservationOrderReference.new(x)))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReservationItem) ? x : ::Io::Flow::V0::Models::ReservationItem.new(x)) }
            @reserved_until = (x = opts.delete(:reserved_until); x.nil? ? nil : HttpClient::Preconditions.assert_class('reserved_until', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Reservation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :order => order.nil? ? nil : order.to_hash,
              :items => items.map { |o| o.to_hash },
              :reserved_until => reserved_until
            }
          end

        end

        class ReservationForm

          attr_reader :order_number, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'ReservationForm')
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReservationItemForm) ? x : ::Io::Flow::V0::Models::ReservationItemForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReservationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order_number => order_number,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class ReservationItem

          attr_reader :item, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :quantity], 'ReservationItem')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::ReservationItemReference) ? x : ::Io::Flow::V0::Models::ReservationItemReference.new(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReservationItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :quantity => quantity
            }
          end

        end

        class ReservationItemForm

          attr_reader :item_number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :quantity], 'ReservationItemForm')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReservationItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :quantity => quantity
            }
          end

        end

        class ReservationItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ReservationItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReservationItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class ReservationOrderReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ReservationOrderReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReservationOrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class Return

          attr_reader :id, :key, :items, :labels

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :items, :labels], 'Return')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReturnLineItem) ? x : ::Io::Flow::V0::Models::ReturnLineItem.new(x)) }
            @labels = HttpClient::Preconditions.assert_class('labels', opts.delete(:labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingLabel) ? x : ::Io::Flow::V0::Models::ShippingLabel.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Return.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :items => items.map { |o| o.to_hash },
              :labels => labels.map { |o| o.to_hash }
            }
          end

        end

        class ReturnDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::RETURN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'ReturnDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class ReturnForm

          attr_reader :items, :tier_id, :order_number, :service, :destination, :key, :origin, :center_key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'ReturnForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReturnLineItem) ? x : ::Io::Flow::V0::Models::ReturnLineItem.new(x)) }
            @tier_id = (x = opts.delete(:tier_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier_id', x, String))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @origin = (x = opts.delete(:origin); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
            @center_key = (x = opts.delete(:center_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('center_key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :tier_id => tier_id,
              :order_number => order_number,
              :service => service,
              :destination => destination.nil? ? nil : destination.to_hash,
              :key => key,
              :origin => origin.nil? ? nil : origin.to_hash,
              :center_key => center_key
            }
          end

        end

        class ReturnItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ReturnItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class ReturnLineItem

          attr_reader :item_number, :order_number, :quantity, :reason, :notes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :quantity], 'ReturnLineItem')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @reason = (x = opts.delete(:reason); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ReturnReason) ? x : ::Io::Flow::V0::Models::ReturnReason.new(x)))
            @notes = (x = opts.delete(:notes); x.nil? ? nil : HttpClient::Preconditions.assert_class('notes', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnLineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :order_number => order_number,
              :quantity => quantity,
              :reason => reason.nil? ? nil : reason.to_hash,
              :notes => notes
            }
          end

        end

        class ReturnOrderReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ReturnOrderReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnOrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class ReturnPackageRatecardFee < RatecardFee

          attr_reader :amount

          def initialize(incoming={})
            super(:discriminator => RatecardFee::Types::RETURN_PACKAGE_RATECARD_FEE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'ReturnPackageRatecardFee')
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnPackageRatecardFee.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount.to_f.to_s
            }
          end

        end

        class ReturnReason

          attr_reader :key, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name], 'ReturnReason')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnReason.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name
            }
          end

        end

        class ReturnReasonForm

          attr_reader :key, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnReasonForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name
            }
          end

        end

        class ReturnReasonPutForm

          attr_reader :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnReasonPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name
            }
          end

        end

        class ReturnUpserted < Event

          attr_reader :event_id, :timestamp, :id, :organization, :destination, :items, :key, :labels, :service, :origin

          def initialize(incoming={})
            super(:discriminator => Event::Types::RETURN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :organization, :destination, :items, :key, :labels, :service, :origin], 'ReturnUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReturnLineItem) ? x : ::Io::Flow::V0::Models::ReturnLineItem.new(x)) }
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @labels = HttpClient::Preconditions.assert_class('labels', opts.delete(:labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingLabel) ? x : ::Io::Flow::V0::Models::ShippingLabel.new(x)) }
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :organization => organization,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :key => key,
              :labels => labels.map { |o| o.to_hash },
              :service => service,
              :origin => origin.to_hash
            }
          end

        end

        class ReturnVersion

          attr_reader :id, :timestamp, :type, :return_

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :return_], 'ReturnVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @return_ = (x = opts.delete(:return); x.is_a?(::Io::Flow::V0::Models::Return) ? x : ::Io::Flow::V0::Models::Return.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :return => return_.to_hash
            }
          end

        end

        # A reversal is used to clear an authorization (full or partial).
        class Reversal

          attr_reader :id, :key, :authorization, :status, :amount, :currency, :requested, :created_at, :attributes, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :authorization, :status, :amount, :currency, :requested, :created_at, :attributes], 'Reversal')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ReversalStatus) ? x : ::Io::Flow::V0::Models::ReversalStatus.apply(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @requested = (x = opts.delete(:requested); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Reversal.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :authorization => authorization.to_hash,
              :status => status.value,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :requested => requested.to_hash,
              :created_at => created_at,
              :attributes => attributes,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        class ReversalDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :reversal

          def initialize(incoming={})
            super(:discriminator => Event::Types::REVERSAL_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :reversal], 'ReversalDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @reversal = (x = opts.delete(:reversal); x.is_a?(::Io::Flow::V0::Models::Reversal) ? x : ::Io::Flow::V0::Models::Reversal.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReversalDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :reversal => reversal.to_hash
            }
          end

        end

        # Details for why a reversal could not be created
        class ReversalError

          attr_reader :code, :messages, :codes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages, :codes], 'ReversalError')
            @code = HttpClient::Preconditions.assert_class('code', (x = opts.delete(:code); x.nil? ? "reversal_error" : x), String)
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @codes = HttpClient::Preconditions.assert_class('codes', opts.delete(:codes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReversalErrorCode) ? x : ::Io::Flow::V0::Models::ReversalErrorCode.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReversalError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :messages => messages,
              :codes => codes.map { |o| o.value }
            }
          end

        end

        class ReversalForm

          attr_reader :key, :authorization_id, :amount, :currency, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authorization_id], 'ReversalForm')
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @authorization_id = HttpClient::Preconditions.assert_class('authorization_id', opts.delete(:authorization_id), String)
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReversalForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :authorization_id => authorization_id,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class ReversalPutForm

          attr_reader :authorization_id, :amount, :currency, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authorization_id], 'ReversalPutForm')
            @authorization_id = HttpClient::Preconditions.assert_class('authorization_id', opts.delete(:authorization_id), String)
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReversalPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :authorization_id => authorization_id,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class ReversalUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :reversal

          def initialize(incoming={})
            super(:discriminator => Event::Types::REVERSAL_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :reversal], 'ReversalUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reversal = (x = opts.delete(:reversal); x.is_a?(::Io::Flow::V0::Models::Reversal) ? x : ::Io::Flow::V0::Models::Reversal.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReversalUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :reversal => reversal.to_hash
            }
          end

        end

        class ReversalVersion

          attr_reader :id, :timestamp, :type, :reversal

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :reversal], 'ReversalVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @reversal = (x = opts.delete(:reversal); x.is_a?(::Io::Flow::V0::Models::Reversal) ? x : ::Io::Flow::V0::Models::Reversal.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReversalVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :reversal => reversal.to_hash
            }
          end

        end

        class Rounding

          attr_reader :type, :method, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :method, :value], 'Rounding')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::RoundingType) ? x : ::Io::Flow::V0::Models::RoundingType.apply(x))
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::RoundingMethod) ? x : ::Io::Flow::V0::Models::RoundingMethod.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rounding.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :method => method.value,
              :value => value.to_f.to_s
            }
          end

        end

        class RouteAudit

          attr_reader :method, :path, :authentication_techniques, :roles

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:method, :path, :authentication_techniques, :roles], 'RouteAudit')
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::PermittedHttpMethod) ? x : ::Io::Flow::V0::Models::PermittedHttpMethod.apply(x))
            @path = HttpClient::Preconditions.assert_class('path', opts.delete(:path), String)
            @authentication_techniques = HttpClient::Preconditions.assert_class('authentication_techniques', opts.delete(:authentication_techniques), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AuthenticationTechnique) ? x : ::Io::Flow::V0::Models::AuthenticationTechnique.apply(x)) }
            @roles = HttpClient::Preconditions.assert_class('roles', opts.delete(:roles), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowRole) ? x : ::Io::Flow::V0::Models::FlowRole.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RouteAudit.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :method => method.value,
              :path => path,
              :authentication_techniques => authentication_techniques.map { |o| o.value },
              :roles => roles.map { |o| o.to_hash }
            }
          end

        end

        class RuleDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::RULE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'RuleDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RuleDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class RuleUpserted < Event

          attr_reader :event_id, :timestamp, :organization_id, :rule

          def initialize(incoming={})
            super(:discriminator => Event::Types::RULE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_id, :rule], 'RuleUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @rule = (x = opts.delete(:rule); x.is_a?(::Io::Flow::V0::Models::InventoryRule) ? x : ::Io::Flow::V0::Models::InventoryRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RuleUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_id => organization_id,
              :rule => rule.to_hash
            }
          end

        end

        # Represents operating calendar and holidays of a center
        class Schedule

          attr_reader :calendar, :holiday, :exception, :cutoff, :min_lead_time, :max_lead_time

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:holiday, :exception], 'Schedule')
            @calendar = (x = opts.delete(:calendar); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Calendar) ? x : ::Io::Flow::V0::Models::Calendar.apply(x)))
            @holiday = (x = opts.delete(:holiday); x.is_a?(::Io::Flow::V0::Models::HolidayCalendar) ? x : ::Io::Flow::V0::Models::HolidayCalendar.apply(x))
            @exception = HttpClient::Preconditions.assert_class('exception', opts.delete(:exception), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Exception) ? x : ::Io::Flow::V0::Models::Exception.new(x)) }
            @cutoff = (x = opts.delete(:cutoff); x.nil? ? nil : HttpClient::Preconditions.assert_class('cutoff', x, String))
            @min_lead_time = (x = opts.delete(:min_lead_time); x.nil? ? nil : HttpClient::Preconditions.assert_class('min_lead_time', x, Integer))
            @max_lead_time = (x = opts.delete(:max_lead_time); x.nil? ? nil : HttpClient::Preconditions.assert_class('max_lead_time', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Schedule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :calendar => calendar.nil? ? nil : calendar.value,
              :holiday => holiday.value,
              :exception => exception.map { |o| o.to_hash },
              :cutoff => cutoff,
              :min_lead_time => min_lead_time,
              :max_lead_time => max_lead_time
            }
          end

        end

        # Allows a user to create a scheduled export that will be delivered on a
        # schedule (currently only support once / day at a set time)
        class ScheduledExport

          attr_reader :id, :user, :organization_q, :hour, :minute, :timezone, :types, :last_sent_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user, :organization_q, :hour, :minute, :timezone, :types], 'ScheduledExport')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @organization_q = HttpClient::Preconditions.assert_class('organization_q', opts.delete(:organization_q), String)
            @hour = HttpClient::Preconditions.assert_class('hour', opts.delete(:hour), Integer)
            @minute = HttpClient::Preconditions.assert_class('minute', opts.delete(:minute), Integer)
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
            @types = HttpClient::Preconditions.assert_class('types', opts.delete(:types), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x)) }
            @last_sent_at = (x = opts.delete(:last_sent_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('last_sent_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ScheduledExport.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash,
              :organization_q => organization_q,
              :hour => hour,
              :minute => minute,
              :timezone => timezone,
              :types => types.map { |o| o.to_hash },
              :last_sent_at => last_sent_at
            }
          end

        end

        class ScheduledExportForm

          attr_reader :user_id, :organization_q, :hour, :minute, :timezone, :types

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:user_id, :organization_q, :hour, :minute, :timezone, :types], 'ScheduledExportForm')
            @user_id = HttpClient::Preconditions.assert_class('user_id', opts.delete(:user_id), String)
            @organization_q = HttpClient::Preconditions.assert_class('organization_q', opts.delete(:organization_q), String)
            @hour = HttpClient::Preconditions.assert_class('hour', opts.delete(:hour), Integer)
            @minute = HttpClient::Preconditions.assert_class('minute', opts.delete(:minute), Integer)
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
            @types = HttpClient::Preconditions.assert_class('types', opts.delete(:types), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ScheduledExportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :user_id => user_id,
              :organization_q => organization_q,
              :hour => hour,
              :minute => minute,
              :timezone => timezone,
              :types => types.map { |o| o.to_hash }
            }
          end

        end

        class ScheduledPickup

          attr_reader :day_of_week, :hour_of_day, :minute_of_hour

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:day_of_week, :hour_of_day, :minute_of_hour], 'ScheduledPickup')
            @day_of_week = (x = opts.delete(:day_of_week); x.is_a?(::Io::Flow::V0::Models::DayOfWeek) ? x : ::Io::Flow::V0::Models::DayOfWeek.apply(x))
            @hour_of_day = HttpClient::Preconditions.assert_class('hour_of_day', opts.delete(:hour_of_day), String)
            @minute_of_hour = HttpClient::Preconditions.assert_class('minute_of_hour', opts.delete(:minute_of_hour), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ScheduledPickup.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :day_of_week => day_of_week.value,
              :hour_of_day => hour_of_day,
              :minute_of_hour => minute_of_hour
            }
          end

        end

        # A unique identifier assigned to an individual item.
        class Serial

          attr_reader :id, :number, :item_number, :item_price, :status, :center, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :item_number, :item_price, :status, :center], 'Serial')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @item_price = (x = opts.delete(:item_price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SerialStatus) ? x : ::Io::Flow::V0::Models::SerialStatus.apply(x))
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::CenterReference) ? x : ::Io::Flow::V0::Models::CenterReference.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Serial.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :item_number => item_number,
              :item_price => item_price.to_hash,
              :status => status.value,
              :center => center.to_hash,
              :attributes => attributes
            }
          end

        end

        class SerialDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SERIAL_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'SerialDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SerialDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        # A unique identifier assigned to an individual item.
        class SerialForm

          attr_reader :number, :item_number, :item_price, :item_currency, :status, :center_key, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :item_number, :item_price, :item_currency, :status], 'SerialForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @item_price = HttpClient::Preconditions.assert_class('item_price', HttpClient::Helper.to_big_decimal(opts.delete(:item_price)), BigDecimal)
            @item_currency = HttpClient::Preconditions.assert_class('item_currency', opts.delete(:item_currency), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SerialStatus) ? x : ::Io::Flow::V0::Models::SerialStatus.apply(x))
            @center_key = (x = opts.delete(:center_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('center_key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SerialForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :item_number => item_number,
              :item_price => item_price.to_f.to_s,
              :item_currency => item_currency,
              :status => status.value,
              :center_key => center_key,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class SerialUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :serial

          def initialize(incoming={})
            super(:discriminator => Event::Types::SERIAL_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :serial], 'SerialUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @serial = (x = opts.delete(:serial); x.is_a?(::Io::Flow::V0::Models::Serial) ? x : ::Io::Flow::V0::Models::Serial.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SerialUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :serial => serial.to_hash
            }
          end

        end

        # Retrieve journaled history of a serial
        class SerialVersion

          attr_reader :id, :timestamp, :type, :serial

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :serial], 'SerialVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @serial = (x = opts.delete(:serial); x.is_a?(::Io::Flow::V0::Models::Serial) ? x : ::Io::Flow::V0::Models::Serial.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SerialVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :serial => serial.to_hash
            }
          end

        end

        class ServiceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ServiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ServiceSummary

          attr_reader :id, :carrier, :name, :center_code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'ServiceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::CarrierReference) ? x : ::Io::Flow::V0::Models::CarrierReference.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @center_code = (x = opts.delete(:center_code); x.nil? ? nil : HttpClient::Preconditions.assert_class('center_code', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name,
              :center_code => center_code
            }
          end

        end

        # Authorize a request using a session id
        class SessionAuthorizationForm

          attr_reader :session

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:session], 'SessionAuthorizationForm')
            @session = HttpClient::Preconditions.assert_class('session', opts.delete(:session), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionAuthorizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :session => session
            }
          end

        end

        class SessionCurrencyFormat

          attr_reader :symbol, :label_formatters

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:symbol, :label_formatters], 'SessionCurrencyFormat')
            @symbol = (x = opts.delete(:symbol); x.is_a?(::Io::Flow::V0::Models::CurrencySymbolFormat) ? x : ::Io::Flow::V0::Models::CurrencySymbolFormat.apply(x))
            @label_formatters = HttpClient::Preconditions.assert_class('label_formatters', opts.delete(:label_formatters), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CurrencyLabelFormatter) ? x : ::Io::Flow::V0::Models::CurrencyLabelFormatter.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionCurrencyFormat.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :symbol => symbol.value,
              :label_formatters => label_formatters.map { |o| o.value }
            }
          end

        end

        # Experiment for A/B testing
        class SessionExperiment

          attr_reader :key, :variant

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'SessionExperiment')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @variant = (x = opts.delete(:variant); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionExperimentVariant) ? x : ::Io::Flow::V0::Models::SessionExperimentVariant.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionExperiment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :variant => variant.nil? ? nil : variant.to_hash
            }
          end

        end

        class SessionExperimentForm

          attr_reader :key, :variant

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'SessionExperimentForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @variant = (x = opts.delete(:variant); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionExperimentVariantForm) ? x : ::Io::Flow::V0::Models::SessionExperimentVariantForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionExperimentForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :variant => variant.nil? ? nil : variant.to_hash
            }
          end

        end

        # Experiment variant. Control or variant
        class SessionExperimentVariant

          attr_reader :key, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name], 'SessionExperimentVariant')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionExperimentVariant.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name
            }
          end

        end

        class SessionExperimentVariantForm

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'SessionExperimentVariantForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionExperimentVariantForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key
            }
          end

        end

        # Configures session expiration time. We default to 30 minutes to follow Google
        # Analytics
        class SessionExpirationConfig

          attr_reader :unit, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @unit = (x = (x = opts.delete(:unit); x.nil? ? "minute" : x); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', (x = opts.delete(:value); x.nil? ? 30 : x), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionExpirationConfig.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :unit => unit.value,
              :value => value
            }
          end

        end

        class SessionForm

          attr_reader :ip, :experience, :country, :currency, :language, :locale, :attributes, :experiment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @experience = (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @locale = (x = opts.delete(:locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('locale', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @experiment = (x = opts.delete(:experiment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionExperimentForm) ? x : ::Io::Flow::V0::Models::SessionExperimentForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ip => ip,
              :experience => experience,
              :country => country,
              :currency => currency,
              :language => language,
              :locale => locale,
              :attributes => attributes.nil? ? nil : attributes,
              :experiment => experiment.nil? ? nil : experiment.to_hash
            }
          end

        end

        class SessionFormat

          attr_reader :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency], 'SessionFormat')
            @currency = (x = opts.delete(:currency); x.is_a?(::Io::Flow::V0::Models::SessionCurrencyFormat) ? x : ::Io::Flow::V0::Models::SessionCurrencyFormat.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionFormat.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency.to_hash
            }
          end

        end

        # The geolocated information for this session
        class SessionGeo

          attr_reader :country, :currency, :language, :locale

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :currency, :language, :locale], 'SessionGeo')
            @country = (x = opts.delete(:country); x.is_a?(::Io::Flow::V0::Models::Country) ? x : ::Io::Flow::V0::Models::Country.new(x))
            @currency = (x = opts.delete(:currency); x.is_a?(::Io::Flow::V0::Models::Currency) ? x : ::Io::Flow::V0::Models::Currency.new(x))
            @language = (x = opts.delete(:language); x.is_a?(::Io::Flow::V0::Models::Language) ? x : ::Io::Flow::V0::Models::Language.new(x))
            @locale = (x = opts.delete(:locale); x.is_a?(::Io::Flow::V0::Models::Locale) ? x : ::Io::Flow::V0::Models::Locale.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionGeo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country.to_hash,
              :currency => currency.to_hash,
              :language => language.to_hash,
              :locale => locale.to_hash
            }
          end

        end

        class SessionPutForm

          attr_reader :ip, :experience, :country, :currency, :language, :locale, :attributes, :experiment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @experience = (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @locale = (x = opts.delete(:locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('locale', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @experiment = (x = opts.delete(:experiment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SessionExperimentForm) ? x : ::Io::Flow::V0::Models::SessionExperimentForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ip => ip,
              :experience => experience,
              :country => country,
              :currency => currency,
              :language => language,
              :locale => locale,
              :attributes => attributes.nil? ? nil : attributes,
              :experiment => experiment.nil? ? nil : experiment.to_hash
            }
          end

        end

        class SessionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SessionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # A session visit expires after a configurable period of inactivity (e.g. 30
        # minutes).
        class SessionVisit

          attr_reader :id, :expires_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :expires_at], 'SessionVisit')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionVisit.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :expires_at => expires_at
            }
          end

        end

        # A session visitor is a unique identifier for our best guess as to who the
        # individual user is interacting with Flow.
        class SessionVisitor

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SessionVisitor')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionVisitor.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ShipmentWindow

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'ShipmentWindow')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class ShippingAddress

          attr_reader :contact, :location, :center_key, :center_reference, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contact, :location], 'ShippingAddress')
            @contact = (x = opts.delete(:contact); x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x))
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @center_key = (x = opts.delete(:center_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('center_key', x, String))
            @center_reference = (x = opts.delete(:center_reference); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CenterReference) ? x : ::Io::Flow::V0::Models::CenterReference.new(x)))
            @service = (x = opts.delete(:service); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingAddress.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contact => contact.to_hash,
              :location => location.to_hash,
              :center_key => center_key,
              :center_reference => center_reference.nil? ? nil : center_reference.to_hash,
              :service => service.nil? ? nil : service.to_hash
            }
          end

        end

        class ShippingConfiguration

          attr_reader :id, :name, :key, :type, :shipping_lanes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :key, :type, :shipping_lanes], 'ShippingConfiguration')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationType) ? x : ::Io::Flow::V0::Models::ShippingConfigurationType.apply(x))
            @shipping_lanes = HttpClient::Preconditions.assert_class('shipping_lanes', opts.delete(:shipping_lanes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingLane) ? x : ::Io::Flow::V0::Models::ShippingLane.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfiguration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :key => key,
              :type => type.value,
              :shipping_lanes => shipping_lanes.map { |o| o.to_hash }
            }
          end

        end

        class ShippingConfigurationCopy

          attr_reader :original, :new

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:original, :new], 'ShippingConfigurationCopy')
            @original = (x = opts.delete(:original); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationReference) ? x : ::Io::Flow::V0::Models::ShippingConfigurationReference.new(x))
            @new = (x = opts.delete(:new); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationReference) ? x : ::Io::Flow::V0::Models::ShippingConfigurationReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationCopy.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :original => original.to_hash,
              :new => new.to_hash
            }
          end

        end

        class ShippingConfigurationCopyForm

          attr_reader :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ShippingConfigurationCopyForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationCopyForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name
            }
          end

        end

        class ShippingConfigurationDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_CONFIGURATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'ShippingConfigurationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class ShippingConfigurationForm

          attr_reader :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ShippingConfigurationForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name
            }
          end

        end

        # Denormalized availability status of an item in a shipping configuration for a
        # destination region
        class ShippingConfigurationItemAvailability

          attr_reader :id, :item, :shipping_configuration, :availabilities

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :shipping_configuration, :availabilities], 'ShippingConfigurationItemAvailability')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::ItemReference) ? x : ::Io::Flow::V0::Models::ItemReference.new(x))
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationSummary) ? x : ::Io::Flow::V0::Models::ShippingConfigurationSummary.new(x))
            @availabilities = HttpClient::Preconditions.assert_class('availabilities', opts.delete(:availabilities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CountryAvailability) ? x : ::Io::Flow::V0::Models::CountryAvailability.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationItemAvailability.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :shipping_configuration => shipping_configuration.to_hash,
              :availabilities => availabilities.map { |o| o.to_hash }
            }
          end

        end

        class ShippingConfigurationItemAvailabilityDeleted < Event

          attr_reader :event_id, :timestamp, :organization_id, :shipping_configuration_item_availability

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_id, :shipping_configuration_item_availability], 'ShippingConfigurationItemAvailabilityDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @shipping_configuration_item_availability = (x = opts.delete(:shipping_configuration_item_availability); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationItemAvailability) ? x : ::Io::Flow::V0::Models::ShippingConfigurationItemAvailability.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationItemAvailabilityDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_id => organization_id,
              :shipping_configuration_item_availability => shipping_configuration_item_availability.to_hash
            }
          end

        end

        class ShippingConfigurationItemAvailabilityUpserted < Event

          attr_reader :event_id, :timestamp, :organization_id, :shipping_configuration_item_availability

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_CONFIGURATION_ITEM_AVAILABILITY_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_id, :shipping_configuration_item_availability], 'ShippingConfigurationItemAvailabilityUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @shipping_configuration_item_availability = (x = opts.delete(:shipping_configuration_item_availability); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationItemAvailability) ? x : ::Io::Flow::V0::Models::ShippingConfigurationItemAvailability.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationItemAvailabilityUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_id => organization_id,
              :shipping_configuration_item_availability => shipping_configuration_item_availability.to_hash
            }
          end

        end

        # Denormalized shipping pricing available for a customer of an item in a
        # shipping configuration for a destination region.
        class ShippingConfigurationItemShippingPricing

          attr_reader :id, :item, :shipping_configuration, :country_shipping_pricings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :shipping_configuration, :country_shipping_pricings], 'ShippingConfigurationItemShippingPricing')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::ItemReference) ? x : ::Io::Flow::V0::Models::ItemReference.new(x))
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationSummary) ? x : ::Io::Flow::V0::Models::ShippingConfigurationSummary.new(x))
            @country_shipping_pricings = HttpClient::Preconditions.assert_class('country_shipping_pricings', opts.delete(:country_shipping_pricings), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CountryShippingPricing) ? x : ::Io::Flow::V0::Models::CountryShippingPricing.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationItemShippingPricing.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :shipping_configuration => shipping_configuration.to_hash,
              :country_shipping_pricings => country_shipping_pricings.map { |o| o.to_hash }
            }
          end

        end

        class ShippingConfigurationItemShippingPricingDeleted < Event

          attr_reader :event_id, :timestamp, :organization_id, :shipping_configuration_item_shipping_pricing

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_id, :shipping_configuration_item_shipping_pricing], 'ShippingConfigurationItemShippingPricingDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @shipping_configuration_item_shipping_pricing = (x = opts.delete(:shipping_configuration_item_shipping_pricing); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationItemShippingPricing) ? x : ::Io::Flow::V0::Models::ShippingConfigurationItemShippingPricing.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationItemShippingPricingDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_id => organization_id,
              :shipping_configuration_item_shipping_pricing => shipping_configuration_item_shipping_pricing.to_hash
            }
          end

        end

        class ShippingConfigurationItemShippingPricingUpserted < Event

          attr_reader :event_id, :timestamp, :organization_id, :shipping_configuration_item_shipping_pricing

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_CONFIGURATION_ITEM_SHIPPING_PRICING_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_id, :shipping_configuration_item_shipping_pricing], 'ShippingConfigurationItemShippingPricingUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @shipping_configuration_item_shipping_pricing = (x = opts.delete(:shipping_configuration_item_shipping_pricing); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationItemShippingPricing) ? x : ::Io::Flow::V0::Models::ShippingConfigurationItemShippingPricing.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationItemShippingPricingUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_id => organization_id,
              :shipping_configuration_item_shipping_pricing => shipping_configuration_item_shipping_pricing.to_hash
            }
          end

        end

        class ShippingConfigurationReference

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'ShippingConfigurationReference')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key
            }
          end

        end

        class ShippingConfigurationSummary

          attr_reader :id, :name, :key, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :key, :type], 'ShippingConfigurationSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationType) ? x : ::Io::Flow::V0::Models::ShippingConfigurationType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :key => key,
              :type => type.value
            }
          end

        end

        class ShippingConfigurationUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :shipping_configuration

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_CONFIGURATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :shipping_configuration], 'ShippingConfigurationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfiguration) ? x : ::Io::Flow::V0::Models::ShippingConfiguration.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :shipping_configuration => shipping_configuration.to_hash
            }
          end

        end

        class ShippingConfigurationVersion

          attr_reader :id, :timestamp, :type, :shipping_configuration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipping_configuration], 'ShippingConfigurationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfiguration) ? x : ::Io::Flow::V0::Models::ShippingConfiguration.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingConfigurationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipping_configuration => shipping_configuration.to_hash
            }
          end

        end

        # Represents information about a carrier-generated shipping label used by a
        # shipper to transport a package from a given origin to destination
        class ShippingLabel

          attr_reader :id, :attributes, :carrier_tracking_number, :carrier_tracking_number_url, :cost, :destination, :flow_tracking_number, :flow_tracking_number_url, :origin, :service, :window, :label, :invoice, :return_, :order, :package, :order_identifier, :fulfillment_key, :shipment_recipient

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier_tracking_number, :carrier_tracking_number_url, :cost, :destination, :flow_tracking_number, :flow_tracking_number_url, :origin, :service, :window, :shipment_recipient], 'ShippingLabel')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @carrier_tracking_number_url = HttpClient::Preconditions.assert_class('carrier_tracking_number_url', opts.delete(:carrier_tracking_number_url), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @flow_tracking_number_url = HttpClient::Preconditions.assert_class('flow_tracking_number_url', opts.delete(:flow_tracking_number_url), String)
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingLabelDocument) ? x : ::Io::Flow::V0::Models::ShippingLabelDocument.new(x)))
            @invoice = (x = opts.delete(:invoice); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingLabelDocument) ? x : ::Io::Flow::V0::Models::ShippingLabelDocument.new(x)))
            @return_ = (x = opts.delete(:return); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingLabelDocument) ? x : ::Io::Flow::V0::Models::ShippingLabelDocument.new(x)))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LabelOrderSummary) ? x : ::Io::Flow::V0::Models::LabelOrderSummary.new(x)))
            @package = (x = opts.delete(:package); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x)))
            @order_identifier = (x = opts.delete(:order_identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_identifier', x, String))
            @fulfillment_key = (x = opts.delete(:fulfillment_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('fulfillment_key', x, String))
            @shipment_recipient = (x = opts.delete(:shipment_recipient); x.is_a?(::Io::Flow::V0::Models::ShipmentRecipient) ? x : ::Io::Flow::V0::Models::ShipmentRecipient.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabel.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :attributes => attributes,
              :carrier_tracking_number => carrier_tracking_number,
              :carrier_tracking_number_url => carrier_tracking_number_url,
              :cost => cost.to_hash,
              :destination => destination.to_hash,
              :flow_tracking_number => flow_tracking_number,
              :flow_tracking_number_url => flow_tracking_number_url,
              :origin => origin.to_hash,
              :service => service.to_hash,
              :window => window.to_hash,
              :label => label.nil? ? nil : label.to_hash,
              :invoice => invoice.nil? ? nil : invoice.to_hash,
              :return => return_.nil? ? nil : return_.to_hash,
              :order => order.nil? ? nil : order.to_hash,
              :package => package.nil? ? nil : package.to_hash,
              :order_identifier => order_identifier,
              :fulfillment_key => fulfillment_key,
              :shipment_recipient => shipment_recipient.value
            }
          end

        end

        # Output data or downloadable links for shipping label documents such as labels
        # or commercial invoices
        class ShippingLabelDocument

          attr_reader :zpl, :pdf, :png, :html

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @png = (x = opts.delete(:png); x.nil? ? nil : HttpClient::Preconditions.assert_class('png', x, String))
            @html = (x = opts.delete(:html); x.nil? ? nil : HttpClient::Preconditions.assert_class('html', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabelDocument.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :zpl => zpl,
              :pdf => pdf,
              :png => png,
              :html => html
            }
          end

        end

        # Describes a package to be shipped, including dimensions and items included
        class ShippingLabelPackage

          attr_reader :dimensions, :items, :reference_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:dimensions, :items], 'ShippingLabelPackage')
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @reference_number = (x = opts.delete(:reference_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference_number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabelPackage.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :dimensions => dimensions.to_hash,
              :items => items.map { |o| o.to_hash },
              :reference_number => reference_number
            }
          end

        end

        class ShippingLabelSummary

          attr_reader :id, :flow_tracking_number, :carrier_tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :flow_tracking_number, :carrier_tracking_number], 'ShippingLabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :flow_tracking_number => flow_tracking_number,
              :carrier_tracking_number => carrier_tracking_number
            }
          end

        end

        class ShippingLabelVersion

          attr_reader :id, :timestamp, :type, :shipping_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipping_label], 'ShippingLabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipping_label = (x = opts.delete(:shipping_label); x.is_a?(::Io::Flow::V0::Models::ShippingLabel) ? x : ::Io::Flow::V0::Models::ShippingLabel.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipping_label => shipping_label.to_hash
            }
          end

        end

        class ShippingLane

          attr_reader :id, :shipping_configuration, :region, :centers, :tiers, :query, :strategy, :direction, :preference

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :shipping_configuration, :region, :centers, :tiers, :query], 'ShippingLane')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @shipping_configuration = (x = opts.delete(:shipping_configuration); x.is_a?(::Io::Flow::V0::Models::ShippingConfigurationReference) ? x : ::Io::Flow::V0::Models::ShippingConfigurationReference.new(x))
            @region = HttpClient::Preconditions.assert_class('region', opts.delete(:region), String)
            @centers = HttpClient::Preconditions.assert_class('centers', opts.delete(:centers), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExpandableCenter) ? x : ::Io::Flow::V0::Models::ExpandableCenter.from_json(x)) }
            @tiers = HttpClient::Preconditions.assert_class('tiers', opts.delete(:tiers), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Tier) ? x : ::Io::Flow::V0::Models::Tier.new(x)) }
            @query = (x = opts.delete(:query); x.is_a?(::Io::Flow::V0::Models::Query) ? x : ::Io::Flow::V0::Models::Query.new(x))
            @strategy = (x = (x = opts.delete(:strategy); x.nil? ? "oldest" : x); x.is_a?(::Io::Flow::V0::Models::LaneStrategy) ? x : ::Io::Flow::V0::Models::LaneStrategy.apply(x))
            @direction = (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LaneDirection) ? x : ::Io::Flow::V0::Models::LaneDirection.apply(x)))
            @preference = (x = opts.delete(:preference); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LanePreselectPreference) ? x : ::Io::Flow::V0::Models::LanePreselectPreference.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLane.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :shipping_configuration => shipping_configuration.to_hash,
              :region => region,
              :centers => centers.map { |o| o.to_hash },
              :tiers => tiers.map { |o| o.to_hash },
              :query => query.to_hash,
              :strategy => strategy.value,
              :direction => direction.nil? ? nil : direction.value,
              :preference => preference.nil? ? nil : preference.value
            }
          end

        end

        class ShippingLaneDefaultTier

          attr_reader :id, :tier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tier], 'ShippingLaneDefaultTier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLaneDefaultTier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tier => tier.to_hash
            }
          end

        end

        class ShippingLaneDefaultTierForm

          attr_reader :tier_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tier_id], 'ShippingLaneDefaultTierForm')
            @tier_id = HttpClient::Preconditions.assert_class('tier_id', opts.delete(:tier_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLaneDefaultTierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tier_id => tier_id
            }
          end

        end

        class ShippingLaneDeleted < Event

          attr_reader :event_id, :timestamp, :shipping_lane

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_LANE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :shipping_lane], 'ShippingLaneDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @shipping_lane = (x = opts.delete(:shipping_lane); x.is_a?(::Io::Flow::V0::Models::ShippingLane) ? x : ::Io::Flow::V0::Models::ShippingLane.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLaneDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :shipping_lane => shipping_lane.to_hash
            }
          end

        end

        class ShippingLaneForm

          attr_reader :from, :to, :strategy, :direction, :preference

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'ShippingLaneForm')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), String)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), String)
            @strategy = (x = opts.delete(:strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LaneStrategy) ? x : ::Io::Flow::V0::Models::LaneStrategy.apply(x)))
            @direction = (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LaneDirection) ? x : ::Io::Flow::V0::Models::LaneDirection.apply(x)))
            @preference = (x = opts.delete(:preference); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LanePreselectPreference) ? x : ::Io::Flow::V0::Models::LanePreselectPreference.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLaneForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :strategy => strategy.nil? ? nil : strategy.value,
              :direction => direction.nil? ? nil : direction.value,
              :preference => preference.nil? ? nil : preference.value
            }
          end

        end

        class ShippingLaneSummary

          attr_reader :shipping_lane_id, :region, :centers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:shipping_lane_id, :region, :centers], 'ShippingLaneSummary')
            @shipping_lane_id = HttpClient::Preconditions.assert_class('shipping_lane_id', opts.delete(:shipping_lane_id), String)
            @region = HttpClient::Preconditions.assert_class('region', opts.delete(:region), String)
            @centers = HttpClient::Preconditions.assert_class('centers', opts.delete(:centers), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExpandableCenter) ? x : ::Io::Flow::V0::Models::ExpandableCenter.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLaneSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :shipping_lane_id => shipping_lane_id,
              :region => region,
              :centers => centers.map { |o| o.to_hash }
            }
          end

        end

        class ShippingLaneUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :shipping_lane

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHIPPING_LANE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :shipping_lane], 'ShippingLaneUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @shipping_lane = (x = opts.delete(:shipping_lane); x.is_a?(::Io::Flow::V0::Models::ShippingLane) ? x : ::Io::Flow::V0::Models::ShippingLane.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLaneUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :shipping_lane => shipping_lane.to_hash
            }
          end

        end

        class ShippingLaneVersion

          attr_reader :id, :timestamp, :type, :shipping_lane

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipping_lane], 'ShippingLaneVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipping_lane = (x = opts.delete(:shipping_lane); x.is_a?(::Io::Flow::V0::Models::ShippingLane) ? x : ::Io::Flow::V0::Models::ShippingLane.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLaneVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipping_lane => shipping_lane.to_hash
            }
          end

        end

        # Represents information about a client-facilitated shipment where the shipping
        # label and fulfillment was not handled by Flow. For merchant-of-record and
        # tracking purposes, clients doing their own shipping will need to notify Flow
        # of shipped packages.
        class ShippingNotification

          attr_reader :id, :key, :attributes, :carrier_tracking_number, :destination, :flow_tracking_number, :origin, :package, :service, :window, :order, :order_identifier, :fulfillment_key, :shipment_recipient

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :carrier_tracking_number, :destination, :flow_tracking_number, :origin, :package, :service, :window], 'ShippingNotification')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LabelOrderSummary) ? x : ::Io::Flow::V0::Models::LabelOrderSummary.new(x)))
            @order_identifier = (x = opts.delete(:order_identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_identifier', x, String))
            @fulfillment_key = (x = opts.delete(:fulfillment_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('fulfillment_key', x, String))
            @shipment_recipient = (x = opts.delete(:shipment_recipient); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShipmentRecipient) ? x : ::Io::Flow::V0::Models::ShipmentRecipient.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingNotification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :attributes => attributes,
              :carrier_tracking_number => carrier_tracking_number,
              :destination => destination.to_hash,
              :flow_tracking_number => flow_tracking_number,
              :origin => origin.to_hash,
              :package => package.to_hash,
              :service => service.to_hash,
              :window => window.to_hash,
              :order => order.nil? ? nil : order.to_hash,
              :order_identifier => order_identifier,
              :fulfillment_key => fulfillment_key,
              :shipment_recipient => shipment_recipient.nil? ? nil : shipment_recipient.value
            }
          end

        end

        class ShippingNotificationVersion

          attr_reader :id, :timestamp, :type, :shipping_notification

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipping_notification], 'ShippingNotificationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipping_notification = (x = opts.delete(:shipping_notification); x.is_a?(::Io::Flow::V0::Models::ShippingNotification) ? x : ::Io::Flow::V0::Models::ShippingNotification.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingNotificationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipping_notification => shipping_notification.to_hash
            }
          end

        end

        # Representation of a Shopify cart exactly as defined by shopify.com
        class ShopifyCart

          attr_reader :id, :items, :item_count, :total_price, :local, :attributes, :note, :requires_shipping, :total_weight

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :item_count, :total_price, :local], 'ShopifyCart')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyCartItem) ? x : ::Io::Flow::V0::Models::ShopifyCartItem.new(x)) }
            @item_count = HttpClient::Preconditions.assert_class('item_count', opts.delete(:item_count), Integer)
            @total_price = HttpClient::Preconditions.assert_class('total_price', opts.delete(:total_price), Integer)
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::ShopifyLocalCartMetadata) ? x : ::Io::Flow::V0::Models::ShopifyLocalCartMetadata.new(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', HttpClient::Helper.to_object(x), Hash))
            @note = (x = opts.delete(:note); x.nil? ? nil : HttpClient::Preconditions.assert_class('note', x, String))
            @requires_shipping = HttpClient::Preconditions.assert_boolean('requires_shipping', (x = opts.delete(:requires_shipping); x.nil? ? true : x))
            @total_weight = (x = opts.delete(:total_weight); x.nil? ? nil : HttpClient::Preconditions.assert_class('total_weight', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCart.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash },
              :item_count => item_count,
              :total_price => total_price,
              :local => local.to_hash,
              :attributes => attributes,
              :note => note,
              :requires_shipping => requires_shipping,
              :total_weight => total_weight
            }
          end

        end

        class ShopifyCartAddMultipleForm < ShopifyCartAddForm

          attr_reader :items, :attributes

          def initialize(incoming={})
            super(:discriminator => ShopifyCartAddForm::Types::SHOPIFY_CART_ADD_MULTIPLE_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'ShopifyCartAddMultipleForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyCartAddSingleForm) ? x : ::Io::Flow::V0::Models::ShopifyCartAddSingleForm.new(x)) }
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCartAddMultipleForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :items => items.map { |o| o.to_hash },
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class ShopifyCartAddSingleForm < ShopifyCartAddForm

          attr_reader :id, :quantity, :properties

          def initialize(incoming={})
            super(:discriminator => ShopifyCartAddForm::Types::SHOPIFY_CART_ADD_SINGLE_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :quantity], 'ShopifyCartAddSingleForm')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), Integer)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @properties = (x = opts.delete(:properties); x.nil? ? nil : HttpClient::Preconditions.assert_class('properties', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('properties', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCartAddSingleForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :quantity => quantity,
              :properties => properties.nil? ? nil : properties
            }
          end

        end

        # Must provide either line or id. If you provide both, they must match
        class ShopifyCartChangeForm

          attr_reader :quantity, :line, :id, :properties

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'ShopifyCartChangeForm')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @line = (x = opts.delete(:line); x.nil? ? nil : HttpClient::Preconditions.assert_class('line', x, Integer))
            @id = (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Integer))
            @properties = (x = opts.delete(:properties); x.nil? ? nil : HttpClient::Preconditions.assert_class('properties', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('properties', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCartChangeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :quantity => quantity,
              :line => line,
              :id => id,
              :properties => properties.nil? ? nil : properties
            }
          end

        end

        class ShopifyCartConversion

          attr_reader :flow, :shopify

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:flow, :shopify], 'ShopifyCartConversion')
            @flow = (x = opts.delete(:flow); x.is_a?(::Io::Flow::V0::Models::ShopifyCartConversionFlowOrder) ? x : ::Io::Flow::V0::Models::ShopifyCartConversionFlowOrder.new(x))
            @shopify = (x = opts.delete(:shopify); x.is_a?(::Io::Flow::V0::Models::ShopifyCartConversionShopifyCart) ? x : ::Io::Flow::V0::Models::ShopifyCartConversionShopifyCart.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCartConversion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :flow => flow.to_hash,
              :shopify => shopify.to_hash
            }
          end

        end

        class ShopifyCartConversionFlowOrder

          attr_reader :order, :errors

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order], 'ShopifyCartConversionFlowOrder')
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
            @errors = (x = opts.delete(:errors); x.nil? ? nil : HttpClient::Preconditions.assert_class('errors', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderError) ? x : ::Io::Flow::V0::Models::OrderError.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCartConversionFlowOrder.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order.to_hash,
              :errors => errors.nil? ? nil : errors.map { |o| o.to_hash }
            }
          end

        end

        class ShopifyCartConversionShopifyCart

          attr_reader :cart

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:cart], 'ShopifyCartConversionShopifyCart')
            @cart = (x = opts.delete(:cart); x.is_a?(::Io::Flow::Shopify::External::V0::Models::ShopifyCart) ? x : ::Io::Flow::Shopify::External::V0::Models::ShopifyCart.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCartConversionShopifyCart.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :cart => cart.to_hash
            }
          end

        end

        class ShopifyCartItem

          attr_reader :id, :handle, :line_price, :price, :product_id, :product_title, :quantity, :title, :url, :variant_id, :local, :gift_card, :image, :product_description, :product_type, :properties, :requires_shipping, :sku, :variant_title, :variant_options, :vendor

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :handle, :line_price, :price, :product_id, :product_title, :quantity, :title, :url, :variant_id, :local], 'ShopifyCartItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @handle = HttpClient::Preconditions.assert_class('handle', opts.delete(:handle), String)
            @line_price = HttpClient::Preconditions.assert_class('line_price', opts.delete(:line_price), Numeric)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Integer)
            @product_id = HttpClient::Preconditions.assert_class('product_id', opts.delete(:product_id), Integer)
            @product_title = HttpClient::Preconditions.assert_class('product_title', opts.delete(:product_title), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @title = HttpClient::Preconditions.assert_class('title', opts.delete(:title), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @variant_id = HttpClient::Preconditions.assert_class('variant_id', opts.delete(:variant_id), Integer)
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::ShopifyLocalCartItemMetadata) ? x : ::Io::Flow::V0::Models::ShopifyLocalCartItemMetadata.new(x))
            @gift_card = HttpClient::Preconditions.assert_boolean('gift_card', (x = opts.delete(:gift_card); x.nil? ? false : x))
            @image = (x = opts.delete(:image); x.nil? ? nil : HttpClient::Preconditions.assert_class('image', x, String))
            @product_description = (x = opts.delete(:product_description); x.nil? ? nil : HttpClient::Preconditions.assert_class('product_description', x, String))
            @product_type = (x = opts.delete(:product_type); x.nil? ? nil : HttpClient::Preconditions.assert_class('product_type', x, String))
            @properties = (x = opts.delete(:properties); x.nil? ? nil : HttpClient::Preconditions.assert_class('properties', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('properties', d[1], String); h })
            @requires_shipping = HttpClient::Preconditions.assert_boolean('requires_shipping', (x = opts.delete(:requires_shipping); x.nil? ? true : x))
            @sku = (x = opts.delete(:sku); x.nil? ? nil : HttpClient::Preconditions.assert_class('sku', x, String))
            @variant_title = (x = opts.delete(:variant_title); x.nil? ? nil : HttpClient::Preconditions.assert_class('variant_title', x, String))
            @variant_options = (x = opts.delete(:variant_options); x.nil? ? nil : HttpClient::Preconditions.assert_class('variant_options', x, Array).map { |v| HttpClient::Preconditions.assert_class('variant_options', v, String) })
            @vendor = (x = opts.delete(:vendor); x.nil? ? nil : HttpClient::Preconditions.assert_class('vendor', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCartItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :handle => handle,
              :line_price => line_price,
              :price => price,
              :product_id => product_id,
              :product_title => product_title,
              :quantity => quantity,
              :title => title,
              :url => url,
              :variant_id => variant_id,
              :local => local.to_hash,
              :gift_card => gift_card,
              :image => image,
              :product_description => product_description,
              :product_type => product_type,
              :properties => properties.nil? ? nil : properties,
              :requires_shipping => requires_shipping,
              :sku => sku,
              :variant_title => variant_title,
              :variant_options => variant_options.nil? ? nil : variant_options,
              :vendor => vendor
            }
          end

        end

        # Model to represent details available in a customer metafield.
        class ShopifyCustomerMetafieldValue

          attr_reader :flow_consumer_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:flow_consumer_id], 'ShopifyCustomerMetafieldValue')
            @flow_consumer_id = HttpClient::Preconditions.assert_class('flow_consumer_id', opts.delete(:flow_consumer_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyCustomerMetafieldValue.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :flow_consumer_id => flow_consumer_id
            }
          end

        end

        class ShopifyItemEventBucket < ShopifyEventBucket

          attr_reader :range, :count, :data

          def initialize(incoming={})
            super(:discriminator => ShopifyEventBucket::Types::SHOPIFY_ITEM_EVENT_BUCKET)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:range, :count, :data], 'ShopifyItemEventBucket')
            @range = (x = opts.delete(:range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
            @data = HttpClient::Preconditions.assert_class('data', opts.delete(:data), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyItemEventData) ? x : ::Io::Flow::V0::Models::ShopifyItemEventData.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyItemEventBucket.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :range => range.to_hash,
              :count => count,
              :data => data.map { |o| o.to_hash }
            }
          end

        end

        class ShopifyItemEventData

          attr_reader :created_at, :experience, :item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:created_at, :experience, :item], 'ShopifyItemEventData')
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::CatalogItemSummary) ? x : ::Io::Flow::V0::Models::CatalogItemSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyItemEventData.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :created_at => created_at,
              :experience => experience.to_hash,
              :item => item.to_hash
            }
          end

        end

        class ShopifyLine

          attr_reader :variant_id, :quantity, :price, :total, :price_source

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:variant_id, :quantity, :price, :total], 'ShopifyLine')
            @variant_id = HttpClient::Preconditions.assert_class('variant_id', opts.delete(:variant_id), Integer)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x))
            @price_source = (x = opts.delete(:price_source); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceSource) ? x : ::Io::Flow::V0::Models::PriceSource.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLine.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :variant_id => variant_id,
              :quantity => quantity,
              :price => price.to_hash,
              :total => total.to_hash,
              :price_source => price_source.nil? ? nil : price_source.to_hash
            }
          end

        end

        class ShopifyLocalCartItemMetadata

          attr_reader :line_price, :price

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:line_price, :price], 'ShopifyLocalCartItemMetadata')
            @line_price = (x = opts.delete(:line_price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalCartItemMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :line_price => line_price.to_hash,
              :price => price.to_hash
            }
          end

        end

        class ShopifyLocalCartMetadata

          attr_reader :total_price, :promotions, :rules, :subtotal, :vat, :duty, :discount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:total_price, :promotions, :subtotal], 'ShopifyLocalCartMetadata')
            @total_price = (x = opts.delete(:total_price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @promotions = (x = opts.delete(:promotions); x.is_a?(::Io::Flow::V0::Models::Promotions) ? x : ::Io::Flow::V0::Models::Promotions.new(x))
            @rules = (x = opts.delete(:rules); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderRulesSummary) ? x : ::Io::Flow::V0::Models::OrderRulesSummary.new(x)))
            @subtotal = (x = opts.delete(:subtotal); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @vat = (x = opts.delete(:vat); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalCartMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :total_price => total_price.to_hash,
              :promotions => promotions.to_hash,
              :rules => rules.nil? ? nil : rules.to_hash,
              :subtotal => subtotal.to_hash,
              :vat => vat.nil? ? nil : vat.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash
            }
          end

        end

        class ShopifyLocalPriceMetadata

          attr_reader :price

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'ShopifyLocalPriceMetadata')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalPriceMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :price => price.to_hash
            }
          end

        end

        class ShopifyLocalizationSetting

          attr_reader :id, :method, :datetime_range

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :method, :datetime_range], 'ShopifyLocalizationSetting')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::ShopifyLocalizationMethod) ? x : ::Io::Flow::V0::Models::ShopifyLocalizationMethod.apply(x))
            @datetime_range = (x = opts.delete(:datetime_range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalizationSetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :method => method.value,
              :datetime_range => datetime_range.to_hash
            }
          end

        end

        class ShopifyLocalizationSettingDeleted < Event

          attr_reader :event_id, :timestamp, :organization_id, :shopify_localization_setting

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHOPIFY_LOCALIZATION_SETTING_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_id, :shopify_localization_setting], 'ShopifyLocalizationSettingDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @shopify_localization_setting = (x = opts.delete(:shopify_localization_setting); x.is_a?(::Io::Flow::V0::Models::ShopifyLocalizationSetting) ? x : ::Io::Flow::V0::Models::ShopifyLocalizationSetting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalizationSettingDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_id => organization_id,
              :shopify_localization_setting => shopify_localization_setting.to_hash
            }
          end

        end

        class ShopifyLocalizationSettingForm

          attr_reader :method, :datetime_range

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:method, :datetime_range], 'ShopifyLocalizationSettingForm')
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::ShopifyLocalizationMethod) ? x : ::Io::Flow::V0::Models::ShopifyLocalizationMethod.apply(x))
            @datetime_range = (x = opts.delete(:datetime_range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalizationSettingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :method => method.value,
              :datetime_range => datetime_range.to_hash
            }
          end

        end

        class ShopifyLocalizationSettingUpserted < Event

          attr_reader :event_id, :timestamp, :organization_id, :shopify_localization_setting

          def initialize(incoming={})
            super(:discriminator => Event::Types::SHOPIFY_LOCALIZATION_SETTING_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization_id, :shopify_localization_setting], 'ShopifyLocalizationSettingUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @shopify_localization_setting = (x = opts.delete(:shopify_localization_setting); x.is_a?(::Io::Flow::V0::Models::ShopifyLocalizationSetting) ? x : ::Io::Flow::V0::Models::ShopifyLocalizationSetting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalizationSettingUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization_id => organization_id,
              :shopify_localization_setting => shopify_localization_setting.to_hash
            }
          end

        end

        class ShopifyLocalizedOrder

          attr_reader :id, :lines, :prices, :total, :allocation_details, :merchant_of_record, :merchant_of_record_entity, :incoterm, :flow_order_id, :tax_registration, :geo

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :lines, :prices, :total, :allocation_details], 'ShopifyLocalizedOrder')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), Integer)
            @lines = HttpClient::Preconditions.assert_class('lines', opts.delete(:lines), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyLine) ? x : ::Io::Flow::V0::Models::ShopifyLine.new(x)) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x)) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x))
            @allocation_details = HttpClient::Preconditions.assert_class('allocation_details', opts.delete(:allocation_details), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationDetail) ? x : ::Io::Flow::V0::Models::AllocationDetail.from_json(x)) }
            @merchant_of_record = (x = opts.delete(:merchant_of_record); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderMerchantOfRecord) ? x : ::Io::Flow::V0::Models::OrderMerchantOfRecord.apply(x)))
            @merchant_of_record_entity = (x = opts.delete(:merchant_of_record_entity); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x)))
            @incoterm = (x = opts.delete(:incoterm); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Incoterm) ? x : ::Io::Flow::V0::Models::Incoterm.apply(x)))
            @flow_order_id = (x = opts.delete(:flow_order_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_order_id', x, String))
            @tax_registration = (x = opts.delete(:tax_registration); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TaxRegistration) ? x : ::Io::Flow::V0::Models::TaxRegistration.new(x)))
            @geo = (x = opts.delete(:geo); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderGeo) ? x : ::Io::Flow::V0::Models::OrderGeo.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalizedOrder.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :lines => lines.map { |o| o.to_hash },
              :prices => prices.map { |o| o.to_hash },
              :total => total.to_hash,
              :allocation_details => allocation_details.map { |o| o.to_hash },
              :merchant_of_record => merchant_of_record.nil? ? nil : merchant_of_record.value,
              :merchant_of_record_entity => merchant_of_record_entity.nil? ? nil : merchant_of_record_entity.to_hash,
              :incoterm => incoterm.nil? ? nil : incoterm.value,
              :flow_order_id => flow_order_id,
              :tax_registration => tax_registration.nil? ? nil : tax_registration.to_hash,
              :geo => geo.nil? ? nil : geo.to_hash
            }
          end

        end

        class ShopifyLocalizedVariant

          attr_reader :id, :handle, :experience, :prices, :status, :inventory_status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :handle, :experience, :prices, :status], 'ShopifyLocalizedVariant')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), Integer)
            @handle = HttpClient::Preconditions.assert_class('handle', opts.delete(:handle), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @prices = (x = opts.delete(:prices); x.is_a?(::Io::Flow::V0::Models::ShopifyLocalizedVariantPrices) ? x : ::Io::Flow::V0::Models::ShopifyLocalizedVariantPrices.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
            @inventory_status = (x = opts.delete(:inventory_status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ItemAvailabilityStatus) ? x : ::Io::Flow::V0::Models::ItemAvailabilityStatus.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalizedVariant.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :handle => handle,
              :experience => experience.to_hash,
              :prices => prices.to_hash,
              :status => status.value,
              :inventory_status => inventory_status.nil? ? nil : inventory_status.value
            }
          end

        end

        class ShopifyLocalizedVariantPrices

          attr_reader :item, :compare_at, :vat, :duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item], 'ShopifyLocalizedVariantPrices')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x))
            @compare_at = (x = opts.delete(:compare_at); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x)))
            @vat = (x = opts.delete(:vat); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x)))
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocalizedVariantPrices.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :compare_at => compare_at.nil? ? nil : compare_at.to_hash,
              :vat => vat.nil? ? nil : vat.to_hash,
              :duty => duty.nil? ? nil : duty.to_hash
            }
          end

        end

        class ShopifyLocationFlowCenterMapping

          attr_reader :id, :shopify_location, :flow_center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :shopify_location, :flow_center], 'ShopifyLocationFlowCenterMapping')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @shopify_location = (x = opts.delete(:shopify_location); x.is_a?(::Io::Flow::V0::Models::ShopifyLocationReference) ? x : ::Io::Flow::V0::Models::ShopifyLocationReference.new(x))
            @flow_center = (x = opts.delete(:flow_center); x.is_a?(::Io::Flow::V0::Models::FlowCenterReference) ? x : ::Io::Flow::V0::Models::FlowCenterReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocationFlowCenterMapping.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :shopify_location => shopify_location.to_hash,
              :flow_center => flow_center.to_hash
            }
          end

        end

        class ShopifyLocationFlowCenterMappingForm

          attr_reader :shopify_location_id, :flow_center_key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:shopify_location_id, :flow_center_key], 'ShopifyLocationFlowCenterMappingForm')
            @shopify_location_id = HttpClient::Preconditions.assert_class('shopify_location_id', opts.delete(:shopify_location_id), Integer)
            @flow_center_key = HttpClient::Preconditions.assert_class('flow_center_key', opts.delete(:flow_center_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocationFlowCenterMappingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :shopify_location_id => shopify_location_id,
              :flow_center_key => flow_center_key
            }
          end

        end

        class ShopifyLocationReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ShopifyLocationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyLocationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ShopifyOrderAttributesForm

          attr_reader :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:attributes], 'ShopifyOrderAttributesForm')
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyOrderAttributesForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :attributes => attributes
            }
          end

        end

        # Model to represent a delivery metafield
        class ShopifyOrderDeliveryMetafield

          attr_reader :key, :items, :service, :window, :cost, :prices, :total, :merchant_of_record_entity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :service, :window], 'ShopifyOrderDeliveryMetafield')
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyOrderDeliveryMetafieldItem) ? x : ::Io::Flow::V0::Models::ShopifyOrderDeliveryMetafieldItem.new(x)) }
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DeliveryWindow) ? x : ::Io::Flow::V0::Models::DeliveryWindow.new(x))
            @cost = (x = opts.delete(:cost); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MoneyWithOptionalBase) ? x : ::Io::Flow::V0::Models::MoneyWithOptionalBase.new(x)))
            @prices = (x = opts.delete(:prices); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x)) })
            @total = (x = opts.delete(:total); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShopifyPrice) ? x : ::Io::Flow::V0::Models::ShopifyPrice.new(x)))
            @merchant_of_record_entity = (x = opts.delete(:merchant_of_record_entity); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MerchantOfRecordEntity) ? x : ::Io::Flow::V0::Models::MerchantOfRecordEntity.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyOrderDeliveryMetafield.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :items => items.map { |o| o.to_hash },
              :service => service.to_hash,
              :window => window.to_hash,
              :cost => cost.nil? ? nil : cost.to_hash,
              :prices => prices.nil? ? nil : prices.map { |o| o.to_hash },
              :total => total.nil? ? nil : total.to_hash,
              :merchant_of_record_entity => merchant_of_record_entity.nil? ? nil : merchant_of_record_entity.to_hash
            }
          end

        end

        # Model to represent a delivery metafield
        class ShopifyOrderDeliveryMetafieldItem

          attr_reader :number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'ShopifyOrderDeliveryMetafieldItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyOrderDeliveryMetafieldItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity
            }
          end

        end

        # Model to represent item's price attributes metafield
        class ShopifyOrderPriceAttributesMetafield

          attr_reader :item_number, :price_attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :price_attributes], 'ShopifyOrderPriceAttributesMetafield')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @price_attributes = HttpClient::Preconditions.assert_class('price_attributes', opts.delete(:price_attributes), Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x)); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyOrderPriceAttributesMetafield.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :price_attributes => price_attributes.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        # Model to represent romanized order detail metafield
        class ShopifyOrderRomanizationMetafield

          attr_reader :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination], 'ShopifyOrderRomanizationMetafield')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyOrderRomanizationMetafield.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash
            }
          end

        end

        class ShopifyPrice

          attr_reader :name, :amount, :cents, :currency, :label, :includes, :local

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :amount, :cents, :currency, :label], 'ShopifyPrice')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @cents = HttpClient::Preconditions.assert_class('cents', opts.delete(:cents), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @includes = (x = opts.delete(:includes); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::IncludedLevies) ? x : ::Io::Flow::V0::Models::IncludedLevies.new(x)))
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShopifyLocalPriceMetadata) ? x : ::Io::Flow::V0::Models::ShopifyLocalPriceMetadata.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyPrice.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :amount => amount,
              :cents => cents,
              :currency => currency,
              :label => label,
              :includes => includes.nil? ? nil : includes.to_hash,
              :local => local.nil? ? nil : local.to_hash
            }
          end

        end

        # Shopify private app information.
        class ShopifyPrivateApp

          attr_reader :id, :api_key, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :api_key, :password], 'ShopifyPrivateApp')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @api_key = HttpClient::Preconditions.assert_class('api_key', opts.delete(:api_key), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyPrivateApp.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :api_key => api_key,
              :password => password
            }
          end

        end

        class ShopifyPrivateAppForm

          attr_reader :api_key, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:api_key, :password], 'ShopifyPrivateAppForm')
            @api_key = HttpClient::Preconditions.assert_class('api_key', opts.delete(:api_key), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyPrivateAppForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :api_key => api_key,
              :password => password
            }
          end

        end

        class ShopifySyncStatus

          attr_reader :sync_check, :range, :interval_seconds, :total, :buckets

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:sync_check, :range, :interval_seconds, :total, :buckets], 'ShopifySyncStatus')
            @sync_check = (x = opts.delete(:sync_check); x.is_a?(::Io::Flow::V0::Models::ShopifySyncCheck) ? x : ::Io::Flow::V0::Models::ShopifySyncCheck.apply(x))
            @range = (x = opts.delete(:range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
            @interval_seconds = HttpClient::Preconditions.assert_class('interval_seconds', opts.delete(:interval_seconds), Integer)
            @total = HttpClient::Preconditions.assert_class('total', opts.delete(:total), Integer)
            @buckets = HttpClient::Preconditions.assert_class('buckets', opts.delete(:buckets), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShopifyEventBucket) ? x : ::Io::Flow::V0::Models::ShopifyEventBucket.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifySyncStatus.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :sync_check => sync_check.value,
              :range => range.to_hash,
              :interval_seconds => interval_seconds,
              :total => total,
              :buckets => buckets.map { |o| o.to_hash }
            }
          end

        end

        # The shopify variant metafield defines the individual metafield values we write
        # into Shopify for each variant. This model was introduced to enable server side
        # rendering of content (e.g. the price on the product detail page). Each field
        # in this model is available as its own metafield within a namespace named
        # 'price_abc' where abc is a unique, short identifier for an experience.
        class ShopifyVariantFlowMetafield

          attr_reader :prices_item, :prices_currency, :prices_includes, :prices_vat, :prices_vat_name, :prices_duty, :prices_compare_at, :prices_status, :inventory_status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:prices_item, :prices_currency, :prices_status], 'ShopifyVariantFlowMetafield')
            @prices_item = HttpClient::Preconditions.assert_class('prices_item', opts.delete(:prices_item), String)
            @prices_currency = HttpClient::Preconditions.assert_class('prices_currency', opts.delete(:prices_currency), String)
            @prices_includes = (x = opts.delete(:prices_includes); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices_includes', x, String))
            @prices_vat = (x = opts.delete(:prices_vat); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices_vat', x, String))
            @prices_vat_name = (x = opts.delete(:prices_vat_name); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices_vat_name', x, String))
            @prices_duty = (x = opts.delete(:prices_duty); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices_duty', x, String))
            @prices_compare_at = (x = opts.delete(:prices_compare_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('prices_compare_at', x, String))
            @prices_status = (x = opts.delete(:prices_status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
            @inventory_status = (x = opts.delete(:inventory_status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ItemAvailabilityStatus) ? x : ::Io::Flow::V0::Models::ItemAvailabilityStatus.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyVariantFlowMetafield.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :prices_item => prices_item,
              :prices_currency => prices_currency,
              :prices_includes => prices_includes,
              :prices_vat => prices_vat,
              :prices_vat_name => prices_vat_name,
              :prices_duty => prices_duty,
              :prices_compare_at => prices_compare_at,
              :prices_status => prices_status.value,
              :inventory_status => inventory_status.nil? ? nil : inventory_status.value
            }
          end

        end

        # For enabled organizations, this indicates the total number of available units
        # of inventory for customers in this experience.
        class ShopifyVariantInventoryMetafield

          attr_reader :experience, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:experience, :status], 'ShopifyVariantInventoryMetafield')
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ItemAvailabilityStatus) ? x : ::Io::Flow::V0::Models::ItemAvailabilityStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifyVariantInventoryMetafield.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :experience => experience.to_hash,
              :status => status.value
            }
          end

        end

        # A simple model, used to convey permitted behaviors along with approval of a
        # request for a specific permitted route.
        class SimplePermissionCheck

          attr_reader :behaviors

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:behaviors], 'SimplePermissionCheck')
            @behaviors = HttpClient::Preconditions.assert_class('behaviors', opts.delete(:behaviors), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::FlowBehavior) ? x : ::Io::Flow::V0::Models::FlowBehavior.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SimplePermissionCheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :behaviors => behaviors.map { |o| o.value }
            }
          end

        end

        # Simplified form for notifying Flow of a Fulfillment shipped entirely in a
        # single tracked package.
        class SinglePackageShippingNotificationForm < ShippingNotificationForm

          attr_reader :fulfillment_key, :carrier_tracking_number, :package_dimensions, :service, :shipment_recipient

          def initialize(incoming={})
            super(:discriminator => ShippingNotificationForm::Types::SINGLE_PACKAGE_SHIPPING_NOTIFICATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:fulfillment_key, :carrier_tracking_number], 'SinglePackageShippingNotificationForm')
            @fulfillment_key = HttpClient::Preconditions.assert_class('fulfillment_key', opts.delete(:fulfillment_key), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @package_dimensions = (x = opts.delete(:package_dimensions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            @shipment_recipient = (x = opts.delete(:shipment_recipient); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShipmentRecipient) ? x : ::Io::Flow::V0::Models::ShipmentRecipient.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SinglePackageShippingNotificationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :fulfillment_key => fulfillment_key,
              :carrier_tracking_number => carrier_tracking_number,
              :package_dimensions => package_dimensions.nil? ? nil : package_dimensions.to_hash,
              :service => service,
              :shipment_recipient => shipment_recipient.nil? ? nil : shipment_recipient.value
            }
          end

        end

        class SnapshotDeleted < Event

          attr_reader :event_id, :timestamp, :snapshot_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SNAPSHOT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :snapshot_id], 'SnapshotDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @snapshot_id = HttpClient::Preconditions.assert_class('snapshot_id', opts.delete(:snapshot_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SnapshotDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :snapshot_id => snapshot_id
            }
          end

        end

        class SnapshotUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :snapshot_id, :available, :center_key, :item_number, :quantity

          def initialize(incoming={})
            super(:discriminator => Event::Types::SNAPSHOT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :snapshot_id, :available, :center_key, :item_number, :quantity], 'SnapshotUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @snapshot_id = HttpClient::Preconditions.assert_class('snapshot_id', opts.delete(:snapshot_id), String)
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Integer)
            @center_key = HttpClient::Preconditions.assert_class('center_key', opts.delete(:center_key), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SnapshotUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :snapshot_id => snapshot_id,
              :available => available,
              :center_key => center_key,
              :item_number => item_number,
              :quantity => quantity
            }
          end

        end

        # Exports product level data for import into solidus
        class SolidusProductExportType < ExportType

          attr_reader :numbers, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::SOLIDUS_PRODUCT_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SolidusProductExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :sort => sort
            }
          end

        end

        # Exports variant level data for import into solidus
        class SolidusVariantExportType < ExportType

          attr_reader :numbers, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::SOLIDUS_VARIANT_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SolidusVariantExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :sort => sort
            }
          end

        end

        # Stripe authentication data.
        class StripeAuthenticationData < GatewayAuthenticationData

          attr_reader :secret_key_reference

          def initialize(incoming={})
            super(:discriminator => GatewayAuthenticationData::Types::STRIPE_AUTHENTICATION_DATA)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:secret_key_reference], 'StripeAuthenticationData')
            @secret_key_reference = HttpClient::Preconditions.assert_class('secret_key_reference', opts.delete(:secret_key_reference), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            StripeAuthenticationData.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :secret_key_reference => secret_key_reference
            }
          end

        end

        # Used to specify Stripe API secret key.
        class StripeAuthenticationDataForm < GatewayAuthenticationDataForm

          attr_reader :account_id, :secret_key, :key

          def initialize(incoming={})
            super(:discriminator => GatewayAuthenticationDataForm::Types::STRIPE_AUTHENTICATION_DATA_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:account_id, :secret_key], 'StripeAuthenticationDataForm')
            @account_id = HttpClient::Preconditions.assert_class('account_id', opts.delete(:account_id), String)
            @secret_key = HttpClient::Preconditions.assert_class('secret_key', opts.delete(:secret_key), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            StripeAuthenticationDataForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :account_id => account_id,
              :secret_key => secret_key,
              :key => key
            }
          end

        end

        # Provides details for Stripe authorizations (e.g. client secret to be used for
        # 3D Secure).
        class StripeAuthorizationResultActionDetails < AuthorizationResultActionDetails

          attr_reader :client_secret, :payment_method_id, :publishable_key

          def initialize(incoming={})
            super(:discriminator => AuthorizationResultActionDetails::Types::STRIPE_AUTHORIZATION_RESULT_ACTION_DETAILS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @client_secret = (x = opts.delete(:client_secret); x.nil? ? nil : HttpClient::Preconditions.assert_class('client_secret', x, String))
            @payment_method_id = (x = opts.delete(:payment_method_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment_method_id', x, String))
            @publishable_key = (x = opts.delete(:publishable_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('publishable_key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            StripeAuthorizationResultActionDetails.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :client_secret => client_secret,
              :payment_method_id => payment_method_id,
              :publishable_key => publishable_key
            }
          end

        end

        # A configuration with custom query to select a subset of master catalog items
        # for a localized experience
        class Subcatalog < ExpandableSubcatalog

          attr_reader :id, :catalog, :settings

          def initialize(incoming={})
            super(:discriminator => ExpandableSubcatalog::Types::SUBCATALOG)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :catalog, :settings], 'Subcatalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
            @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::V0::Models::SubcatalogSettings) ? x : ::Io::Flow::V0::Models::SubcatalogSettings.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Subcatalog.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :catalog => catalog.to_hash,
              :settings => settings.to_hash
            }
          end

        end

        class SubcatalogDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog, :subcatalog_id], 'SubcatalogDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class SubcatalogForm

          attr_reader :settings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @settings = (x = opts.delete(:settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogSettingsForm) ? x : ::Io::Flow::V0::Models::SubcatalogSettingsForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :settings => settings.nil? ? nil : settings.to_hash
            }
          end

        end

        # Represents information specific to an item in a given subcatalog
        class SubcatalogItem

          attr_reader :id, :item, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :status], 'SubcatalogItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :status => status.value
            }
          end

        end

        class SubcatalogItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id], 'SubcatalogItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class SubcatalogItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id, :status

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id, :status], 'SubcatalogItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id,
              :status => status
            }
          end

        end

        class SubcatalogItemVersion

          attr_reader :id, :timestamp, :type, :subcatalog_item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog_item], 'SubcatalogItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog_item = (x = opts.delete(:subcatalog_item); x.is_a?(::Io::Flow::V0::Models::SubcatalogItem) ? x : ::Io::Flow::V0::Models::SubcatalogItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog_item => subcatalog_item.to_hash
            }
          end

        end

        # Represents a typed query to indicate which items to include or exclude in a
        # subcatalog
        class SubcatalogQuery

          attr_reader :id, :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :type], 'SubcatalogQuery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogQuery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :type => type.value
            }
          end

        end

        # Defines a query specifying items to be included or excluded in a subcatalog
        class SubcatalogQueryForm

          attr_reader :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :type], 'SubcatalogQueryForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogQueryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :type => type.value
            }
          end

        end

        # Indicates valid and invalid queries
        class SubcatalogQueryValidation

          attr_reader :valid, :invalid

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:valid, :invalid], 'SubcatalogQueryValidation')
            @valid = HttpClient::Preconditions.assert_class('valid', opts.delete(:valid), Array).map { |v| HttpClient::Preconditions.assert_class('valid', v, String) }
            @invalid = HttpClient::Preconditions.assert_class('invalid', opts.delete(:invalid), Array).map { |v| HttpClient::Preconditions.assert_class('invalid', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogQueryValidation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :valid => valid,
              :invalid => invalid
            }
          end

        end

        class SubcatalogReference < ExpandableSubcatalog

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandableSubcatalog::Types::SUBCATALOG_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SubcatalogReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class SubcatalogSettings

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = (x = opts.delete(:update_policy); x.nil? ? "auto" : x); x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.value
            }
          end

        end

        class SubcatalogSettingsForm

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = opts.delete(:update_policy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.nil? ? nil : update_policy.value
            }
          end

        end

        # Statistics related to the items in this subcatalog, including item count,
        # number of distinct categories, etc.
        class SubcatalogStatistics

          attr_reader :excluded, :included, :restricted, :queue, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:excluded, :included, :restricted, :queue, :catalog], 'SubcatalogStatistics')
            @excluded = (x = opts.delete(:excluded); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @included = (x = opts.delete(:included); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @restricted = (x = opts.delete(:restricted); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @queue = (x = opts.delete(:queue); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogStatistics) ? x : ::Io::Flow::V0::Models::CatalogStatistics.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :excluded => excluded.to_hash,
              :included => included.to_hash,
              :restricted => restricted.to_hash,
              :queue => queue.to_hash,
              :catalog => catalog.to_hash
            }
          end

        end

        class SubcatalogUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog, :subcatalog_id], 'SubcatalogUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class SubcatalogVersion

          attr_reader :id, :timestamp, :type, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog], 'SubcatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::Subcatalog) ? x : ::Io::Flow::V0::Models::Subcatalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog => subcatalog.to_hash
            }
          end

        end

        class Suggestion

          attr_reader :label, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label, :count], 'Suggestion')
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Suggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label => label,
              :count => count
            }
          end

        end

        # Minimal form to create a shipping label. Origin and destination are assumed
        # based on a given order's center and final shipping destination
        class SummaryShippingLabelForm < ShippingLabelForm

          attr_reader :order_number, :items

          def initialize(incoming={})
            super(:discriminator => ShippingLabelForm::Types::SUMMARY_SHIPPING_LABEL_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order_number, :items], 'SummaryShippingLabelForm')
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SummaryShippingLabelForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :order_number => order_number,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        # Surcharge responsible parties that can be displayed and selected
        class SurchargeResponsiblePartyDisplay

          attr_reader :name, :responsible_party

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :responsible_party], 'SurchargeResponsiblePartyDisplay')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @responsible_party = (x = opts.delete(:responsible_party); x.is_a?(::Io::Flow::V0::Models::SurchargeResponsibleParty) ? x : ::Io::Flow::V0::Models::SurchargeResponsibleParty.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SurchargeResponsiblePartyDisplay.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :responsible_party => responsible_party.value
            }
          end

        end

        class SurchargeSetting

          attr_reader :key, :responsible_party

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :responsible_party], 'SurchargeSetting')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionCostDetailComponentKey) ? x : ::Io::Flow::V0::Models::DeliveryOptionCostDetailComponentKey.apply(x))
            @responsible_party = (x = opts.delete(:responsible_party); x.is_a?(::Io::Flow::V0::Models::SurchargeResponsibleParty) ? x : ::Io::Flow::V0::Models::SurchargeResponsibleParty.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SurchargeSetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :responsible_party => responsible_party.value
            }
          end

        end

        # Surcharge settings that can be displayed and configured
        class SurchargeSettingDisplay

          attr_reader :name, :description, :key, :available

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :description, :key, :available], 'SurchargeSettingDisplay')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionCostDetailComponentKey) ? x : ::Io::Flow::V0::Models::DeliveryOptionCostDetailComponentKey.apply(x))
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SurchargeResponsiblePartyDisplay) ? x : ::Io::Flow::V0::Models::SurchargeResponsiblePartyDisplay.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SurchargeSettingDisplay.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :description => description,
              :key => key.value,
              :available => available.map { |o| o.to_hash }
            }
          end

        end

        class Targeting

          attr_reader :id, :key, :queries, :catalog, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :queries, :catalog], 'Targeting')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @queries = HttpClient::Preconditions.assert_class('queries', opts.delete(:queries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TargetingQuery) ? x : ::Io::Flow::V0::Models::TargetingQuery.new(x)) }
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogReference) ? x : ::Io::Flow::V0::Models::CatalogReference.new(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Targeting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :queries => queries.map { |o| o.to_hash },
              :catalog => catalog.to_hash,
              :subcatalog => subcatalog.nil? ? nil : subcatalog.to_hash
            }
          end

        end

        class TargetingForm

          attr_reader :key, :queries, :subcatalog_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :queries], 'TargetingForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @queries = HttpClient::Preconditions.assert_class('queries', opts.delete(:queries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TargetingQueryForm) ? x : ::Io::Flow::V0::Models::TargetingQueryForm.new(x)) }
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :queries => queries.map { |o| o.to_hash },
              :subcatalog_id => subcatalog_id
            }
          end

        end

        # Represents catalog items where a targeting query is applicable
        class TargetingItem

          attr_reader :id, :targeting, :item_number, :query

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :targeting, :item_number, :query], 'TargetingItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @targeting = (x = opts.delete(:targeting); x.is_a?(::Io::Flow::V0::Models::TargetingSummary) ? x : ::Io::Flow::V0::Models::TargetingSummary.new(x))
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @query = (x = opts.delete(:query); x.is_a?(::Io::Flow::V0::Models::TargetingQuery) ? x : ::Io::Flow::V0::Models::TargetingQuery.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :targeting => targeting.to_hash,
              :item_number => item_number,
              :query => query.to_hash
            }
          end

        end

        class TargetingItemDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::TARGETING_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'TargetingItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class TargetingItemDeletedV3 < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::TARGETING_ITEM_DELETED_V3)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'TargetingItemDeletedV3')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItemDeletedV3.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Indiciates that a given item has been targeted by the query q producing an
        # outcome. The item number is unique within its targeting_id.
        class TargetingItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :targeting_id, :item_number, :q, :outcome_id, :catalog_id, :key, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::TARGETING_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :targeting_id, :item_number, :q, :outcome_id, :catalog_id, :key], 'TargetingItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @targeting_id = HttpClient::Preconditions.assert_class('targeting_id', opts.delete(:targeting_id), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @outcome_id = HttpClient::Preconditions.assert_class('outcome_id', opts.delete(:outcome_id), String)
            @catalog_id = HttpClient::Preconditions.assert_class('catalog_id', opts.delete(:catalog_id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :targeting_id => targeting_id,
              :item_number => item_number,
              :q => q,
              :outcome_id => outcome_id,
              :catalog_id => catalog_id,
              :key => key,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class TargetingItemUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :targeting_item

          def initialize(incoming={})
            super(:discriminator => Event::Types::TARGETING_ITEM_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :targeting_item], 'TargetingItemUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @targeting_item = (x = opts.delete(:targeting_item); x.is_a?(::Io::Flow::V0::Models::TargetingItem) ? x : ::Io::Flow::V0::Models::TargetingItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItemUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :targeting_item => targeting_item.to_hash
            }
          end

        end

        class TargetingQuery

          attr_reader :id, :q, :outcome_id, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :outcome_id, :position], 'TargetingQuery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @outcome_id = HttpClient::Preconditions.assert_class('outcome_id', opts.delete(:outcome_id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingQuery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :outcome_id => outcome_id,
              :position => position
            }
          end

        end

        class TargetingQueryForm

          attr_reader :q, :outcome_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :outcome_id], 'TargetingQueryForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @outcome_id = HttpClient::Preconditions.assert_class('outcome_id', opts.delete(:outcome_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingQueryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :outcome_id => outcome_id
            }
          end

        end

        class TargetingSummary

          attr_reader :id, :key, :catalog, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :catalog], 'TargetingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogReference) ? x : ::Io::Flow::V0::Models::CatalogReference.new(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :catalog => catalog.to_hash,
              :subcatalog => subcatalog.nil? ? nil : subcatalog.to_hash
            }
          end

        end

        class TargetingVersion

          attr_reader :id, :timestamp, :type, :targeting

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :targeting], 'TargetingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @targeting = (x = opts.delete(:targeting); x.is_a?(::Io::Flow::V0::Models::Targeting) ? x : ::Io::Flow::V0::Models::Targeting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :targeting => targeting.to_hash
            }
          end

        end

        # Represents a simple model of taxes that apply to a given item / destination.
        class Tax

          attr_reader :name, :rate, :components, :deminimis

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :rate, :components], 'Tax')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimis = (x = opts.delete(:deminimis); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimis) ? x : ::Io::Flow::V0::Models::Deminimis.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tax.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :rate => rate.to_f.to_s,
              :components => components.map { |o| o.value },
              :deminimis => deminimis.nil? ? nil : deminimis.to_hash
            }
          end

        end

        # Result of looking up a specific tax registration number. Indicates validity of
        # a number for a specific country and (if valid) the associated person/company.
        class TaxRegistration

          attr_reader :id, :key, :number, :timestamp, :result, :result_reason, :name, :address, :company_name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :number, :timestamp, :result], 'TaxRegistration')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @result = (x = opts.delete(:result); x.is_a?(::Io::Flow::V0::Models::TaxVerificationResult) ? x : ::Io::Flow::V0::Models::TaxVerificationResult.apply(x))
            @result_reason = (x = opts.delete(:result_reason); x.nil? ? nil : HttpClient::Preconditions.assert_class('result_reason', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String))
            @company_name = (x = opts.delete(:company_name); x.nil? ? nil : HttpClient::Preconditions.assert_class('company_name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TaxRegistration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :number => number,
              :timestamp => timestamp,
              :result => result.value,
              :result_reason => result_reason,
              :name => name,
              :address => address,
              :company_name => company_name
            }
          end

        end

        class TaxRegistrationForm

          attr_reader :number, :company_name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'TaxRegistrationForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @company_name = (x = opts.delete(:company_name); x.nil? ? nil : HttpClient::Preconditions.assert_class('company_name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TaxRegistrationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :company_name => company_name
            }
          end

        end

        # Represents the results from 3D Secure, if applied to an authorization
        class ThreeDSecure

          attr_reader :code, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'ThreeDSecure')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::ThreeDSecureCode) ? x : ::Io::Flow::V0::Models::ThreeDSecureCode.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ThreeDSecure.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :description => description
            }
          end

        end

        # Service shipping tier available in this tier group. e.g. Standard tier,
        # Express tier, Economy tier
        class Tier

          attr_reader :id, :direction, :integration, :name, :message, :rules, :services, :strategy, :visibility, :currency, :description, :display, :shipping_lane, :surcharge_settings, :lane

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :integration, :name, :rules, :services, :strategy, :visibility, :currency], 'Tier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @direction = (x = (x = opts.delete(:direction); x.nil? ? "outbound" : x); x.is_a?(::Io::Flow::V0::Models::LaneDirection) ? x : ::Io::Flow::V0::Models::LaneDirection.apply(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @message = (x = opts.delete(:message); x.nil? ? nil : HttpClient::Preconditions.assert_class('message', x, String))
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CarrierService) ? x : ::Io::Flow::V0::Models::CarrierService.new(x)) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @display = (x = opts.delete(:display); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TierDisplay) ? x : ::Io::Flow::V0::Models::TierDisplay.new(x)))
            @shipping_lane = (x = opts.delete(:shipping_lane); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipping_lane', x, String))
            @surcharge_settings = (x = opts.delete(:surcharge_settings); x.nil? ? nil : HttpClient::Preconditions.assert_class('surcharge_settings', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SurchargeSetting) ? x : ::Io::Flow::V0::Models::SurchargeSetting.new(x)) })
            @lane = (x = opts.delete(:lane); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingLaneSummary) ? x : ::Io::Flow::V0::Models::ShippingLaneSummary.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :direction => direction.value,
              :integration => integration.value,
              :name => name,
              :message => message,
              :rules => rules.map { |o| o.to_hash },
              :services => services.map { |o| o.to_hash },
              :strategy => strategy.value,
              :visibility => visibility.value,
              :currency => currency,
              :description => description,
              :display => display.nil? ? nil : display.to_hash,
              :shipping_lane => shipping_lane,
              :surcharge_settings => surcharge_settings.nil? ? nil : surcharge_settings.map { |o| o.to_hash },
              :lane => lane.nil? ? nil : lane.to_hash
            }
          end

        end

        class TierDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :tier

          def initialize(incoming={})
            super(:discriminator => Event::Types::TIER_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :tier], 'TierDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::Tier) ? x : ::Io::Flow::V0::Models::Tier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :tier => tier.to_hash
            }
          end

        end

        class TierDisplay

          attr_reader :estimate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:estimate], 'TierDisplay')
            @estimate = (x = opts.delete(:estimate); x.is_a?(::Io::Flow::V0::Models::TierEstimate) ? x : ::Io::Flow::V0::Models::TierEstimate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDisplay.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :estimate => estimate.to_hash
            }
          end

        end

        class TierDisplayForm

          attr_reader :estimate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @estimate = (x = opts.delete(:estimate); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TierEstimate) ? x : ::Io::Flow::V0::Models::TierEstimate.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDisplayForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :estimate => estimate.nil? ? nil : estimate.to_hash
            }
          end

        end

        class TierEstimate

          attr_reader :type, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'TierEstimate')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::TierEstimateType) ? x : ::Io::Flow::V0::Models::TierEstimateType.apply(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :label => label
            }
          end

        end

        # Service shipping tier available in this tier group. e.g. Standard tier,
        # Express tier, Economy tier
        class TierForm

          attr_reader :currency, :integration, :name, :message, :rules, :services, :strategy, :visibility, :description, :direction, :display, :shipping_lane, :surcharge_settings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :integration, :name, :rules, :services, :strategy, :visibility, :shipping_lane], 'TierForm')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @message = (x = opts.delete(:message); x.nil? ? nil : HttpClient::Preconditions.assert_class('message', x, String))
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRuleForm) ? x : ::Io::Flow::V0::Models::TierRuleForm.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', v, String) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @direction = (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LaneDirection) ? x : ::Io::Flow::V0::Models::LaneDirection.apply(x)))
            @display = (x = opts.delete(:display); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TierDisplayForm) ? x : ::Io::Flow::V0::Models::TierDisplayForm.new(x)))
            @shipping_lane = HttpClient::Preconditions.assert_class('shipping_lane', opts.delete(:shipping_lane), String)
            @surcharge_settings = (x = opts.delete(:surcharge_settings); x.nil? ? nil : HttpClient::Preconditions.assert_class('surcharge_settings', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SurchargeSetting) ? x : ::Io::Flow::V0::Models::SurchargeSetting.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :integration => integration.value,
              :name => name,
              :message => message,
              :rules => rules.map { |o| o.to_hash },
              :services => services,
              :strategy => strategy.value,
              :visibility => visibility.value,
              :description => description,
              :direction => direction.nil? ? nil : direction.value,
              :display => display.nil? ? nil : display.to_hash,
              :shipping_lane => shipping_lane,
              :surcharge_settings => surcharge_settings.nil? ? nil : surcharge_settings.map { |o| o.to_hash }
            }
          end

        end

        class TierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'TierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # System to filter incoming quote for a shipment request based on a query and
        # output corresponding outcomes.
        class TierRule

          attr_reader :id, :position, :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :position, :query, :outcome], 'TierRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::TierRuleOutcome) ? x : ::Io::Flow::V0::Models::TierRuleOutcome.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :position => position,
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        class TierRuleForm

          attr_reader :position, :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:query, :outcome], 'TierRuleForm')
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::TierRuleOutcomeForm) ? x : ::Io::Flow::V0::Models::TierRuleOutcomeForm.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :position => position,
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        class TierRuleVersion

          attr_reader :id, :timestamp, :type, :tier_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier_rule], 'TierRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier_rule = (x = opts.delete(:tier_rule); x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier_rule => tier_rule.to_hash
            }
          end

        end

        class TierSummary

          attr_reader :id, :experience, :integration, :name, :services, :strategy, :visibility, :currency, :display, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :integration, :name, :services, :strategy, :visibility, :currency], 'TierSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x)))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', v, String) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @display = (x = opts.delete(:display); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TierDisplay) ? x : ::Io::Flow::V0::Models::TierDisplay.new(x)))
            @message = (x = opts.delete(:message); x.nil? ? nil : HttpClient::Preconditions.assert_class('message', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.nil? ? nil : experience.to_hash,
              :integration => integration.value,
              :name => name,
              :services => services,
              :strategy => strategy.value,
              :visibility => visibility.value,
              :currency => currency,
              :display => display.nil? ? nil : display.to_hash,
              :message => message
            }
          end

        end

        class TierUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :tier

          def initialize(incoming={})
            super(:discriminator => Event::Types::TIER_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :tier], 'TierUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::Tier) ? x : ::Io::Flow::V0::Models::Tier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :tier => tier.to_hash
            }
          end

        end

        class TierVersion

          attr_reader :id, :timestamp, :type, :tier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier], 'TierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierSummary) ? x : ::Io::Flow::V0::Models::TierSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier => tier.to_hash
            }
          end

        end

        # Time zone data is provided by the public IANA time zone database. See
        # http://www.iana.org/time-zones
        class Timezone

          attr_reader :name, :description, :offset

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :description, :offset], 'Timezone')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @offset = HttpClient::Preconditions.assert_class('offset', opts.delete(:offset), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Timezone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :description => description,
              :offset => offset
            }
          end

        end

        # Used to authenticate a given token.
        class TokenAuthenticationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'TokenAuthenticationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenAuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        class TokenPartnerReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'TokenPartnerReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenPartnerReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Model used to report whether or not a given token is valid
        class TokenValidation

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'TokenValidation')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenValidation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # Defines the payload of a request to validate a token, with primary goal of
        # preventing the token from being included in an HTTP GET.
        class TokenValidationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'TokenValidationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenValidationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class Tracking

          attr_reader :id, :labels, :status, :attributes, :url, :window, :order_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :labels, :status, :attributes, :url], 'Tracking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @labels = HttpClient::Preconditions.assert_class('labels', opts.delete(:labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TrackingLabel) ? x : ::Io::Flow::V0::Models::TrackingLabel.new(x)) }
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tracking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :labels => labels.map { |o| o.to_hash },
              :status => status.value,
              :attributes => attributes,
              :url => url,
              :window => window.nil? ? nil : window.to_hash,
              :order_number => order_number
            }
          end

        end

        class TrackingEvent

          attr_reader :id, :address, :status, :timestamp, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :address, :status, :timestamp], 'TrackingEvent')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEvent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :address => address.to_hash,
              :status => status.value,
              :timestamp => timestamp,
              :description => description
            }
          end

        end

        class TrackingEventForm

          attr_reader :tracking_label_id, :timestamp, :status, :description, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_label_id, :timestamp, :status], 'TrackingEventForm')
            @tracking_label_id = HttpClient::Preconditions.assert_class('tracking_label_id', opts.delete(:tracking_label_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEventForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_label_id => tracking_label_id,
              :timestamp => timestamp,
              :status => status.value,
              :description => description,
              :address => address
            }
          end

        end

        class TrackingEventSummary

          attr_reader :id, :status, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :timestamp], 'TrackingEventSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEventSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :timestamp => timestamp
            }
          end

        end

        class TrackingEventVersion

          attr_reader :id, :timestamp, :type, :tracking_event

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking_event], 'TrackingEventVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking_event = (x = opts.delete(:tracking_event); x.is_a?(::Io::Flow::V0::Models::TrackingEventSummary) ? x : ::Io::Flow::V0::Models::TrackingEventSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEventVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking_event => tracking_event.to_hash
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class TrackingForm

          attr_reader :status, :order_number, :attributes, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x)))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.nil? ? nil : status.value,
              :order_number => order_number,
              :attributes => attributes.nil? ? nil : attributes,
              :window => window.nil? ? nil : window.to_hash
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class TrackingLabel

          attr_reader :id, :carrier, :carrier_tracking_number, :events, :status, :timestamp, :delivery_estimate, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :carrier_tracking_number, :events, :status, :timestamp], 'TrackingLabel')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @events = HttpClient::Preconditions.assert_class('events', opts.delete(:events), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TrackingEvent) ? x : ::Io::Flow::V0::Models::TrackingEvent.new(x)) }
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabel.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier,
              :carrier_tracking_number => carrier_tracking_number,
              :events => events.map { |o| o.to_hash },
              :status => status.value,
              :timestamp => timestamp,
              :delivery_estimate => delivery_estimate,
              :description => description
            }
          end

        end

        class TrackingLabelEventUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :address, :carrier, :carrier_timestamp, :carrier_tracking_number, :flow_tracking_number, :status, :delivery_estimate, :description, :order_number

          def initialize(incoming={})
            super(:discriminator => Event::Types::TRACKING_LABEL_EVENT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :address, :carrier, :carrier_timestamp, :carrier_tracking_number, :flow_tracking_number, :status], 'TrackingLabelEventUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @carrier_timestamp = HttpClient::Preconditions.assert_class('carrier_timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:carrier_timestamp)), DateTime)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelEventUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :address => address.to_hash,
              :carrier => carrier,
              :carrier_timestamp => carrier_timestamp,
              :carrier_tracking_number => carrier_tracking_number,
              :flow_tracking_number => flow_tracking_number,
              :status => status,
              :delivery_estimate => delivery_estimate,
              :description => description,
              :order_number => order_number
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class TrackingLabelForm

          attr_reader :tracking_id, :status, :carrier, :carrier_tracking_number, :delivery_estimate, :description, :timestamp, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_id, :carrier, :carrier_tracking_number], 'TrackingLabelForm')
            @tracking_id = HttpClient::Preconditions.assert_class('tracking_id', opts.delete(:tracking_id), String)
            @status = (x = (x = opts.delete(:status); x.nil? ? "pending" : x); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @timestamp = (x = opts.delete(:timestamp); x.nil? ? nil : HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_id => tracking_id,
              :status => status.value,
              :carrier => carrier,
              :carrier_tracking_number => carrier_tracking_number,
              :delivery_estimate => delivery_estimate,
              :description => description,
              :timestamp => timestamp,
              :parent_id => parent_id
            }
          end

        end

        class TrackingLabelSummary

          attr_reader :id, :tracking, :status, :carrier, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number], 'TrackingLabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number
            }
          end

        end

        class TrackingLabelVersion

          attr_reader :id, :timestamp, :type, :tracking_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking_label], 'TrackingLabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking_label = (x = opts.delete(:tracking_label); x.is_a?(::Io::Flow::V0::Models::TrackingLabelSummary) ? x : ::Io::Flow::V0::Models::TrackingLabelSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking_label => tracking_label.to_hash
            }
          end

        end

        class TrackingSummary

          attr_reader :id, :status, :order_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status], 'TrackingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :order_number => order_number
            }
          end

        end

        class TrackingVersion

          attr_reader :id, :timestamp, :type, :tracking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking], 'TrackingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking => tracking.to_hash
            }
          end

        end

        class TransitEstimate

          attr_reader :origin, :destination, :min_date, :max_date, :source

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:origin, :destination, :min_date, :max_date, :source], 'TransitEstimate')
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowLocation) ? x : ::Io::Flow::V0::Models::DeliveryWindowLocation.apply(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowLocation) ? x : ::Io::Flow::V0::Models::DeliveryWindowLocation.apply(x))
            @min_date = HttpClient::Preconditions.assert_class('min_date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:min_date)), DateTime)
            @max_date = HttpClient::Preconditions.assert_class('max_date', HttpClient::Helper.to_date_time_iso8601(opts.delete(:max_date)), DateTime)
            @source = (x = opts.delete(:source); x.is_a?(::Io::Flow::V0::Models::DeliveryWindowComponentSource) ? x : ::Io::Flow::V0::Models::DeliveryWindowComponentSource.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TransitEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin => origin.value,
              :destination => destination.value,
              :min_date => min_date,
              :max_date => max_date,
              :source => source.value
            }
          end

        end

        class TransitWindow

          attr_reader :origin_country, :destination_country, :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:origin_country, :destination_country, :from, :to], 'TransitWindow')
            @origin_country = HttpClient::Preconditions.assert_class('origin_country', opts.delete(:origin_country), String)
            @destination_country = HttpClient::Preconditions.assert_class('destination_country', opts.delete(:destination_country), String)
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TransitWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin_country => origin_country,
              :destination_country => destination_country,
              :from => from,
              :to => to
            }
          end

        end

        # Export for items that require harmonization.
        class UnharmonizedItemExportType < ExportType

          attr_reader :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::UNHARMONIZED_ITEM_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UnharmonizedItemExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :sort => sort
            }
          end

        end

        # Provides the ability to upload a file to a URL (an expiring s3 url, usually
        # valid for 1 week)
        class Upload

          attr_reader :id, :name, :url, :expiration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :url, :expiration], 'Upload')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expiration)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Upload.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :url => url,
              :expiration => expiration
            }
          end

        end

        # Represents a single user in the system
        class User < ExpandableUser

          attr_reader :id, :email, :name, :status

          def initialize(incoming={})
            super(:discriminator => ExpandableUser::Types::USER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'User')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @status = (x = (x = opts.delete(:status); x.nil? ? "active" : x); x.is_a?(::Io::Flow::V0::Models::UserStatus) ? x : ::Io::Flow::V0::Models::UserStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            User.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :email => email,
              :name => name.to_hash,
              :status => status.value
            }
          end

        end

        class UserForm

          attr_reader :email, :password, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @password = (x = opts.delete(:password); x.nil? ? nil : HttpClient::Preconditions.assert_class('password', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserPutForm

          attr_reader :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserReference < ExpandableUser

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandableUser::Types::USER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'UserReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class UserVersion

          attr_reader :id, :timestamp, :type, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :user], 'UserVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::User) ? x : ::Io::Flow::V0::Models::User.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :user => user.to_hash
            }
          end

        end

        class ValueThresholdExceededDetails

          attr_reader :local, :original

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:local, :original], 'ValueThresholdExceededDetails')
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @original = (x = opts.delete(:original); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ValueThresholdExceededDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :local => local.to_hash,
              :original => original.to_hash
            }
          end

        end

        # Virtual credit cards are created for a specific limit and currency. Currently
        # only USD denominated cards can be issued. Once created the virtual card can be
        # used in the same way as a physical credit card using the card number, cvv and
        # expiration details.
        class VirtualCard

          attr_reader :id, :key, :number, :cvv, :limit, :type, :expiration, :iin, :last4, :name, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :limit, :type, :expiration, :iin, :last4, :name], 'VirtualCard')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @limit = (x = opts.delete(:limit); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CardType) ? x : ::Io::Flow::V0::Models::CardType.apply(x))
            @expiration = (x = opts.delete(:expiration); x.is_a?(::Io::Flow::V0::Models::Expiration) ? x : ::Io::Flow::V0::Models::Expiration.new(x))
            @iin = HttpClient::Preconditions.assert_class('iin', opts.delete(:iin), String)
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCard.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :number => number,
              :cvv => cvv,
              :limit => limit.to_hash,
              :type => type.value,
              :expiration => expiration.to_hash,
              :iin => iin,
              :last4 => last4,
              :name => name,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # Payment has been captured for the virtual credit card
        class VirtualCardCapture

          attr_reader :id, :issuer, :virtual_card, :authorization, :amount, :currency, :created_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :issuer, :virtual_card, :authorization, :amount, :currency, :created_at], 'VirtualCardCapture')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @issuer = (x = opts.delete(:issuer); x.is_a?(::Io::Flow::V0::Models::IssuerV1) ? x : ::Io::Flow::V0::Models::IssuerV1.new(x))
            @virtual_card = (x = opts.delete(:virtual_card); x.is_a?(::Io::Flow::V0::Models::VirtualCardReference) ? x : ::Io::Flow::V0::Models::VirtualCardReference.new(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardCapture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :issuer => issuer.to_hash,
              :virtual_card => virtual_card.to_hash,
              :authorization => authorization.to_hash,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :created_at => created_at
            }
          end

        end

        # Event emitted when a previous virtual card capture has been deleted.
        class VirtualCardCaptureDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::VIRTUAL_CARD_CAPTURE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'VirtualCardCaptureDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardCaptureDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Emitted when a capture event occurs against an existing virtual credit card.
        class VirtualCardCaptureUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :capture

          def initialize(incoming={})
            super(:discriminator => Event::Types::VIRTUAL_CARD_CAPTURE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :capture], 'VirtualCardCaptureUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::VirtualCardCapture) ? x : ::Io::Flow::V0::Models::VirtualCardCapture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardCaptureUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :capture => capture.to_hash
            }
          end

        end

        class VirtualCardCaptureVersion

          attr_reader :id, :timestamp, :type, :virtual_card_capture

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :virtual_card_capture], 'VirtualCardCaptureVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @virtual_card_capture = (x = opts.delete(:virtual_card_capture); x.is_a?(::Io::Flow::V0::Models::VirtualCardCapture) ? x : ::Io::Flow::V0::Models::VirtualCardCapture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardCaptureVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :virtual_card_capture => virtual_card_capture.to_hash
            }
          end

        end

        class VirtualCardForm

          attr_reader :limit, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:limit], 'VirtualCardForm')
            @limit = (x = opts.delete(:limit); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :limit => limit.to_hash,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # Flows reference identifier for the virtual credit card.
        class VirtualCardReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'VirtualCardReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # A refund has been issued for the virtual credit card
        class VirtualCardRefund

          attr_reader :id, :issuer, :virtual_card, :authorization, :amount, :currency, :created_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :issuer, :virtual_card, :authorization, :amount, :currency, :created_at], 'VirtualCardRefund')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @issuer = (x = opts.delete(:issuer); x.is_a?(::Io::Flow::V0::Models::IssuerV1) ? x : ::Io::Flow::V0::Models::IssuerV1.new(x))
            @virtual_card = (x = opts.delete(:virtual_card); x.is_a?(::Io::Flow::V0::Models::VirtualCardReference) ? x : ::Io::Flow::V0::Models::VirtualCardReference.new(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardRefund.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :issuer => issuer.to_hash,
              :virtual_card => virtual_card.to_hash,
              :authorization => authorization.to_hash,
              :amount => amount.to_f.to_s,
              :currency => currency,
              :created_at => created_at
            }
          end

        end

        # Event emitted when a previous virtual card refund has been deleted.
        class VirtualCardRefundDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::VIRTUAL_CARD_REFUND_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'VirtualCardRefundDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardRefundDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Emitted when a refund event occurs against an existing virtual credit card.
        class VirtualCardRefundUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :refund

          def initialize(incoming={})
            super(:discriminator => Event::Types::VIRTUAL_CARD_REFUND_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :refund], 'VirtualCardRefundUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::VirtualCardRefund) ? x : ::Io::Flow::V0::Models::VirtualCardRefund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardRefundUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :refund => refund.to_hash
            }
          end

        end

        class VirtualCardRefundVersion

          attr_reader :id, :timestamp, :type, :virtual_card_refund

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :virtual_card_refund], 'VirtualCardRefundVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @virtual_card_refund = (x = opts.delete(:virtual_card_refund); x.is_a?(::Io::Flow::V0::Models::VirtualCardRefund) ? x : ::Io::Flow::V0::Models::VirtualCardRefund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardRefundVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :virtual_card_refund => virtual_card_refund.to_hash
            }
          end

        end

        class VirtualCardVersion

          attr_reader :id, :timestamp, :type, :virtual_card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :virtual_card], 'VirtualCardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @virtual_card = (x = opts.delete(:virtual_card); x.is_a?(::Io::Flow::V0::Models::VirtualCard) ? x : ::Io::Flow::V0::Models::VirtualCard.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            VirtualCardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :virtual_card => virtual_card.to_hash
            }
          end

        end

        class Webhook

          attr_reader :id, :url, :events

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :url, :events], 'Webhook')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @events = HttpClient::Preconditions.assert_class('events', opts.delete(:events), Array).map { |v| HttpClient::Preconditions.assert_class('events', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Webhook.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :url => url,
              :events => events
            }
          end

        end

        # A webhook delivery represents an event that matched a webhook's event types.
        # Each delivery will be attempted one or more times subject to the settings of
        # your webhook.
        class WebhookDelivery

          attr_reader :id, :webhook, :status, :created_at, :latest, :next_attempt_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :webhook, :status, :created_at], 'WebhookDelivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @webhook = (x = opts.delete(:webhook); x.is_a?(::Io::Flow::V0::Models::WebhookReference) ? x : ::Io::Flow::V0::Models::WebhookReference.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::WebhookStatus) ? x : ::Io::Flow::V0::Models::WebhookStatus.apply(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @latest = (x = opts.delete(:latest); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::WebhookRequest) ? x : ::Io::Flow::V0::Models::WebhookRequest.new(x)))
            @next_attempt_at = (x = opts.delete(:next_attempt_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('next_attempt_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookDelivery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :webhook => webhook.to_hash,
              :status => status.value,
              :created_at => created_at,
              :latest => latest.nil? ? nil : latest.to_hash,
              :next_attempt_at => next_attempt_at
            }
          end

        end

        class WebhookForm

          attr_reader :url, :events

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url, :events], 'WebhookForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @events = HttpClient::Preconditions.assert_class('events', opts.delete(:events), Array).map { |v| HttpClient::Preconditions.assert_class('events', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :events => events
            }
          end

        end

        class WebhookReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'WebhookReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class WebhookRequest

          attr_reader :id, :headers, :method, :body, :status, :started_at, :completed_at, :duration_ms, :response, :error

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :headers, :method, :body, :status], 'WebhookRequest')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @headers = HttpClient::Preconditions.assert_class('headers', opts.delete(:headers), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Header) ? x : ::Io::Flow::V0::Models::Header.new(x)) }
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::Method) ? x : ::Io::Flow::V0::Models::Method.apply(x))
            @body = HttpClient::Preconditions.assert_class('body', opts.delete(:body), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::WebhookStatus) ? x : ::Io::Flow::V0::Models::WebhookStatus.apply(x))
            @started_at = (x = opts.delete(:started_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('started_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @completed_at = (x = opts.delete(:completed_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('completed_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @duration_ms = (x = opts.delete(:duration_ms); x.nil? ? nil : HttpClient::Preconditions.assert_class('duration_ms', x, Integer))
            @response = (x = opts.delete(:response); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::WebhookResponse) ? x : ::Io::Flow::V0::Models::WebhookResponse.new(x)))
            @error = (x = opts.delete(:error); x.nil? ? nil : HttpClient::Preconditions.assert_class('error', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookRequest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :headers => headers.map { |o| o.to_hash },
              :method => method.value,
              :body => body,
              :status => status.value,
              :started_at => started_at,
              :completed_at => completed_at,
              :duration_ms => duration_ms,
              :response => response.nil? ? nil : response.to_hash,
              :error => error
            }
          end

        end

        class WebhookRequestReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'WebhookRequestReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookRequestReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class WebhookResponse

          attr_reader :id, :request, :headers, :body, :body_url, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :request, :headers, :body, :status], 'WebhookResponse')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @request = (x = opts.delete(:request); x.is_a?(::Io::Flow::V0::Models::WebhookRequestReference) ? x : ::Io::Flow::V0::Models::WebhookRequestReference.new(x))
            @headers = HttpClient::Preconditions.assert_class('headers', opts.delete(:headers), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Header) ? x : ::Io::Flow::V0::Models::Header.new(x)) }
            @body = HttpClient::Preconditions.assert_class('body', opts.delete(:body), String)
            @body_url = (x = opts.delete(:body_url); x.nil? ? nil : HttpClient::Preconditions.assert_class('body_url', x, String))
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookResponse.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :request => request.to_hash,
              :headers => headers.map { |o| o.to_hash },
              :body => body,
              :body_url => body_url,
              :status => status
            }
          end

        end

        # Sets organization level settings to determine things like how many retries on
        # delivery, how long we wait, etc. By default, we will attempt delivery up to 6
        # times, using exponential backoff with a see of 1 minute (60k ms) - which means
        # that we will retry over the course of approximately an hour before giving up.
        class WebhookSettings

          attr_reader :secret, :retry_max_attempts, :retry_sleep_ms, :sleep_ms

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @secret = (x = opts.delete(:secret); x.nil? ? nil : HttpClient::Preconditions.assert_class('secret', x, String))
            @retry_max_attempts = HttpClient::Preconditions.assert_class('retry_max_attempts', (x = opts.delete(:retry_max_attempts); x.nil? ? 6 : x), Integer)
            @retry_sleep_ms = HttpClient::Preconditions.assert_class('retry_sleep_ms', (x = opts.delete(:retry_sleep_ms); x.nil? ? 60000 : x), Integer)
            @sleep_ms = HttpClient::Preconditions.assert_class('sleep_ms', (x = opts.delete(:sleep_ms); x.nil? ? 0 : x), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :secret => secret,
              :retry_max_attempts => retry_max_attempts,
              :retry_sleep_ms => retry_sleep_ms,
              :sleep_ms => sleep_ms
            }
          end

        end

        class Zone

          attr_reader :postals, :provinces, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country], 'Zone')
            @postals = (x = opts.delete(:postals); x.nil? ? nil : HttpClient::Preconditions.assert_class('postals', x, Array).map { |v| HttpClient::Preconditions.assert_class('postals', v, String) })
            @provinces = (x = opts.delete(:provinces); x.nil? ? nil : HttpClient::Preconditions.assert_class('provinces', x, Array).map { |v| HttpClient::Preconditions.assert_class('provinces', v, String) })
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Zone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :postals => postals.nil? ? nil : postals,
              :provinces => provinces.nil? ? nil : provinces,
              :country => country
            }
          end

        end

      end

      # ===== END OF SERVICE DEFINITION =====
      module HttpClient

        class HttpHandler

          # Returns a client instance to use
          #
          # @param base_uri The base URI for this API
          # @param path the Requested full http path (including any query strings)
          def instance(base_uri, path)
            raise "Override in subclass"
          end

        end

        class HttpHandlerInstance

          # Executes a request. The provided request object will be an
          # instance of Net::HTTP (e.g. Net::HTTP::Get)
          def execute(request)
            raise "Override in subclass"
          end

        end

        class DefaultHttpHandler < HttpHandler

          def instance(base_uri, path)
            DefaultHttpHandlerInstance.new(base_uri)
          end

        end

        class DefaultHttpHandlerInstance < HttpHandlerInstance

          attr_reader :client

          def initialize(base_uri)
            @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
            @client = Net::HTTP.new(@base_uri.host, @base_uri.port)
            if @base_uri.scheme == "https"
              configure_ssl
            end
          end

          def execute(request)
            response = begin
                         @client.request(request)
                       rescue SocketError => e
                         raise StandardError.new("Error accessing uri[#{full_uri(request.path)}]: #{e}")
                       end

            case response
            when Net::HTTPSuccess
              response.body
            else
              body = response.body rescue nil
              raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => full_uri(request.path).to_s)
            end
          end

          def full_uri(path)
            path.start_with?(@base_uri.to_s) ? path : File.join(@base_uri.to_s, path)
          end

          # Called to configure SSL if the base uri requires it
          def configure_ssl
            @client.use_ssl = true
            @client.verify_mode = OpenSSL::SSL::VERIFY_PEER
            @client.cert_store = OpenSSL::X509::Store.new
            @client.cert_store.set_default_paths
          end

        end

        class Request

          attr_reader :base_uri, :path, :full_uri

          def initialize(http_handler, base_uri, path)
            @http_handler = http_handler
            @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
            @path = Preconditions.assert_class('path', path, String)
            @full_uri = @base_uri.to_s + @path
            @params = nil
            @body = nil
            @auth = nil
            @headers = {}
            @header_keys_lower_case = []
          end

          def with_header(name, value)
            Preconditions.check_not_blank('name', name, "Header name is required")
            Preconditions.check_not_blank('value', value, "Header value is required")
            Preconditions.check_state(!@headers.has_key?(name),
                                      "Duplicate header named[%s]" % name)
            @headers[name] = value
            @header_keys_lower_case << name.downcase
            self
          end

          def with_auth(auth)
            Preconditions.assert_class('auth', auth, HttpClient::Authorization)
            Preconditions.check_state(@auth.nil?, "auth previously set")

            if auth.scheme.name == AuthScheme::BASIC.name
              @auth = auth
            else
              raise "Auth Scheme[#{auth.scheme.name}] not supported"
            end
            self
          end

          def with_query(params)
            Preconditions.assert_class('params', params, Hash)
            Preconditions.check_state(@params.nil?, "Already have query parameters")
            @params = params
            self
          end

          # Wrapper to set Content-Type header to application/json and set
          # the provided json document as the body
          def with_json(json)
            @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
            with_body(json)
          end

          def with_body(body)
            Preconditions.check_not_blank('body', body)
            @body = body
            self
          end

          def get(&block)
            do_request(Net::HTTP::Get, &block)
          end

          def delete(&block)
            do_request(Net::HTTP::Delete, &block)
          end

          def options(&block)
            do_request(Net::HTTP::Options, &block)
          end

          def post(&block)
            do_request(Net::HTTP::Post, &block)
          end

          def put(&block)
            do_request(Net::HTTP::Put, &block)
          end

          class PATCH < Net::HTTP::Put
            METHOD = "PATCH"
          end

          def patch(&block)
            do_request(PATCH, &block)
          end

          def do_request(klass)
            Preconditions.assert_class('klass', klass, Class)

            uri = @full_uri.dup
            if q = to_query(@params)
              uri += "?%s" % q
            end

            request = klass.send(:new, uri)

            # DEBUG curl = ['curl']
            # DEBUG if klass != Net::HTTP::Get
            # DEBUG  curl << "-X%s" % klass.name.split("::").last.upcase
            # DEBUG end

            if @body
              # DEBUG tmpfile = "/tmp/rest_client.tmp"
              # DEBUG File.open(tmpfile, "w") { |os| os << @body.to_s }
              # DEBUG curl << "-d@%s" % tmpfile
              request.body = @body
            end

            if @auth
              # DEBUG curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
              Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                        "Cannot specify both an Authorization header and an auth instance")
              user_pass = "%s:%s" % [@auth.username, @auth.password]
              encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
              request.add_field("Authorization", "Basic %s" % encoded)
            end

            @headers.each { |key, value|
              # DEBUG curl <<  "-H \"%s: %s\"" % [key, value]
              request.add_field(key, value)
            }

            # DEBUG curl << "'%s%s'" % [@base_uri, path]
            # DEBUG puts curl.join(" ")

            raw_response = @http_handler.instance(@base_uri, request.path).execute(request)
            response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

            if block_given?
              yield response
            else
              response
            end
          end

          private
          def to_query(params={})
            parts = (params || {}).map { |k,v|
              if v.is_a?(Enumerable)
                v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
              else
                "%s=%s" % [k, CGI.escape(v.to_s)]
              end
            }
            parts.empty? ? nil : parts.join("&")
          end

        end

        class ServerError < StandardError

          attr_reader :code, :details, :body, :uri

          def initialize(code, details, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @code = HttpClient::Preconditions.assert_class('code', code, Integer)
            @details = HttpClient::Preconditions.assert_class('details', details, String)
            @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
            @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
            super(self.message)
          end

          def message
            m = "%s %s" % [@code, @details]
            if @body
              m << ": %s" % @body
            end
            m
          end

          def body_json
            @body ? JSON.parse(@body) : nil
          end

        end

        class PreconditionException < StandardError

          attr_reader :message

          def initialize(message)
            super(message)
            @message = message
          end

        end

        module Preconditions

          def Preconditions.check_argument(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_argument failed")
            end
            nil
          end

          def Preconditions.check_state(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_state failed")
            end
            nil
          end

          def Preconditions.check_not_nil(field_name, reference, error_message=nil)
            if reference.nil?
              raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
            end
            reference
          end

          def Preconditions.check_not_blank(field_name, reference, error_message=nil)
            if reference.to_s.strip == ""
              raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
            end
            reference
          end

          # Throws an error if opts is not empty. Useful when parsing
          # arguments to a function
          def Preconditions.assert_empty_opts(opts)
            if !opts.empty?
              raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
            end
          end

          # Requires that the provided hash has the specified keys.
          # @param fields A list of symbols
          def Preconditions.require_keys(hash, fields, error_prefix=nil)
            missing = fields.select { |f| !hash.has_key?(f) }
            if !missing.empty?
              msg = "Missing required fields: " + missing.join(", ")
              raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
            end
          end

          # Asserts that value is not nill and is_?(klass). Returns
          # value. Common use is
          #
          # amount = Preconditions.assert_class('amount', amount, BigDecimal)
          def Preconditions.assert_class(field_name, value, klass)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('klass', klass)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
            Preconditions.check_state(value.is_a?(klass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_class_or_nil(field_name, value, klass)
            if !value.nil?
              Preconditions.assert_class(field_name, value, klass)
            end
          end

          def Preconditions.assert_boolean(field_name, value)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
            Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_boolean_or_nil(field_name, value)
            if !value.nil?
              Preconditions.assert_boolean(field_name, value)
            end
          end

          def Preconditions.assert_collection_of_class(field_name, values, klass)
            Preconditions.assert_class(field_name, values, Array)
            values.each { |v| Preconditions.assert_class(field_name, v, klass) }
          end

          def Preconditions.assert_hash_of_class(field_name, hash, klass)
            Preconditions.assert_class(field_name, hash, Hash)
            values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
          end

        end

        class AuthScheme

          attr_reader :name

          def initialize(name)
            @name = HttpClient::Preconditions.check_not_blank('name', name)
          end

          BASIC = AuthScheme.new("basic") unless defined?(BASIC)

        end

        class Authorization

          attr_reader :scheme, :username, :password

          def initialize(scheme, username, opts={})
            @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
            @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
            @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
          end

          def Authorization.basic(username, password=nil)
            Authorization.new(AuthScheme::BASIC, username, :password => password)
          end

        end

        module Helper

          def Helper.symbolize_keys(hash)
            Preconditions.assert_class('hash', hash, Hash)
            new_hash = {}
            hash.each { |k, v|
              new_hash[k.to_sym] = v
            }
            new_hash
          end

          def Helper.to_big_decimal(value)
            value ? BigDecimal.new(value.to_s) : nil
          end

          def Helper.to_object(value)
            value ? (value.is_a?(Hash) ? value : JSON.parse(value)) : nil
          end

          def Helper.to_uuid(value)
            Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                      "Invalid guid[%s]" % value)
            value
          end

          def Helper.to_date_iso8601(value)
            if value.is_a?(Date)
              value
            elsif value
              Date.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.to_date_time_iso8601(value)
            if value.is_a?(DateTime)
              value
            elsif value
              DateTime.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.date_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%d')
          end

          def Helper.date_time_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
          end

          TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
          FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

          def Helper.to_boolean(field_name, value)
            string = value.to_s.strip.downcase
            if TRUE_STRINGS.include?(string)
              true
            elsif FALSE_STRINGS.include?(string)
              false
            elsif string != ""
              raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
            else
              nil
            end
          end

        end

      end
    end
  end
end