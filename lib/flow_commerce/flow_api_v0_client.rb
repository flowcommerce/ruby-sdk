# Generated by apidoc - http://www.apidoc.me
# Service version: 0.0.44
# apidoc:0.11.32 http://www.apidoc.me/flow/api/0.0.44/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

# The Flow Commerce REST API provides full access to the global ecommerce
# platform.
module Io
  module Flow
    module V0

      class Client

        module Constants

          BASE_URL = 'https://api.flow.io' unless defined?(Constants::BASE_URL)
          NAMESPACE = 'io.flow.v0' unless defined?(Constants::NAMESPACE)
          USER_AGENT = 'apidoc:0.11.32 http://www.apidoc.me/flow/api/0.0.44/ruby_client' unless defined?(Constants::USER_AGENT)
          VERSION = '0.0.44' unless defined?(Constants::VERSION)
          VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

        end

        attr_reader :url

        def initialize(url, opts={})
          @url = HttpClient::Preconditions.assert_class('url', url, String)
          @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
          @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
          HttpClient::Preconditions.assert_empty_opts(opts)
          HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
        end

        # Creates an instance of the client using the base url specified in the API spec.
        def Client.at_base_url(opts={})
          Client.new(Constants::BASE_URL, opts)
        end

        def request(path=nil)
          HttpClient::Preconditions.assert_class_or_nil('path', path, String)
          request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

          @default_headers.each do |key, value|
            request = request.with_header(key, value)
          end

          if @authorization
            request = request.with_auth(@authorization)
          end

          request
        end

        def attributes
          @attributes ||= ::Io::Flow::V0::Clients::Attributes.new(self)
        end

        def catalogs
          @catalogs ||= ::Io::Flow::V0::Clients::Catalogs.new(self)
        end

        def experiences
          @experiences ||= ::Io::Flow::V0::Clients::Experiences.new(self)
        end

        def items
          @items ||= ::Io::Flow::V0::Clients::Items.new(self)
        end

        def subcatalogs
          @subcatalogs ||= ::Io::Flow::V0::Clients::Subcatalogs.new(self)
        end

        def subcatalog_items
          @subcatalog_items ||= ::Io::Flow::V0::Clients::SubcatalogItems.new(self)
        end

        def displays
          @displays ||= ::Io::Flow::V0::Clients::Displays.new(self)
        end

        def functions
          @functions ||= ::Io::Flow::V0::Clients::Functions.new(self)
        end

        def duties
          @duties ||= ::Io::Flow::V0::Clients::Duties.new(self)
        end

        def harmonization_settings
          @harmonization_settings ||= ::Io::Flow::V0::Clients::HarmonizationSettings.new(self)
        end

        def harmonized_items
          @harmonized_items ||= ::Io::Flow::V0::Clients::HarmonizedItems.new(self)
        end

        def harmonized_item_duties
          @harmonized_item_duties ||= ::Io::Flow::V0::Clients::HarmonizedItemDuties.new(self)
        end

        def hs10
          @hs10 ||= ::Io::Flow::V0::Clients::Hs10.new(self)
        end

        def hs6
          @hs6 ||= ::Io::Flow::V0::Clients::Hs6.new(self)
        end

        def taxes
          @taxes ||= ::Io::Flow::V0::Clients::Taxes.new(self)
        end

        def authorizations
          @authorizations ||= ::Io::Flow::V0::Clients::Authorizations.new(self)
        end

        def captures
          @captures ||= ::Io::Flow::V0::Clients::Captures.new(self)
        end

        def cards
          @cards ||= ::Io::Flow::V0::Clients::Cards.new(self)
        end

        def refunds
          @refunds ||= ::Io::Flow::V0::Clients::Refunds.new(self)
        end

        def bookings
          @bookings ||= ::Io::Flow::V0::Clients::Bookings.new(self)
        end

        def carriers
          @carriers ||= ::Io::Flow::V0::Clients::Carriers.new(self)
        end

        def carrier_accounts
          @carrier_accounts ||= ::Io::Flow::V0::Clients::CarrierAccounts.new(self)
        end

        def centers
          @centers ||= ::Io::Flow::V0::Clients::Centers.new(self)
        end

        def delivery_windows
          @delivery_windows ||= ::Io::Flow::V0::Clients::DeliveryWindows.new(self)
        end

        def events
          @events ||= ::Io::Flow::V0::Clients::Events.new(self)
        end

        def labels
          @labels ||= ::Io::Flow::V0::Clients::Labels.new(self)
        end

        def lanes
          @lanes ||= ::Io::Flow::V0::Clients::Lanes.new(self)
        end

        def quotes
          @quotes ||= ::Io::Flow::V0::Clients::Quotes.new(self)
        end

        def services
          @services ||= ::Io::Flow::V0::Clients::Services.new(self)
        end

        def shipments
          @shipments ||= ::Io::Flow::V0::Clients::Shipments.new(self)
        end

        def shipment_labels
          @shipment_labels ||= ::Io::Flow::V0::Clients::ShipmentLabels.new(self)
        end

        def tiers
          @tiers ||= ::Io::Flow::V0::Clients::Tiers.new(self)
        end

        def trackings
          @trackings ||= ::Io::Flow::V0::Clients::Trackings.new(self)
        end

        def countries
          @countries ||= ::Io::Flow::V0::Clients::Countries.new(self)
        end

        def currencies
          @currencies ||= ::Io::Flow::V0::Clients::Currencies.new(self)
        end

        def languages
          @languages ||= ::Io::Flow::V0::Clients::Languages.new(self)
        end

        def timezones
          @timezones ||= ::Io::Flow::V0::Clients::Timezones.new(self)
        end

        def documents
          @documents ||= ::Io::Flow::V0::Clients::Documents.new(self)
        end

        def email_verifications
          @email_verifications ||= ::Io::Flow::V0::Clients::EmailVerifications.new(self)
        end

        def healthchecks
          @healthchecks ||= ::Io::Flow::V0::Clients::Healthchecks.new(self)
        end

        def invitations
          @invitations ||= ::Io::Flow::V0::Clients::Invitations.new(self)
        end

        def locations
          @locations ||= ::Io::Flow::V0::Clients::Locations.new(self)
        end

        def memberships
          @memberships ||= ::Io::Flow::V0::Clients::Memberships.new(self)
        end

        def organizations
          @organizations ||= ::Io::Flow::V0::Clients::Organizations.new(self)
        end

        def password_reset_forms
          @password_reset_forms ||= ::Io::Flow::V0::Clients::PasswordResetForms.new(self)
        end

        def suggestions
          @suggestions ||= ::Io::Flow::V0::Clients::Suggestions.new(self)
        end

        def tokens
          @tokens ||= ::Io::Flow::V0::Clients::Tokens.new(self)
        end

        def users
          @users ||= ::Io::Flow::V0::Clients::Users.new(self)
        end

        def validations
          @validations ||= ::Io::Flow::V0::Clients::Validations.new(self)
        end
      end

      module Clients

        class Attributes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search metadata. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :option => (x = opts.delete(:option); x.nil? ? nil : HttpClient::Preconditions.assert_class('option', x, Array).map { |v| HttpClient::Preconditions.assert_class('option', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Attribute.new(x) }
          end

          # Add attribute
          def post(organization, attribute)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('attribute', attribute, ::Io::Flow::V0::Models::Attribute)
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_json(attribute.to_json).post
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Returns information about a specific attribute.
          def get_by_name(organization, name)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('name', name, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(name)}").get
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Update an attribute with the specified name, creating if it does not exist.
          def put_by_name(organization, name, attribute)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('name', name, String)
            HttpClient::Preconditions.assert_class('attribute', attribute, ::Io::Flow::V0::Models::Attribute)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(name)}").with_json(attribute.to_json).put
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Delete an attribute with this name
          def delete_by_name(organization, name)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('name', name, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(name)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AttributeVersion.new(x) }
          end

        end

        class Catalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns information about a specific catalog.
          def get_catalog(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog").get
            ::Io::Flow::V0::Models::Catalog.new(r)
          end

        end

        class Experiences

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search experiences. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, Array).map { |v| HttpClient::Preconditions.assert_class('country', v, String) }),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, Array).map { |v| HttpClient::Preconditions.assert_class('currency', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :subcatalog => (x = opts.delete(:subcatalog); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog', x, Array).map { |v| HttpClient::Preconditions.assert_class('subcatalog', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Experience.new(x) }
          end

          # Add experience
          def post(organization, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_json(experience_form.to_json).post
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Returns information about a specific experience.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Update experience with the specified key, creating if it does not exist.
          def put_by_key(organization, key, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").with_json(experience_form.to_json).put
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Delete the experience with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").delete
            nil
          end

          # Checkout, aggregate items and prices.
          def post_checkout(organization, checkout_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('checkout_form', checkout_form, ::Io::Flow::V0::Models::CheckoutForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/checkout").with_json(checkout_form.to_json).post
            ::Io::Flow::V0::Models::Checkout.new(r)
          end

          # Compose items and prices. Always paginated.
          def get_items(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :from_country => (x = opts.delete(:from_country); x.nil? ? nil : HttpClient::Preconditions.assert_class('from_country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExperienceVersion.new(x) }
          end

        end

        class Items

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search items. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :query => (x = opts.delete(:query); x.nil? ? nil : HttpClient::Preconditions.assert_class('query', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Add catalog item(s)
          def post(organization, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_json(item_form.to_json).post
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Returns information about a specific item.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update item with the specified number, creating if it does not exist.
          def put_by_number(organization, number, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").with_json(item_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the item with this number
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemVersion.new(x) }
          end

        end

        class Subcatalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalogs. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Subcatalog.new(x) }
          end

          # Add subcatalog
          def post(organization, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_json(subcatalog_form.to_json).post
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Returns information about a specific subcatalog.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Update subcatalog with the specified key, creating if it does not exist.
          def put_by_key(organization, key, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(key)}").with_json(subcatalog_form.to_json).put
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Delete the subcatalog with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(key)}").delete
            nil
          end

          # Sync subcatalog
          def post_events_by_key_and_event(organization, key, event, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('event', event, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(key)}/events/#{CGI.escape(event)}").with_json(hash.to_json).post
            nil
          end

          # Returns information about a specific subcatalog's settings.
          def get_settings_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(key)}/settings").get
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Update subcatalog settings for the specified subcatalog.
          def put_settings_by_key(organization, key, subcatalog_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('subcatalog_settings_form', subcatalog_settings_form, ::Io::Flow::V0::Models::SubcatalogSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(key)}/settings").with_json(subcatalog_settings_form.to_json).put
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

        end

        class SubcatalogItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalog items. Always paginated.
          def get(organization, subcatalog, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog', subcatalog, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :query => (x = opts.delete(:query); x.nil? ? nil : HttpClient::Preconditions.assert_class('query', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog)}/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Add subcatalog item
          def post(organization, subcatalog, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog', subcatalog, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog)}/items").with_json(item_form.to_json).post
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Returns information about specific subcatalog items.
          def get_by_number(organization, subcatalog, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog', subcatalog, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog)}/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update subcatalog item with the specified number, creating if it does not
          # exist.
          def put_by_number(organization, subcatalog, number, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog', subcatalog, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog)}/items/#{CGI.escape(number)}").with_json(item_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the subcatalog item with this number
          def delete_by_number(organization, subcatalog, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog', subcatalog, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog)}/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, subcatalog, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog', subcatalog, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog)}/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

        end

        class Displays

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search displays. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/displays").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Display.new(x) }
          end

          # Add display
          def post(organization, display_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('display_form', display_form, ::Io::Flow::V0::Models::DisplayForm)
            r = @client.request("/#{CGI.escape(organization)}/displays").with_json(display_form.to_json).post
            ::Io::Flow::V0::Models::Display.new(r)
          end

          # Returns information about a specific display.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/displays/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Display.new(r)
          end

          # Update display with the specified key, creating if it does not exist.
          def put_by_key(organization, key, display_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('display_form', display_form, ::Io::Flow::V0::Models::DisplayForm)
            r = @client.request("/#{CGI.escape(organization)}/displays/#{CGI.escape(key)}").with_json(display_form.to_json).put
            ::Io::Flow::V0::Models::Display.new(r)
          end

          # Delete the display with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/displays/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/displays/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::DisplayVersion.new(x) }
          end

        end

        class Functions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search functions. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :position => (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Array).map { |v| HttpClient::Preconditions.assert_class('position', v, Integer) }),
              :subcatalog => (x = opts.delete(:subcatalog); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog', x, Array).map { |v| HttpClient::Preconditions.assert_class('subcatalog', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/functions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Function.new(x) }
          end

          # Add function
          def post(organization, function_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('function_form', function_form, ::Io::Flow::V0::Models::FunctionForm)
            r = @client.request("/#{CGI.escape(organization)}/functions").with_json(function_form.to_json).post
            ::Io::Flow::V0::Models::Function.new(r)
          end

          # Returns information about a specific function.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/functions/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Function.new(r)
          end

          # Update function with the specified key, creating if it does not exist.
          def put_by_key(organization, key, function_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('function_form', function_form, ::Io::Flow::V0::Models::FunctionForm)
            r = @client.request("/#{CGI.escape(organization)}/functions/#{CGI.escape(key)}").with_json(function_form.to_json).put
            ::Io::Flow::V0::Models::Function.new(r)
          end

          # Delete the function with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/functions/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/functions/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::FunctionVersion.new(x) }
          end

        end

        class Duties

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, origin, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('origin', origin, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => HttpClient::Preconditions.assert_class('number', opts.delete(:number), String),
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/duties/#{CGI.escape(origin)}").with_query(query).get
            ::Io::Flow::V0::Models::Duty.new(r)
          end

        end

        class HarmonizationSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").get
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

          def put(organization, harmonization_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonization_settings_form', harmonization_settings_form, ::Io::Flow::V0::Models::HarmonizationSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").with_json(harmonization_settings_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

        end

        class HarmonizedItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItem.new(x) }
          end

          def post(organization, harmonized_item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_form', harmonized_item_form, ::Io::Flow::V0::Models::HarmonizedItemForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_json(harmonized_item_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          # Create or update an item to harmonize
          def put_by_number(organization, number, harmonized_item_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('harmonized_item_put_form', harmonized_item_put_form, ::Io::Flow::V0::Models::HarmonizedItemPutForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").with_json(harmonized_item_put_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_id => (x = opts.delete(:item_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemVersion.new(x) }
          end

        end

        class HarmonizedItemDuties

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x) }
          end

          def post(organization, harmonized_item_duty_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_duty_form', harmonized_item_duty_form, ::Io::Flow::V0::Models::HarmonizedItemDutyForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_json(harmonized_item_duty_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :harmonized_item_duty_id => (x = opts.delete(:harmonized_item_duty_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('harmonized_item_duty_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('harmonized_item_duty_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDutyVersion.new(x) }
          end

        end

        class Hs10

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs10_id => (x = opts.delete(:hs10_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs10_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs10_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10Version.new(x) }
          end

        end

        class Hs6

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs6_id => (x = opts.delete(:hs6_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs6_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs6_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6Version.new(x) }
          end

        end

        class Taxes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/taxes").with_query(query).get
            ::Io::Flow::V0::Models::Tax.new(r)
          end

        end

        class Authorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Authorization.new(x) }
          end

          # Create a new authorization.
          def post(organization, authorization_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('authorization_form', authorization_form, ::Io::Flow::V0::Models::AuthorizationForm)
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_json(authorization_form.to_json).post
            ::Io::Flow::V0::Models::Authorization.new(r)
          end

          # Returns information about a specific authorization.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Authorization.new(r)
          end

          # Deletes a given authorization. This method will return a 422 if funds have
          # already been captured.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('authorization_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AuthorizationVersion.new(x) }
          end

        end

        class Captures

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_reference => (x = opts.delete(:authorization_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_reference', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Capture.new(x) }
          end

          # Create a new capture.
          def post(organization, capture_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('capture_form', capture_form, ::Io::Flow::V0::Models::CaptureForm)
            r = @client.request("/#{CGI.escape(organization)}/captures").with_json(capture_form.to_json).post
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Returns information about a specific capture.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('capture_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CaptureVersion.new(x) }
          end

        end

        class Cards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Card.new(x) }
          end

          # Create a new card.
          def post(organization, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('card_form', card_form, ::Io::Flow::V0::Models::CardForm)
            r = @client.request("/#{CGI.escape(organization)}/cards").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Returns information about a specific card.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Deletes the card with the specified ID.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}").delete
            nil
          end

          # Updates are implemented as copy on write. This method is a convenience
          # method that will transactionally DELETE the card with the specified ID, then
          # CREATE a new card with the data from this request. Note that this means the
          # returned credit card token will be DIFFERENT from the one used in the
          # request.
          def post_updates_by_id(organization, id, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('card_form', card_form, ::Io::Flow::V0::Models::CardForm)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}/updates").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :card_id => (x = opts.delete(:card_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('card_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CardVersion.new(x) }
          end

        end

        class Refunds

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_reference => (x = opts.delete(:authorization_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_reference', x, String)),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, String)),
              :capture_reference => (x = opts.delete(:capture_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_reference', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Refund.new(x) }
          end

          # Create a new refund.
          def post(organization, refund_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('refund_form', refund_form, ::Io::Flow::V0::Models::RefundForm)
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_json(refund_form.to_json).post
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Returns information about a specific refund.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :refund_id => (x = opts.delete(:refund_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('refund_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RefundVersion.new(x) }
          end

        end

        class Bookings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/bookings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Booking.new(x) }
          end

          def post(organization, booking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('booking_form', booking_form, ::Io::Flow::V0::Models::BookingForm)
            r = @client.request("/#{CGI.escape(organization)}/bookings").with_json(booking_form.to_json).post
            ::Io::Flow::V0::Models::Booking.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/bookings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Booking.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :booking => (x = opts.delete(:booking); x.nil? ? nil : HttpClient::Preconditions.assert_class('booking', x, Array).map { |v| HttpClient::Preconditions.assert_class('booking', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/bookings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::BookingVersion.new(x) }
          end

        end

        class Carriers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/carriers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Carrier.new(x) }
          end

          def post(carrier_form)
            HttpClient::Preconditions.assert_class('carrier_form', carrier_form, ::Io::Flow::V0::Models::CarrierForm)
            r = @client.request("/carriers").with_json(carrier_form.to_json).post
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/carriers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def put_by_id(id, carrier_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('carrier_form', carrier_form, ::Io::Flow::V0::Models::CarrierForm)
            r = @client.request("/carriers/#{CGI.escape(id)}").with_json(carrier_form.to_json).put
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/carriers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier => (x = opts.delete(:carrier); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/carriers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierVersion.new(x) }
          end

        end

        class CarrierAccounts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierAccount.new(x) }
          end

          def post(organization, carrier_account_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('carrier_account_form', carrier_account_form, ::Io::Flow::V0::Models::CarrierAccountForm)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts").with_json(carrier_account_form.to_json).post
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def put_by_id(organization, id, carrier_account_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('carrier_account_form', carrier_account_form, ::Io::Flow::V0::Models::CarrierAccountForm)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").with_json(carrier_account_form.to_json).put
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier_account => (x = opts.delete(:carrier_account); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_account', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_account', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierAccountVersion.new(x) }
          end

        end

        class Centers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Center.new(x) }
          end

          def post(organization, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers").with_json(center_form.to_json).post
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def put_by_id(organization, id, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").with_json(center_form.to_json).put
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CenterVersion.new(x) }
          end

        end

        class DeliveryWindows

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Endpoint to request a delivery window. Requires some knowledge of origin
          # (based on organization, center, or specified address string) and destination
          # (based on ip, lat/long, or address string). Other attributes allow us to
          # narrow down delivery windows even more such as service level to be used and
          # timestamp of expected shipment date.
          def get_summary(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :strategy => (x = (x = opts.delete(:strategy); x.nil? ? "range" : x); x.is_a?(::Io::Flow::V0::Models::Strategy) ? x : ::Io::Flow::V0::Models::Strategy.apply(x)).value,
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String)),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/delivery-windows/summary").with_query(query).get
            ::Io::Flow::V0::Models::DeliveryWindow.new(r)
          end

        end

        class Events

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :label_id => (x = opts.delete(:label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/events").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Event.new(x) }
          end

          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/events/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Event.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :event_id => (x = opts.delete(:event_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('event_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('event_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/events/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::EventVersion.new(x) }
          end

        end

        class Labels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Label.new(x) }
          end

          def post(label_form)
            HttpClient::Preconditions.assert_class('label_form', label_form, ::Io::Flow::V0::Models::LabelForm)
            r = @client.request("/labels").with_json(label_form.to_json).post
            ::Io::Flow::V0::Models::Label.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/labels/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Label.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :label_id => (x = opts.delete(:label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LabelVersion.new(x) }
          end

        end

        class Lanes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/lanes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Lane.new(x) }
          end

          def post(lane_form)
            HttpClient::Preconditions.assert_class('lane_form', lane_form, ::Io::Flow::V0::Models::LaneForm)
            r = @client.request("/lanes").with_json(lane_form.to_json).post
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/lanes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def put_by_id(id, lane_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('lane_form', lane_form, ::Io::Flow::V0::Models::LaneForm)
            r = @client.request("/lanes/#{CGI.escape(id)}").with_json(lane_form.to_json).put
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/lanes/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :lane => (x = opts.delete(:lane); x.nil? ? nil : HttpClient::Preconditions.assert_class('lane', x, Array).map { |v| HttpClient::Preconditions.assert_class('lane', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/lanes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LaneVersion.new(x) }
          end

        end

        class Quotes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search quotes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Quote.new(x) }
          end

          def post(organization, quote_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('quote_form', quote_form, ::Io::Flow::V0::Models::QuoteForm)
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_json(quote_form.to_json).post
            r.map { |x| ::Io::Flow::V0::Models::Quote.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/quotes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Quote.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :quote => (x = opts.delete(:quote); x.nil? ? nil : HttpClient::Preconditions.assert_class('quote', x, Array).map { |v| HttpClient::Preconditions.assert_class('quote', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::QuoteVersion.new(x) }
          end

        end

        class Services

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/services").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Service.new(x) }
          end

          def post(service_form, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('service_form', service_form, ::Io::Flow::V0::Models::ServiceForm)
            r = @client.request("/services").with_query(query).with_json(service_form.to_json).post
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/services/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def put_by_id(id, service_form, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('service_form', service_form, ::Io::Flow::V0::Models::ServiceForm)
            r = @client.request("/services/#{CGI.escape(id)}").with_query(query).with_json(service_form.to_json).put
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/services/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/services/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ServiceVersion.new(x) }
          end

        end

        class Shipments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Shipment.new(x) }
          end

          def post(organization, shipment_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('shipment_form', shipment_form, ::Io::Flow::V0::Models::ShipmentForm)
            r = @client.request("/#{CGI.escape(organization)}/shipments").with_json(shipment_form.to_json).post
            ::Io::Flow::V0::Models::Shipment.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Shipment.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentVersion.new(x) }
          end

        end

        class ShipmentLabels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, tracking_number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentLabel.new(x) }
          end

          def post(organization, tracking_number, shipment_label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            HttpClient::Preconditions.assert_class('shipment_label_form', shipment_label_form, ::Io::Flow::V0::Models::ShipmentLabelForm)
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels").with_json(shipment_label_form.to_json).post
            ::Io::Flow::V0::Models::ShipmentLabel.new(r)
          end

          def get_versions(organization, tracking_number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentLabelVersion.new(x) }
          end

        end

        class Tiers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tier.new(x) }
          end

          def post(organization, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_json(tier_form.to_json).post
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def put_by_id(organization, id, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").with_json(tier_form.to_json).put
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier => (x = opts.delete(:tier); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierVersion.new(x) }
          end

        end

        class Trackings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/trackings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tracking.new(x) }
          end

          def post(tracking_form)
            HttpClient::Preconditions.assert_class('tracking_form', tracking_form, ::Io::Flow::V0::Models::TrackingForm)
            r = @client.request("/trackings").with_json(tracking_form.to_json).post
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/trackings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/trackings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingVersion.new(x) }
          end

        end

        class Countries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of countries.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/countries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

        end

        class Currencies

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of currencies.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/currencies").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Currency.new(x) }
          end

        end

        class Languages

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of languages.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/languages").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Language.new(x) }
          end

        end

        class Timezones

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of timezones.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/timezones").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Timezone.new(x) }
          end

        end

        class Documents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns items based on search criteria
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :attributes => (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Array).map { |v| HttpClient::Preconditions.assert_class('attributes', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CatalogItemDocument.new(x) }
          end

          # Returns harmonization information based on search criteria
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizationDocument.new(x) }
          end

        end

        class EmailVerifications

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_token(token, hash)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/users/emails/verifications/#{CGI.escape(token)}").with_json(hash.to_json).post
            ::Io::Flow::V0::Models::EmailVerification.new(r)
          end

        end

        class Healthchecks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_healthcheck
            r = @client.request("/_internal_/healthcheck").get
            ::Io::Flow::V0::Models::Healthcheck.new(r)
          end

        end

        class Invitations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search invitations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Invitation.new(x) }
          end

          # Create a new invitation.
          def post(invitation_form)
            HttpClient::Preconditions.assert_class('invitation_form', invitation_form, ::Io::Flow::V0::Models::InvitationForm)
            r = @client.request("/invitations").with_json(invitation_form.to_json).post
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Returns information about a specific invitation.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/invitations/#{CGI.escape(id)}").delete
            nil
          end

          # Lookup an invitation by its token.
          def get_tokens_by_token(token, incoming={})
            HttpClient::Preconditions.assert_class('token', token, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Accepts the invitation w/ the specified token, creating a membership record
          # for this user within this organization. Invitations are one time use only -
          # you will get a validation error if the invitation has previously been
          # accepted.
          def put_tokens_by_token(token, invitation_accepts_form)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('invitation_accepts_form', invitation_accepts_form, ::Io::Flow::V0::Models::InvitationAcceptsForm)
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_json(invitation_accepts_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :invitation => (x = opts.delete(:invitation); x.nil? ? nil : HttpClient::Preconditions.assert_class('invitation', x, Array).map { |v| HttpClient::Preconditions.assert_class('invitation', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InvitationVersion.new(x) }
          end

        end

        class Locations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Based on the provided location parameters, returns a list of the best
          # potential matching addresses.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/locations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Location.new(x) }
          end

        end

        class Memberships

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search memberships. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x)).value }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Membership.new(x) }
          end

          # Create a new membership.
          def post(membership_form)
            HttpClient::Preconditions.assert_class('membership_form', membership_form, ::Io::Flow::V0::Models::MembershipForm)
            r = @client.request("/memberships").with_json(membership_form.to_json).post
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Returns information about a specific membership.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Change the role for a specific membership record. If the user already has
          # the specified role within the organization, does nothing.
          def put_by_id(id, membership_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('membership_put_form', membership_put_form, ::Io::Flow::V0::Models::MembershipPutForm)
            r = @client.request("/memberships/#{CGI.escape(id)}").with_json(membership_put_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/memberships/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :membership => (x = opts.delete(:membership); x.nil? ? nil : HttpClient::Preconditions.assert_class('membership', x, Array).map { |v| HttpClient::Preconditions.assert_class('membership', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::MembershipVersion.new(x) }
          end

        end

        class Organizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organizations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Organization.new(x) }
          end

          # Create a new organization.
          def post(organization_form)
            HttpClient::Preconditions.assert_class('organization_form', organization_form, ::Io::Flow::V0::Models::OrganizationForm)
            r = @client.request("/organizations").with_json(organization_form.to_json).post
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Returns information about a specific organization.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Update or create an organization with the specified id.
          def put_by_id(id, organization_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('organization_form', organization_form, ::Io::Flow::V0::Models::OrganizationForm)
            r = @client.request("/organizations/#{CGI.escape(id)}").with_json(organization_form.to_json).put
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Delete the organization with this id
          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, Array).map { |v| HttpClient::Preconditions.assert_class('organization', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationVersion.new(x) }
          end

        end

        class PasswordResetForms

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(password_reset_form, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('password_reset_form', password_reset_form, ::Io::Flow::V0::Models::PasswordResetForm)
            r = @client.request("/users/passwords").with_query(query).with_json(password_reset_form.to_json).post
            ::Io::Flow::V0::Models::ExpandableUser.from_json(r)
          end

          def post_resets(password_reset_request_form)
            HttpClient::Preconditions.assert_class('password_reset_request_form', password_reset_request_form, ::Io::Flow::V0::Models::PasswordResetRequestForm)
            r = @client.request("/users/passwords/resets").with_json(password_reset_request_form.to_json).post
            nil
          end

        end

        class Suggestions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns search suggestions for catalog items
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-count" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

          # Returns search suggestions for harmonization data
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

        end

        class Tokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens that you are authorized to view. Note that the cleartext
          # token value is never sent. To view the API token itself, see the resource
          # path /:id/cleartext
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Token.new(x) }
          end

          # Create a new token for the requesting user
          def post(token_form)
            HttpClient::Preconditions.assert_class('token_form', token_form, ::Io::Flow::V0::Models::TokenForm)
            r = @client.request("/tokens").with_json(token_form.to_json).post
            ::Io::Flow::V0::Models::Token.new(r)
          end

          # Get metadata for the token with this ID
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Token.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").delete
            nil
          end

          # Retrieves the token with the actual string token in cleartext
          def get_cleartext_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}/cleartext").get
            ::Io::Flow::V0::Models::Cleartext.new(r)
          end

          # Preferred method to validate a token, obtaining user information if the
          # token is valid (or a 404 if the token does not exist). We use an HTTP POST
          # with a form body to enusre that the token itself is not logged in the
          # request logs.
          def post_authentications(token_authentication_form)
            HttpClient::Preconditions.assert_class('token_authentication_form', token_authentication_form, ::Io::Flow::V0::Models::TokenAuthenticationForm)
            r = @client.request("/tokens/authentications").with_json(token_authentication_form.to_json).post
            ::Io::Flow::V0::Models::TokenReference.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token_id => (x = opts.delete(:token_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('token_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('token_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TokenVersion.new(x) }
          end

        end

        class Users

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search users. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::User.new(x) }
          end

          # Create a new user.
          def post(user_form)
            HttpClient::Preconditions.assert_class('user_form', user_form, ::Io::Flow::V0::Models::UserForm)
            r = @client.request("/users").with_json(user_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Returns information about a specific user.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update a user.
          def put_by_id(id, user_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('user_put_form', user_put_form, ::Io::Flow::V0::Models::UserPutForm)
            r = @client.request("/users/#{CGI.escape(id)}").with_json(user_put_form.to_json).put
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update the password for a user.
          def patch_passwords_by_id(id, password_change_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('password_change_form', password_change_form, ::Io::Flow::V0::Models::PasswordChangeForm)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").with_json(password_change_form.to_json).patch
            nil
          end

          # Deletes a password for the given user.
          def delete_passwords_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").delete
            nil
          end

          # Authenticates a user by email / password.
          def post_authenticate(authentication_form)
            HttpClient::Preconditions.assert_class('authentication_form', authentication_form, ::Io::Flow::V0::Models::AuthenticationForm)
            r = @client.request("/users/authenticate").with_json(authentication_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user_id => (x = opts.delete(:user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('user_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::UserVersion.new(x) }
          end

        end

        class Validations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(validation_form)
            HttpClient::Preconditions.assert_class('validation_form', validation_form, ::Io::Flow::V0::Models::ValidationForm)
            r = @client.request("/token-validations").with_json(validation_form.to_json).post
            ::Io::Flow::V0::Models::Validation.new(r)
          end

        end

      end

      module Models

        # Cost variation used to calculate localized prices
        class Adjustment

          module Types
            MARGIN = 'margin' unless defined?(MARGIN)
            ROUNDING = 'rounding' unless defined?(ROUNDING)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Adjustment')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Adjustment.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::MARGIN; Margin.new(hash)
              when Types::ROUNDING; Rounding.new(hash)
              else AdjustmentUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class AdjustmentUndefinedType < Adjustment

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Represents all possible responses from an authorization attempt
        class AuthorizationDetails

          module Types
            AUTHORIZATION_DETAILS_DECLINE = 'authorization_details_decline' unless defined?(AUTHORIZATION_DETAILS_DECLINE)
            AUTHORIZATION_DETAILS_SUCCESS = 'authorization_details_success' unless defined?(AUTHORIZATION_DETAILS_SUCCESS)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'AuthorizationDetails')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def AuthorizationDetails.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::AUTHORIZATION_DETAILS_DECLINE; AuthorizationDetailsDecline.new(hash)
              when Types::AUTHORIZATION_DETAILS_SUCCESS; AuthorizationDetailsSuccess.new(hash)
              else AuthorizationDetailsUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class AuthorizationDetailsUndefinedType < AuthorizationDetails

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Credentials

          module Types
            DHL_CREDENTIALS = 'dhl_credentials' unless defined?(DHL_CREDENTIALS)
            FEDEX_CREDENTIALS = 'fedex_credentials' unless defined?(FEDEX_CREDENTIALS)
            UPS_CREDENTIALS = 'ups_credentials' unless defined?(UPS_CREDENTIALS)
            USPS_CREDENTIALS = 'usps_credentials' unless defined?(USPS_CREDENTIALS)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Credentials')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Credentials.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::DHL_CREDENTIALS; DhlCredentials.new(hash)
              when Types::FEDEX_CREDENTIALS; FedexCredentials.new(hash)
              when Types::UPS_CREDENTIALS; UpsCredentials.new(hash)
              when Types::USPS_CREDENTIALS; UspsCredentials.new(hash)
              else CredentialsUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class CredentialsUndefinedType < Credentials

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Deminimus

          module Types
            DEMINIMUS_SIMPLE = 'deminimus_simple' unless defined?(DEMINIMUS_SIMPLE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Deminimus')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Deminimus.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::DEMINIMUS_SIMPLE; DeminimusSimple.new(hash)
              else DeminimusUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class DeminimusUndefinedType < Deminimus

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Document

          module Types
            CATALOG_ITEM_DOCUMENT = 'catalog_item_document' unless defined?(CATALOG_ITEM_DOCUMENT)
            HARMONIZATION_DOCUMENT = 'harmonization_document' unless defined?(HARMONIZATION_DOCUMENT)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Document')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Document.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::CATALOG_ITEM_DOCUMENT; CatalogItemDocument.new(hash)
              when Types::HARMONIZATION_DOCUMENT; HarmonizationDocument.new(hash)
              else DocumentUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class DocumentUndefinedType < Document

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableBooking

          module Types
            BOOKING = 'booking' unless defined?(BOOKING)
            BOOKING_REFERENCE = 'booking_reference' unless defined?(BOOKING_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableBooking')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableBooking.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::BOOKING; Booking.new(hash)
              when Types::BOOKING_REFERENCE; BookingReference.new(hash)
              else ExpandableBookingUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableBookingUndefinedType < ExpandableBooking

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableCarrier

          module Types
            CARRIER = 'carrier' unless defined?(CARRIER)
            CARRIER_REFERENCE = 'carrier_reference' unless defined?(CARRIER_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableCarrier')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableCarrier.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::CARRIER; Carrier.new(hash)
              when Types::CARRIER_REFERENCE; CarrierReference.new(hash)
              else ExpandableCarrierUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableCarrierUndefinedType < ExpandableCarrier

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableCarrierAccount

          module Types
            CARRIER_ACCOUNT = 'carrier_account' unless defined?(CARRIER_ACCOUNT)
            CARRIER_ACCOUNT_REFERENCE = 'carrier_account_reference' unless defined?(CARRIER_ACCOUNT_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableCarrierAccount')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableCarrierAccount.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::CARRIER_ACCOUNT; CarrierAccount.new(hash)
              when Types::CARRIER_ACCOUNT_REFERENCE; CarrierAccountReference.new(hash)
              else ExpandableCarrierAccountUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableCarrierAccountUndefinedType < ExpandableCarrierAccount

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableCenter

          module Types
            CENTER = 'center' unless defined?(CENTER)
            CENTER_REFERENCE = 'center_reference' unless defined?(CENTER_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableCenter')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableCenter.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::CENTER; Center.new(hash)
              when Types::CENTER_REFERENCE; CenterReference.new(hash)
              else ExpandableCenterUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableCenterUndefinedType < ExpandableCenter

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableDelivery

          module Types
            DELIVERY = 'delivery' unless defined?(DELIVERY)
            DELIVERY_REFERENCE = 'delivery_reference' unless defined?(DELIVERY_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableDelivery')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableDelivery.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::DELIVERY; Delivery.new(hash)
              when Types::DELIVERY_REFERENCE; DeliveryReference.new(hash)
              else ExpandableDeliveryUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableDeliveryUndefinedType < ExpandableDelivery

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A function can be represented with just it's ID, or the entire model
        class ExpandableFunction

          module Types
            FUNCTION = 'function' unless defined?(FUNCTION)
            FUNCTION_REFERENCE = 'function_reference' unless defined?(FUNCTION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableFunction')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableFunction.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::FUNCTION; Function.new(hash)
              when Types::FUNCTION_REFERENCE; FunctionReference.new(hash)
              else ExpandableFunctionUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableFunctionUndefinedType < ExpandableFunction

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableLane

          module Types
            LANE = 'lane' unless defined?(LANE)
            LANE_REFERENCE = 'lane_reference' unless defined?(LANE_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableLane')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableLane.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::LANE; Lane.new(hash)
              when Types::LANE_REFERENCE; LaneReference.new(hash)
              else ExpandableLaneUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableLaneUndefinedType < ExpandableLane

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableLocation

          module Types
            LOCATION = 'location' unless defined?(LOCATION)
            LOCATION_REFERENCE = 'location_reference' unless defined?(LOCATION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableLocation')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableLocation.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::LOCATION; Location.new(hash)
              when Types::LOCATION_REFERENCE; LocationReference.new(hash)
              else ExpandableLocationUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableLocationUndefinedType < ExpandableLocation

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableOption

          module Types
            OPTION = 'option' unless defined?(OPTION)
            OPTION_REFERENCE = 'option_reference' unless defined?(OPTION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableOption')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableOption.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::OPTION; Option.new(hash)
              when Types::OPTION_REFERENCE; OptionReference.new(hash)
              else ExpandableOptionUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableOptionUndefinedType < ExpandableOption

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableOrganization

          module Types
            ORGANIZATION = 'organization' unless defined?(ORGANIZATION)
            ORGANIZATION_REFERENCE = 'organization_reference' unless defined?(ORGANIZATION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableOrganization')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableOrganization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::ORGANIZATION; Organization.new(hash)
              when Types::ORGANIZATION_REFERENCE; OrganizationReference.new(hash)
              else ExpandableOrganizationUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableOrganizationUndefinedType < ExpandableOrganization

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableQuote

          module Types
            QUOTE = 'quote' unless defined?(QUOTE)
            QUOTE_REFERENCE = 'quote_reference' unless defined?(QUOTE_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableQuote')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableQuote.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::QUOTE; Quote.new(hash)
              when Types::QUOTE_REFERENCE; QuoteReference.new(hash)
              else ExpandableQuoteUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableQuoteUndefinedType < ExpandableQuote

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableService

          module Types
            SERVICE = 'service' unless defined?(SERVICE)
            SERVICE_REFERENCE = 'service_reference' unless defined?(SERVICE_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableService')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableService.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::SERVICE; Service.new(hash)
              when Types::SERVICE_REFERENCE; ServiceReference.new(hash)
              else ExpandableServiceUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableServiceUndefinedType < ExpandableService

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableShipment

          module Types
            SHIPMENT = 'shipment' unless defined?(SHIPMENT)
            SHIPMENT_REFERENCE = 'shipment_reference' unless defined?(SHIPMENT_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableShipment')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableShipment.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::SHIPMENT; Shipment.new(hash)
              when Types::SHIPMENT_REFERENCE; ShipmentReference.new(hash)
              else ExpandableShipmentUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableShipmentUndefinedType < ExpandableShipment

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableShipmentLabel

          module Types
            SHIPMENT_LABEL = 'shipment_label' unless defined?(SHIPMENT_LABEL)
            SHIPMENT_LABEL_REFERENCE = 'shipment_label_reference' unless defined?(SHIPMENT_LABEL_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableShipmentLabel')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableShipmentLabel.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::SHIPMENT_LABEL; ShipmentLabel.new(hash)
              when Types::SHIPMENT_LABEL_REFERENCE; ShipmentLabelReference.new(hash)
              else ExpandableShipmentLabelUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableShipmentLabelUndefinedType < ExpandableShipmentLabel

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A subcatalog can be represented with just it's ID, or the entire model
        class ExpandableSubcatalog

          module Types
            SUBCATALOG = 'subcatalog' unless defined?(SUBCATALOG)
            SUBCATALOG_REFERENCE = 'subcatalog_reference' unless defined?(SUBCATALOG_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableSubcatalog')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableSubcatalog.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::SUBCATALOG; Subcatalog.new(hash)
              when Types::SUBCATALOG_REFERENCE; SubcatalogReference.new(hash)
              else ExpandableSubcatalogUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableSubcatalogUndefinedType < ExpandableSubcatalog

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableTier

          module Types
            TIER = 'tier' unless defined?(TIER)
            TIER_REFERENCE = 'tier_reference' unless defined?(TIER_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableTier')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableTier.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::TIER; Tier.new(hash)
              when Types::TIER_REFERENCE; TierReference.new(hash)
              else ExpandableTierUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableTierUndefinedType < ExpandableTier

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableUser

          module Types
            USER = 'user' unless defined?(USER)
            USER_REFERENCE = 'user_reference' unless defined?(USER_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableUser')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableUser.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::USER; User.new(hash)
              when Types::USER_REFERENCE; UserReference.new(hash)
              else ExpandableUserUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableUserUndefinedType < ExpandableUser

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Possible outcome types from a tier rule
        class RuleOutcome

          module Types
            FREE_SHIPPING = 'free_shipping' unless defined?(FREE_SHIPPING)
            AT_COST = 'at_cost' unless defined?(AT_COST)
            FLAT_RATE = 'flat_rate' unless defined?(FLAT_RATE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'RuleOutcome')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def RuleOutcome.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::FREE_SHIPPING; FreeShipping.new(hash)
              when Types::AT_COST; AtCost.new(hash)
              when Types::FLAT_RATE; FlatRate.new(hash)
              else RuleOutcomeUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class RuleOutcomeUndefinedType < RuleOutcome

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AdjustmentType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AdjustmentType for this value, creating a new instance for an unknown value
          def AdjustmentType.apply(value)
            if value.instance_of?(AdjustmentType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AdjustmentType.new(value))
            end
          end

          # Returns the instance of AdjustmentType for this value, or nil if not found
          def AdjustmentType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AdjustmentType.ALL.find { |v| v.value == value }
          end

          def AdjustmentType.ALL
            @@all ||= [AdjustmentType.fixed_margin, AdjustmentType.percent_margin, AdjustmentType.round]
          end

          def AdjustmentType.fixed_margin
            @@_fixed_margin ||= AdjustmentType.new('fixed_margin')
          end

          def AdjustmentType.percent_margin
            @@_percent_margin ||= AdjustmentType.new('percent_margin')
          end

          def AdjustmentType.round
            @@_round ||= AdjustmentType.new('round')
          end

          def to_hash
            value
          end

        end

        class Calendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Calendar for this value, creating a new instance for an unknown value
          def Calendar.apply(value)
            if value.instance_of?(Calendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Calendar.new(value))
            end
          end

          # Returns the instance of Calendar for this value, or nil if not found
          def Calendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Calendar.ALL.find { |v| v.value == value }
          end

          def Calendar.ALL
            @@all ||= [Calendar.weekdays, Calendar.everyday]
          end

          # Mon - Fri
          def Calendar.weekdays
            @@_weekdays ||= Calendar.new('weekdays')
          end

          # 7 days per week
          def Calendar.everyday
            @@_everyday ||= Calendar.new('everyday')
          end

          def to_hash
            value
          end

        end

        class Capability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Capability for this value, creating a new instance for an unknown value
          def Capability.apply(value)
            if value.instance_of?(Capability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Capability.new(value))
            end
          end

          # Returns the instance of Capability for this value, or nil if not found
          def Capability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Capability.ALL.find { |v| v.value == value }
          end

          def Capability.ALL
            @@all ||= [Capability.crossdock]
          end

          def Capability.crossdock
            @@_crossdock ||= Capability.new('crossdock')
          end

          def to_hash
            value
          end

        end

        class CardType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CardType for this value, creating a new instance for an unknown value
          def CardType.apply(value)
            if value.instance_of?(CardType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CardType.new(value))
            end
          end

          # Returns the instance of CardType for this value, or nil if not found
          def CardType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CardType.ALL.find { |v| v.value == value }
          end

          def CardType.ALL
            @@all ||= [CardType.visa, CardType.mastercard, CardType.american_express, CardType.diners_club, CardType.discover, CardType.jcb, CardType.china_union_pay]
          end

          def CardType.visa
            @@_visa ||= CardType.new('visa')
          end

          def CardType.mastercard
            @@_mastercard ||= CardType.new('mastercard')
          end

          def CardType.american_express
            @@_american_express ||= CardType.new('american_express')
          end

          def CardType.diners_club
            @@_diners_club ||= CardType.new('diners_club')
          end

          def CardType.discover
            @@_discover ||= CardType.new('discover')
          end

          def CardType.jcb
            @@_jcb ||= CardType.new('jcb')
          end

          def CardType.china_union_pay
            @@_china_union_pay ||= CardType.new('china_union_pay')
          end

          def to_hash
            value
          end

        end

        class ChangeType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ChangeType for this value, creating a new instance for an unknown value
          def ChangeType.apply(value)
            if value.instance_of?(ChangeType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ChangeType.new(value))
            end
          end

          # Returns the instance of ChangeType for this value, or nil if not found
          def ChangeType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ChangeType.ALL.find { |v| v.value == value }
          end

          def ChangeType.ALL
            @@all ||= [ChangeType.insert, ChangeType.update, ChangeType.delete]
          end

          def ChangeType.insert
            @@_insert ||= ChangeType.new('insert')
          end

          def ChangeType.update
            @@_update ||= ChangeType.new('update')
          end

          def ChangeType.delete
            @@_delete ||= ChangeType.new('delete')
          end

          def to_hash
            value
          end

        end

        class CommercialTerm

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CommercialTerm for this value, creating a new instance for an unknown value
          def CommercialTerm.apply(value)
            if value.instance_of?(CommercialTerm)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CommercialTerm.new(value))
            end
          end

          # Returns the instance of CommercialTerm for this value, or nil if not found
          def CommercialTerm.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CommercialTerm.ALL.find { |v| v.value == value }
          end

          def CommercialTerm.ALL
            @@all ||= [CommercialTerm.ddp, CommercialTerm.ddu, CommercialTerm.cpt, CommercialTerm.cip]
          end

          def CommercialTerm.ddp
            @@_ddp ||= CommercialTerm.new('DDP')
          end

          def CommercialTerm.ddu
            @@_ddu ||= CommercialTerm.new('DDU')
          end

          def CommercialTerm.cpt
            @@_cpt ||= CommercialTerm.new('CPT')
          end

          def CommercialTerm.cip
            @@_cip ||= CommercialTerm.new('CIP')
          end

          def to_hash
            value
          end

        end

        class ContentType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ContentType for this value, creating a new instance for an unknown value
          def ContentType.apply(value)
            if value.instance_of?(ContentType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ContentType.new(value))
            end
          end

          # Returns the instance of ContentType for this value, or nil if not found
          def ContentType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ContentType.ALL.find { |v| v.value == value }
          end

          def ContentType.ALL
            @@all ||= [ContentType.zpl, ContentType.pdf, ContentType.png]
          end

          def ContentType.zpl
            @@_zpl ||= ContentType.new('zpl')
          end

          def ContentType.pdf
            @@_pdf ||= ContentType.new('pdf')
          end

          def ContentType.png
            @@_png ||= ContentType.new('png')
          end

          def to_hash
            value
          end

        end

        class DeliveredDuty

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveredDuty for this value, creating a new instance for an unknown value
          def DeliveredDuty.apply(value)
            if value.instance_of?(DeliveredDuty)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveredDuty.new(value))
            end
          end

          # Returns the instance of DeliveredDuty for this value, or nil if not found
          def DeliveredDuty.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveredDuty.ALL.find { |v| v.value == value }
          end

          def DeliveredDuty.ALL
            @@all ||= [DeliveredDuty.paid, DeliveredDuty.unpaid]
          end

          def DeliveredDuty.paid
            @@_paid ||= DeliveredDuty.new('paid')
          end

          def DeliveredDuty.unpaid
            @@_unpaid ||= DeliveredDuty.new('unpaid')
          end

          def to_hash
            value
          end

        end

        class DimensionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DimensionType for this value, creating a new instance for an unknown value
          def DimensionType.apply(value)
            if value.instance_of?(DimensionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DimensionType.new(value))
            end
          end

          # Returns the instance of DimensionType for this value, or nil if not found
          def DimensionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DimensionType.ALL.find { |v| v.value == value }
          end

          def DimensionType.ALL
            @@all ||= [DimensionType.product, DimensionType.package]
          end

          # The standalone dimensions of an item.
          def DimensionType.product
            @@_product ||= DimensionType.new('product')
          end

          # The boxed dimensions of an item.
          def DimensionType.package
            @@_package ||= DimensionType.new('package')
          end

          def to_hash
            value
          end

        end

        class EelPfc

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of EelPfc for this value, creating a new instance for an unknown value
          def EelPfc.apply(value)
            if value.instance_of?(EelPfc)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || EelPfc.new(value))
            end
          end

          # Returns the instance of EelPfc for this value, or nil if not found
          def EelPfc.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            EelPfc.ALL.find { |v| v.value == value }
          end

          def EelPfc.ALL
            @@all ||= [EelPfc.n_o_e_e_i_30_37_a, EelPfc.n_o_e_e_i_30_37_h, EelPfc.noeei_30_36, EelPfc.aes_itn]
          end

          def EelPfc.n_o_e_e_i_30_37_a
            @@_n_o_e_e_i_30_37_a ||= EelPfc.new('NOEEI_30_37_a')
          end

          def EelPfc.n_o_e_e_i_30_37_h
            @@_n_o_e_e_i_30_37_h ||= EelPfc.new('NOEEI_30_37_h')
          end

          def EelPfc.noeei_30_36
            @@_noeei_30_36 ||= EelPfc.new('NOEEI_30_36')
          end

          def EelPfc.aes_itn
            @@_aes_itn ||= EelPfc.new('AES_ITN')
          end

          def to_hash
            value
          end

        end

        class ExceptionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExceptionType for this value, creating a new instance for an unknown value
          def ExceptionType.apply(value)
            if value.instance_of?(ExceptionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExceptionType.new(value))
            end
          end

          # Returns the instance of ExceptionType for this value, or nil if not found
          def ExceptionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExceptionType.ALL.find { |v| v.value == value }
          end

          def ExceptionType.ALL
            @@all ||= [ExceptionType.open, ExceptionType.closed]
          end

          def ExceptionType.open
            @@_open ||= ExceptionType.new('open')
          end

          def ExceptionType.closed
            @@_closed ||= ExceptionType.new('closed')
          end

          def to_hash
            value
          end

        end

        class HolidayCalendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of HolidayCalendar for this value, creating a new instance for an unknown value
          def HolidayCalendar.apply(value)
            if value.instance_of?(HolidayCalendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || HolidayCalendar.new(value))
            end
          end

          # Returns the instance of HolidayCalendar for this value, or nil if not found
          def HolidayCalendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            HolidayCalendar.ALL.find { |v| v.value == value }
          end

          def HolidayCalendar.ALL
            @@all ||= [HolidayCalendar.us_bank_holidays, HolidayCalendar.jewish_holidays]
          end

          def HolidayCalendar.us_bank_holidays
            @@_us_bank_holidays ||= HolidayCalendar.new('us_bank_holidays')
          end

          def HolidayCalendar.jewish_holidays
            @@_jewish_holidays ||= HolidayCalendar.new('jewish_holidays')
          end

          def to_hash
            value
          end

        end

        class Integration

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Integration for this value, creating a new instance for an unknown value
          def Integration.apply(value)
            if value.instance_of?(Integration)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Integration.new(value))
            end
          end

          # Returns the instance of Integration for this value, or nil if not found
          def Integration.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Integration.ALL.find { |v| v.value == value }
          end

          def Integration.ALL
            @@all ||= [Integration.direct, Integration.informational, Integration.preadvice]
          end

          # Always generate a label for the chosen delivery option.
          def Integration.direct
            @@_direct ||= Integration.new('direct')
          end

          # Booking and label generation is not available. Just use Flow to calculate
          # delivery window estimates and shipment prices to display.
          def Integration.informational
            @@_informational ||= Integration.new('informational')
          end

          # A generic label will be provided by the client organization when available as
          # pre-advice shipment notification to carrier partner.
          def Integration.preadvice
            @@_preadvice ||= Integration.new('preadvice')
          end

          def to_hash
            value
          end

        end

        class Levy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Levy for this value, creating a new instance for an unknown value
          def Levy.apply(value)
            if value.instance_of?(Levy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Levy.new(value))
            end
          end

          # Returns the instance of Levy for this value, or nil if not found
          def Levy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Levy.ALL.find { |v| v.value == value }
          end

          def Levy.ALL
            @@all ||= [Levy.duty, Levy.shipping, Levy.vat]
          end

          def Levy.duty
            @@_duty ||= Levy.new('duty')
          end

          def Levy.shipping
            @@_shipping ||= Levy.new('shipping')
          end

          # Value-Added Tax
          def Levy.vat
            @@_vat ||= Levy.new('vat')
          end

          def to_hash
            value
          end

        end

        class LevyComponent

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyComponent for this value, creating a new instance for an unknown value
          def LevyComponent.apply(value)
            if value.instance_of?(LevyComponent)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyComponent.new(value))
            end
          end

          # Returns the instance of LevyComponent for this value, or nil if not found
          def LevyComponent.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyComponent.ALL.find { |v| v.value == value }
          end

          def LevyComponent.ALL
            @@all ||= [LevyComponent.goods, LevyComponent.duty, LevyComponent.insurance, LevyComponent.freight, LevyComponent.vat]
          end

          # The value of goods
          def LevyComponent.goods
            @@_goods ||= LevyComponent.new('goods')
          end

          def LevyComponent.duty
            @@_duty ||= LevyComponent.new('duty')
          end

          def LevyComponent.insurance
            @@_insurance ||= LevyComponent.new('insurance')
          end

          def LevyComponent.freight
            @@_freight ||= LevyComponent.new('freight')
          end

          # Value-Added Tax
          def LevyComponent.vat
            @@_vat ||= LevyComponent.new('vat')
          end

          def to_hash
            value
          end

        end

        class LevyStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyStrategy for this value, creating a new instance for an unknown value
          def LevyStrategy.apply(value)
            if value.instance_of?(LevyStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyStrategy.new(value))
            end
          end

          # Returns the instance of LevyStrategy for this value, or nil if not found
          def LevyStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyStrategy.ALL.find { |v| v.value == value }
          end

          def LevyStrategy.ALL
            @@all ||= [LevyStrategy.minimum, LevyStrategy.average, LevyStrategy.maximum]
          end

          def LevyStrategy.minimum
            @@_minimum ||= LevyStrategy.new('minimum')
          end

          def LevyStrategy.average
            @@_average ||= LevyStrategy.new('average')
          end

          def LevyStrategy.maximum
            @@_maximum ||= LevyStrategy.new('maximum')
          end

          def to_hash
            value
          end

        end

        class MeasurementSystem

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MeasurementSystem for this value, creating a new instance for an unknown value
          def MeasurementSystem.apply(value)
            if value.instance_of?(MeasurementSystem)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MeasurementSystem.new(value))
            end
          end

          # Returns the instance of MeasurementSystem for this value, or nil if not found
          def MeasurementSystem.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MeasurementSystem.ALL.find { |v| v.value == value }
          end

          def MeasurementSystem.ALL
            @@all ||= [MeasurementSystem.imperial, MeasurementSystem.metric]
          end

          def MeasurementSystem.imperial
            @@_imperial ||= MeasurementSystem.new('imperial')
          end

          def MeasurementSystem.metric
            @@_metric ||= MeasurementSystem.new('metric')
          end

          def to_hash
            value
          end

        end

        class Reason

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Reason for this value, creating a new instance for an unknown value
          def Reason.apply(value)
            if value.instance_of?(Reason)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Reason.new(value))
            end
          end

          # Returns the instance of Reason for this value, or nil if not found
          def Reason.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Reason.ALL.find { |v| v.value == value }
          end

          def Reason.ALL
            @@all ||= [Reason.prohibited, Reason.restricted, Reason.risk]
          end

          # Absolutely cannot ship
          def Reason.prohibited
            @@_prohibited ||= Reason.new('prohibited')
          end

          # May be able to ship depending on criteria
          def Reason.restricted
            @@_restricted ||= Reason.new('restricted')
          end

          # Known to cause delays at customs
          def Reason.risk
            @@_risk ||= Reason.new('risk')
          end

          def to_hash
            value
          end

        end

        class Role

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Role for this value, creating a new instance for an unknown value
          def Role.apply(value)
            if value.instance_of?(Role)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Role.new(value))
            end
          end

          # Returns the instance of Role for this value, or nil if not found
          def Role.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Role.ALL.find { |v| v.value == value }
          end

          def Role.ALL
            @@all ||= [Role.admin, Role.member]
          end

          def Role.admin
            @@_admin ||= Role.new('admin')
          end

          def Role.member
            @@_member ||= Role.new('member')
          end

          def to_hash
            value
          end

        end

        class RoundingMethod

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingMethod for this value, creating a new instance for an unknown value
          def RoundingMethod.apply(value)
            if value.instance_of?(RoundingMethod)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingMethod.new(value))
            end
          end

          # Returns the instance of RoundingMethod for this value, or nil if not found
          def RoundingMethod.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingMethod.ALL.find { |v| v.value == value }
          end

          def RoundingMethod.ALL
            @@all ||= [RoundingMethod.up, RoundingMethod.down, RoundingMethod.nearest]
          end

          # Round up to the specified rounding.value
          def RoundingMethod.up
            @@_up ||= RoundingMethod.new('up')
          end

          # Round down to the specified rounding.value
          def RoundingMethod.down
            @@_down ||= RoundingMethod.new('down')
          end

          # Round to the nearest specified rounding.value. If equidistant, will round up.
          def RoundingMethod.nearest
            @@_nearest ||= RoundingMethod.new('nearest')
          end

          def to_hash
            value
          end

        end

        class ScheduleExceptionStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ScheduleExceptionStatus for this value, creating a new instance for an unknown value
          def ScheduleExceptionStatus.apply(value)
            if value.instance_of?(ScheduleExceptionStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ScheduleExceptionStatus.new(value))
            end
          end

          # Returns the instance of ScheduleExceptionStatus for this value, or nil if not found
          def ScheduleExceptionStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ScheduleExceptionStatus.ALL.find { |v| v.value == value }
          end

          def ScheduleExceptionStatus.ALL
            @@all ||= [ScheduleExceptionStatus.open, ScheduleExceptionStatus.closed]
          end

          def ScheduleExceptionStatus.open
            @@_open ||= ScheduleExceptionStatus.new('Open')
          end

          def ScheduleExceptionStatus.closed
            @@_closed ||= ScheduleExceptionStatus.new('Closed')
          end

          def to_hash
            value
          end

        end

        class SortDirection

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SortDirection for this value, creating a new instance for an unknown value
          def SortDirection.apply(value)
            if value.instance_of?(SortDirection)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SortDirection.new(value))
            end
          end

          # Returns the instance of SortDirection for this value, or nil if not found
          def SortDirection.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SortDirection.ALL.find { |v| v.value == value }
          end

          def SortDirection.ALL
            @@all ||= [SortDirection.ascending, SortDirection.descending]
          end

          def SortDirection.ascending
            @@_ascending ||= SortDirection.new('ascending')
          end

          def SortDirection.descending
            @@_descending ||= SortDirection.new('descending')
          end

          def to_hash
            value
          end

        end

        class Status

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Status for this value, creating a new instance for an unknown value
          def Status.apply(value)
            if value.instance_of?(Status)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Status.new(value))
            end
          end

          # Returns the instance of Status for this value, or nil if not found
          def Status.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Status.ALL.find { |v| v.value == value }
          end

          def Status.ALL
            @@all ||= [Status.pending, Status.info_received, Status.in_transit, Status.out_for_delivery, Status.attempt_fail, Status.delivered, Status.exception, Status.expired]
          end

          def Status.pending
            @@_pending ||= Status.new('pending')
          end

          def Status.info_received
            @@_info_received ||= Status.new('info_received')
          end

          def Status.in_transit
            @@_in_transit ||= Status.new('in_transit')
          end

          def Status.out_for_delivery
            @@_out_for_delivery ||= Status.new('out_for_delivery')
          end

          def Status.attempt_fail
            @@_attempt_fail ||= Status.new('attempt_fail')
          end

          def Status.delivered
            @@_delivered ||= Status.new('delivered')
          end

          def Status.exception
            @@_exception ||= Status.new('exception')
          end

          def Status.expired
            @@_expired ||= Status.new('expired')
          end

          def to_hash
            value
          end

        end

        class Strategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Strategy for this value, creating a new instance for an unknown value
          def Strategy.apply(value)
            if value.instance_of?(Strategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Strategy.new(value))
            end
          end

          # Returns the instance of Strategy for this value, or nil if not found
          def Strategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Strategy.ALL.find { |v| v.value == value }
          end

          def Strategy.ALL
            @@all ||= [Strategy.range, Strategy.from, Strategy.to]
          end

          # Tightest range
          def Strategy.range
            @@_range ||= Strategy.new('range')
          end

          # Lowest minimum of the ranges
          def Strategy.from
            @@_from ||= Strategy.new('from')
          end

          # Lowest maximum of the ranges
          def Strategy.to
            @@_to ||= Strategy.new('to')
          end

          def to_hash
            value
          end

        end

        class TierStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TierStrategy for this value, creating a new instance for an unknown value
          def TierStrategy.apply(value)
            if value.instance_of?(TierStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TierStrategy.new(value))
            end
          end

          # Returns the instance of TierStrategy for this value, or nil if not found
          def TierStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TierStrategy.ALL.find { |v| v.value == value }
          end

          def TierStrategy.ALL
            @@all ||= [TierStrategy.fastest, TierStrategy.cheapest]
          end

          # Optimize for fastest first, then cheapest
          def TierStrategy.fastest
            @@_fastest ||= TierStrategy.new('fastest')
          end

          # Optimize for cheapest first, then fastest
          def TierStrategy.cheapest
            @@_cheapest ||= TierStrategy.new('cheapest')
          end

          def to_hash
            value
          end

        end

        class UnitOfMeasurement

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfMeasurement for this value, creating a new instance for an unknown value
          def UnitOfMeasurement.apply(value)
            if value.instance_of?(UnitOfMeasurement)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfMeasurement.new(value))
            end
          end

          # Returns the instance of UnitOfMeasurement for this value, or nil if not found
          def UnitOfMeasurement.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfMeasurement.ALL.find { |v| v.value == value }
          end

          def UnitOfMeasurement.ALL
            @@all ||= [UnitOfMeasurement.millimeter, UnitOfMeasurement.centimeter, UnitOfMeasurement.inch, UnitOfMeasurement.foot, UnitOfMeasurement.cubic_inch, UnitOfMeasurement.cubic_meter, UnitOfMeasurement.gram, UnitOfMeasurement.kilogram, UnitOfMeasurement.meter, UnitOfMeasurement.ounce, UnitOfMeasurement.pound]
          end

          # Equivalent to MILLI(METRE).
          def UnitOfMeasurement.millimeter
            @@_millimeter ||= UnitOfMeasurement.new('millimeter')
          end

          # Equivalent to CENTI(METRE).
          def UnitOfMeasurement.centimeter
            @@_centimeter ||= UnitOfMeasurement.new('centimeter')
          end

          # A unit of length equal to 0.01004 m (standard name in).
          def UnitOfMeasurement.inch
            @@_inch ||= UnitOfMeasurement.new('inch')
          end

          # A unit of length equal to 0.3048 m (standard name ft).
          def UnitOfMeasurement.foot
            @@_foot ||= UnitOfMeasurement.new('foot')
          end

          # A unit of volume equal to one cubic inch (in).
          def UnitOfMeasurement.cubic_inch
            @@_cubic_inch ||= UnitOfMeasurement.new('cubic_inch')
          end

          # The metric unit for volume quantities (m).
          def UnitOfMeasurement.cubic_meter
            @@_cubic_meter ||= UnitOfMeasurement.new('cubic_meter')
          end

          # A unit of mass equal to 1 / 1000 kilogram (standard name g).
          def UnitOfMeasurement.gram
            @@_gram ||= UnitOfMeasurement.new('gram')
          end

          # The base unit for mass quantities (kg).
          def UnitOfMeasurement.kilogram
            @@_kilogram ||= UnitOfMeasurement.new('kilogram')
          end

          # The base unit for length quantities (m).
          def UnitOfMeasurement.meter
            @@_meter ||= UnitOfMeasurement.new('meter')
          end

          # A unit of mass equal to 1 / 16 POUND (standard name oz).
          def UnitOfMeasurement.ounce
            @@_ounce ||= UnitOfMeasurement.new('ounce')
          end

          # A unit of mass equal to 453.59237 grams (avoirdupois pound, standard name lb).
          def UnitOfMeasurement.pound
            @@_pound ||= UnitOfMeasurement.new('pound')
          end

          def to_hash
            value
          end

        end

        class UnitOfTime

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfTime for this value, creating a new instance for an unknown value
          def UnitOfTime.apply(value)
            if value.instance_of?(UnitOfTime)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfTime.new(value))
            end
          end

          # Returns the instance of UnitOfTime for this value, or nil if not found
          def UnitOfTime.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfTime.ALL.find { |v| v.value == value }
          end

          def UnitOfTime.ALL
            @@all ||= [UnitOfTime.day, UnitOfTime.hour, UnitOfTime.minute]
          end

          def UnitOfTime.day
            @@_day ||= UnitOfTime.new('day')
          end

          def UnitOfTime.hour
            @@_hour ||= UnitOfTime.new('hour')
          end

          def UnitOfTime.minute
            @@_minute ||= UnitOfTime.new('minute')
          end

          def to_hash
            value
          end

        end

        class UpdatePolicy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdatePolicy for this value, creating a new instance for an unknown value
          def UpdatePolicy.apply(value)
            if value.instance_of?(UpdatePolicy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdatePolicy.new(value))
            end
          end

          # Returns the instance of UpdatePolicy for this value, or nil if not found
          def UpdatePolicy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdatePolicy.ALL.find { |v| v.value == value }
          end

          def UpdatePolicy.ALL
            @@all ||= [UpdatePolicy.auto, UpdatePolicy.queue, UpdatePolicy.discard]
          end

          def UpdatePolicy.auto
            @@_auto ||= UpdatePolicy.new('auto')
          end

          # Queue item update for approval.
          def UpdatePolicy.queue
            @@_queue ||= UpdatePolicy.new('queue')
          end

          def UpdatePolicy.discard
            @@_discard ||= UpdatePolicy.new('discard')
          end

          def to_hash
            value
          end

        end

        class ValueAddedService

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ValueAddedService for this value, creating a new instance for an unknown value
          def ValueAddedService.apply(value)
            if value.instance_of?(ValueAddedService)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ValueAddedService.new(value))
            end
          end

          # Returns the instance of ValueAddedService for this value, or nil if not found
          def ValueAddedService.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ValueAddedService.ALL.find { |v| v.value == value }
          end

          def ValueAddedService.ALL
            @@all ||= [ValueAddedService.hazardous_material]
          end

          # See https://en.wikipedia.org/wiki/ORM-D
          def ValueAddedService.hazardous_material
            @@_hazardous_material ||= ValueAddedService.new('Hazardous Material')
          end

          def to_hash
            value
          end

        end

        class Visibility

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Visibility for this value, creating a new instance for an unknown value
          def Visibility.apply(value)
            if value.instance_of?(Visibility)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Visibility.new(value))
            end
          end

          # Returns the instance of Visibility for this value, or nil if not found
          def Visibility.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Visibility.ALL.find { |v| v.value == value }
          end

          def Visibility.ALL
            @@all ||= [Visibility.public, Visibility.private]
          end

          def Visibility.public
            @@_public ||= Visibility.new('public')
          end

          def Visibility.private
            @@_private ||= Visibility.new('private')
          end

          def to_hash
            value
          end

        end

        class Address

          attr_reader :contact, :location

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contact, :location], 'Address')
            @contact = (x = opts.delete(:contact); x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x))
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Address.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contact => contact.to_hash,
              :location => location.to_hash
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost of the service
        class AtCost < RuleOutcome

          attr_reader :at_cost

          def initialize(incoming={})
            super(:name => RuleOutcome::Types::AT_COST)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:at_cost], 'AtCost')
            @at_cost = HttpClient::Preconditions.assert_class('at_cost', opts.delete(:at_cost), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AtCost.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :at_cost => at_cost
            }
          end

        end

        # An attribute represents applicable item data made available on specific UI
        # elements (e.g. require 'Brand')
        class Attribute

          attr_reader :name, :options, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :options], 'Attribute')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Attribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :options => options.to_hash,
              :label => label
            }
          end

        end

        # Attribtue metadata represents additional item data not configured in other top
        # level fields
        class AttributeMetadata

          attr_reader :key, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :value], 'AttributeMetadata')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :value => value
            }
          end

        end

        # Retrieve journaled history of an attribute
        class AttributeVersion

          attr_reader :id, :timestamp, :type, :attribute

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :attribute], 'AttributeVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @attribute = (x = opts.delete(:attribute); x.is_a?(::Io::Flow::V0::Models::Attribute) ? x : ::Io::Flow::V0::Models::Attribute.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :attribute => attribute.to_hash
            }
          end

        end

        class AuthenticationForm

          attr_reader :email, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email, :password], 'AuthenticationForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class Authorization

          attr_reader :id, :reference, :card, :amount, :currency, :metadata, :shipping, :details

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :card, :amount, :currency, :metadata, :details], 'Authorization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::CardReference) ? x : ::Io::Flow::V0::Models::CardReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @metadata = HttpClient::Preconditions.assert_class('metadata', opts.delete(:metadata), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h }
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
            @details = (x = opts.delete(:details); x.is_a?(::Io::Flow::V0::Models::AuthorizationDetails) ? x : ::Io::Flow::V0::Models::AuthorizationDetails.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Authorization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :card => card.to_hash,
              :amount => amount,
              :currency => currency,
              :metadata => metadata,
              :shipping => shipping.nil? ? nil : shipping.to_hash,
              :details => details.to_hash
            }
          end

        end

        # Represents a declined authorization
        class AuthorizationDetailsDecline < AuthorizationDetails

          attr_reader :reason, :avs, :cvv

          def initialize(incoming={})
            super(:name => AuthorizationDetails::Types::AUTHORIZATION_DETAILS_DECLINE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:reason], 'AuthorizationDetailsDecline')
            @reason = HttpClient::Preconditions.assert_class('reason', opts.delete(:reason), String)
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDetailsDecline.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :reason => reason,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        # Represents a successful authorization
        class AuthorizationDetailsSuccess < AuthorizationDetails

          attr_reader :avs, :cvv

          def initialize(incoming={})
            super(:name => AuthorizationDetails::Types::AUTHORIZATION_DETAILS_SUCCESS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDetailsSuccess.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class AuthorizationForm

          attr_reader :reference, :token, :amount, :currency, :cvv, :metadata, :shipping

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :amount, :currency], 'AuthorizationForm')
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h })
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :reference => reference,
              :token => token,
              :amount => amount,
              :currency => currency,
              :cvv => cvv,
              :metadata => metadata.nil? ? nil : metadata,
              :shipping => shipping.nil? ? nil : shipping.to_hash
            }
          end

        end

        class AuthorizationReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'AuthorizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class AuthorizationVersion

          attr_reader :id, :timestamp, :type, :authorization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :authorization], 'AuthorizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::Authorization) ? x : ::Io::Flow::V0::Models::Authorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :authorization => authorization.to_hash
            }
          end

        end

        # Representation of a service level available at a center, including misc
        # attributes. Only ID for now, more attributes will be added in the future.
        class AvailableService

          attr_reader :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service], 'AvailableService')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailableService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service
            }
          end

        end

        # Represents data from the address verification check
        class Avs

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Avs')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Avs.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        # Represents second step of two-step purchase of Flow services.
        class Booking < ExpandableBooking

          attr_reader :id, :number, :shipments

          def initialize(incoming={})
            super(:name => ExpandableBooking::Types::BOOKING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :shipments], 'Booking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @shipments = HttpClient::Preconditions.assert_class('shipments', opts.delete(:shipments), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentReference) ? x : ::Io::Flow::V0::Models::ShipmentReference.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Booking.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :number => number,
              :shipments => shipments.map { |o| o.to_hash }
            }
          end

        end

        # Represents second step of two-step purchase of Flow services.
        class BookingForm

          attr_reader :number, :quote, :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quote, :options], 'BookingForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quote = HttpClient::Preconditions.assert_class('quote', opts.delete(:quote), String)
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| HttpClient::Preconditions.assert_class('options', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quote => quote,
              :options => options
            }
          end

        end

        class BookingReference < ExpandableBooking

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableBooking::Types::BOOKING_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'BookingReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class BookingVersion

          attr_reader :id, :timestamp, :type, :booking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :booking], 'BookingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @booking = (x = opts.delete(:booking); x.is_a?(::Io::Flow::V0::Models::ExpandableBooking) ? x : ::Io::Flow::V0::Models::ExpandableBooking.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :booking => booking.to_hash
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class Capture

          attr_reader :id, :reference, :authorization, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :authorization, :amount, :currency], 'Capture')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Capture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :authorization => authorization.to_hash,
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class CaptureForm

          attr_reader :reference, :authorization_id, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authorization_id], 'CaptureForm')
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @authorization_id = HttpClient::Preconditions.assert_class('authorization_id', opts.delete(:authorization_id), String)
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :reference => reference,
              :authorization_id => authorization_id,
              :amount => amount,
              :currency => currency
            }
          end

        end

        class CaptureVersion

          attr_reader :id, :timestamp, :type, :capture

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :capture], 'CaptureVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :capture => capture.to_hash
            }
          end

        end

        # Card represents the metadata about a secure, tokenized card. The card 'id' is
        # a unique, cryptographically secure token by which this card can be identified
        # in the future.
        class Card

          attr_reader :id, :type, :expiration, :last4, :name, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :expiration, :last4], 'Card')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CardType) ? x : ::Io::Flow::V0::Models::CardType.apply(x))
            @expiration = (x = opts.delete(:expiration); x.is_a?(::Io::Flow::V0::Models::Expiration) ? x : ::Io::Flow::V0::Models::Expiration.new(x))
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Card.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :expiration => expiration.to_hash,
              :last4 => last4,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CardForm

          attr_reader :number, :expiration_month, :expiration_year, :name, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :expiration_month, :expiration_year], 'CardForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @expiration_month = HttpClient::Preconditions.assert_class('expiration_month', opts.delete(:expiration_month), Integer)
            @expiration_year = HttpClient::Preconditions.assert_class('expiration_year', opts.delete(:expiration_year), Integer)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :expiration_month => expiration_month,
              :expiration_year => expiration_year,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CardReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CardReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CardVersion

          attr_reader :id, :timestamp, :type, :card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :card], 'CardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :card => card.to_hash
            }
          end

        end

        # Partner that actually take a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class Carrier < ExpandableCarrier

          attr_reader :id, :name, :facilities, :visibility

          def initialize(incoming={})
            super(:name => ExpandableCarrier::Types::CARRIER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :facilities, :visibility], 'Carrier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @facilities = HttpClient::Preconditions.assert_class('facilities', opts.delete(:facilities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)) }
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Carrier.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :name => name,
              :facilities => facilities.map { |o| o.to_hash },
              :visibility => visibility.value
            }
          end

        end

        # carrier_account an organization has with a carrier, including credentials. A
        # carrier can have multiple carrier_accounts with a single carrier, each with
        # their own set of credentials. This represents the many-to-many relationship
        # between organizations and carriers.
        class CarrierAccount < ExpandableCarrierAccount

          attr_reader :id, :carrier, :name, :credentials

          def initialize(incoming={})
            super(:name => ExpandableCarrierAccount::Types::CARRIER_ACCOUNT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'CarrierAccount')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @credentials = (x = opts.delete(:credentials); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Credentials) ? x : ::Io::Flow::V0::Models::Credentials.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccount.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name,
              :credentials => credentials.nil? ? nil : credentials.to_hash
            }
          end

        end

        class CarrierAccountForm

          attr_reader :carrier, :name, :credentials

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:carrier], 'CarrierAccountForm')
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @credentials = (x = opts.delete(:credentials); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Credentials) ? x : ::Io::Flow::V0::Models::Credentials.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :carrier => carrier,
              :name => name,
              :credentials => credentials.nil? ? nil : credentials.to_hash
            }
          end

        end

        class CarrierAccountReference < ExpandableCarrierAccount

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableCarrierAccount::Types::CARRIER_ACCOUNT_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierAccountReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class CarrierAccountVersion

          attr_reader :id, :timestamp, :type, :carrier_account

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :carrier_account], 'CarrierAccountVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @carrier_account = (x = opts.delete(:carrier_account); x.is_a?(::Io::Flow::V0::Models::ExpandableCarrierAccount) ? x : ::Io::Flow::V0::Models::ExpandableCarrierAccount.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :carrier_account => carrier_account.to_hash
            }
          end

        end

        # Partner that actually take a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class CarrierForm

          attr_reader :name, :facilities, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'CarrierForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @facilities = (x = opts.delete(:facilities); x.nil? ? nil : HttpClient::Preconditions.assert_class('facilities', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)) })
            @visibility = (x = opts.delete(:visibility); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :facilities => facilities.nil? ? nil : facilities.map { |o| o.to_hash },
              :visibility => visibility.nil? ? nil : visibility.value
            }
          end

        end

        class CarrierReference < ExpandableCarrier

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableCarrier::Types::CARRIER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class CarrierVersion

          attr_reader :id, :timestamp, :type, :carrier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :carrier], 'CarrierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::ExpandableCarrier) ? x : ::Io::Flow::V0::Models::ExpandableCarrier.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :carrier => carrier.to_hash
            }
          end

        end

        class Catalog

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'Catalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Catalog.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CatalogItemDocument < Document

          attr_reader :number, :name, :categories, :experiences, :attributes

          def initialize(incoming={})
            super(:name => Document::Types::CATALOG_ITEM_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :categories, :experiences, :attributes], 'CatalogItemDocument')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @experiences = HttpClient::Preconditions.assert_class('experiences', opts.delete(:experiences), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DocumentAttribute) ? x : ::Io::Flow::V0::Models::DocumentAttribute.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :number => number,
              :name => name,
              :categories => categories,
              :experiences => experiences.map { |o| o.to_hash },
              :attributes => attributes.map { |o| o.to_hash }
            }
          end

        end

        class CatalogVersion

          attr_reader :id, :timestamp, :type, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :catalog], 'CatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :catalog => catalog.to_hash
            }
          end

        end

        class CategorySummary

          attr_reader :name, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:count], 'CategorySummary')
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CategorySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :count => count
            }
          end

        end

        # Represents a facility capable of fulfilling a shipment
        class Center < ExpandableCenter

          attr_reader :id, :capabilities, :address, :name, :schedule, :services, :timezone

          def initialize(incoming={})
            super(:name => ExpandableCenter::Types::CENTER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :capabilities, :address, :name, :schedule, :services, :timezone], 'Center')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @capabilities = HttpClient::Preconditions.assert_class('capabilities', opts.delete(:capabilities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Capability) ? x : ::Io::Flow::V0::Models::Capability.apply(x)) }
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Center.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :capabilities => capabilities.map { |o| o.value },
              :address => address.to_hash,
              :name => name,
              :schedule => schedule.to_hash,
              :services => services.map { |o| o.to_hash },
              :timezone => timezone
            }
          end

        end

        class CenterForm

          attr_reader :capabilities, :address, :name, :schedule, :services, :timezone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:capabilities, :address, :name, :schedule, :services, :timezone], 'CenterForm')
            @capabilities = HttpClient::Preconditions.assert_class('capabilities', opts.delete(:capabilities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Capability) ? x : ::Io::Flow::V0::Models::Capability.apply(x)) }
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :capabilities => capabilities.map { |o| o.value },
              :address => address.to_hash,
              :name => name,
              :schedule => schedule.to_hash,
              :services => services.map { |o| o.to_hash },
              :timezone => timezone
            }
          end

        end

        class CenterReference < ExpandableCenter

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableCenter::Types::CENTER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CenterReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class CenterVersion

          attr_reader :id, :timestamp, :type, :center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :center], 'CenterVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::ExpandableCenter) ? x : ::Io::Flow::V0::Models::ExpandableCenter.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :center => center.to_hash
            }
          end

        end

        # Representation of information indicating landed cost and how it was derived
        class Checkout

          attr_reader :id, :deliveries, :prices, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :deliveries, :prices, :total], 'Checkout')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x)) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Checkout.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :deliveries => deliveries.map { |o| o.to_hash },
              :prices => prices.map { |o| o.to_hash },
              :total => total.to_hash
            }
          end

        end

        class CheckoutForm

          attr_reader :destination, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :items], 'CheckoutForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Line) ? x : ::Io::Flow::V0::Models::Line.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CheckoutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        # The actual value of the API token. This is modeled as a separate resource as
        # it is fetched only on demand.
        class Cleartext

          attr_reader :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value], 'Cleartext')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cleartext.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value
            }
          end

        end

        class Component

          attr_reader :adjustments, :levies

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:adjustments, :levies], 'Component')
            @adjustments = HttpClient::Preconditions.assert_class('adjustments', opts.delete(:adjustments), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AdjustmentType) ? x : ::Io::Flow::V0::Models::AdjustmentType.apply(x)) }
            @levies = HttpClient::Preconditions.assert_class('levies', opts.delete(:levies), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Levy) ? x : ::Io::Flow::V0::Models::Levy.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Component.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :adjustments => adjustments.map { |o| o.value },
              :levies => levies.map { |o| o.value }
            }
          end

        end

        # Defines structured fields for a contact person. Typically used for specifying
        # contact person for an account, shipment, or organization representative
        class Contact

          attr_reader :name, :email, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Contact')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Contact.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :email => email,
              :phone => phone
            }
          end

        end

        class Country

          attr_reader :name, :iso_3166_2, :iso_3166_3, :measurement_system, :default_currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_3166_2, :iso_3166_3, :measurement_system], 'Country')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_3166_2 = HttpClient::Preconditions.assert_class('iso_3166_2', opts.delete(:iso_3166_2), String)
            @iso_3166_3 = HttpClient::Preconditions.assert_class('iso_3166_3', opts.delete(:iso_3166_3), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
            @default_currency = (x = opts.delete(:default_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Country.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_3166_2 => iso_3166_2,
              :iso_3166_3 => iso_3166_3,
              :measurement_system => measurement_system.value,
              :default_currency => default_currency
            }
          end

        end

        # ISO 4217 3-character currency code. See http://www.xe.com/iso4217.php
        class Currency

          attr_reader :name, :iso_4217_3

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_4217_3], 'Currency')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_4217_3 = HttpClient::Preconditions.assert_class('iso_4217_3', opts.delete(:iso_4217_3), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Currency.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_4217_3 => iso_4217_3
            }
          end

        end

        # Customs-related form information that need to be filled, either by Flow based
        # on the customer's setup, or manually by the customer through the API
        class Customs

          attr_reader :signer, :commercial_term

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:signer, :commercial_term], 'Customs')
            @signer = HttpClient::Preconditions.assert_class('signer', opts.delete(:signer), String)
            @commercial_term = (x = opts.delete(:commercial_term); x.is_a?(::Io::Flow::V0::Models::CommercialTerm) ? x : ::Io::Flow::V0::Models::CommercialTerm.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Customs.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :signer => signer,
              :commercial_term => commercial_term.value
            }
          end

        end

        # Represents data from the card verification number check
        class Cvv

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Cvv')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cvv.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        class DatetimeRange

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DatetimeRange')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DatetimeRange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class Delivery < ExpandableDelivery

          attr_reader :id, :items, :options

          def initialize(incoming={})
            super(:name => ExpandableDelivery::Types::DELIVERY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :options], 'Delivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Option) ? x : ::Io::Flow::V0::Models::Option.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Delivery.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash },
              :options => options.map { |o| o.to_hash }
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class DeliveryForm

          attr_reader :quote, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quote, :items, :destination], 'DeliveryForm')
            @quote = HttpClient::Preconditions.assert_class('quote', opts.delete(:quote), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :quote => quote,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        class DeliveryReference < ExpandableDelivery

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableDelivery::Types::DELIVERY_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'DeliveryReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class DeliveryVersion

          attr_reader :id, :timestamp, :type, :delivery

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery], 'DeliveryVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery = (x = opts.delete(:delivery); x.is_a?(::Io::Flow::V0::Models::ExpandableDelivery) ? x : ::Io::Flow::V0::Models::ExpandableDelivery.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery => delivery.to_hash
            }
          end

        end

        class DeliveryWindow

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DeliveryWindow')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class DeminimusSimple < Deminimus

          attr_reader :value, :currency, :components, :minimum

          def initialize(incoming={})
            super(:name => Deminimus::Types::DEMINIMUS_SIMPLE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :currency, :components, :minimum], 'DeminimusSimple')
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @minimum = HttpClient::Preconditions.assert_class('minimum', HttpClient::Helper.to_big_decimal(opts.delete(:minimum)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeminimusSimple.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :value => value,
              :currency => currency,
              :components => components.map { |o| o.value },
              :minimum => minimum
            }
          end

        end

        # Credentials used to communicate with DHL on behalf of client organization.
        class DhlCredentials < Credentials

          attr_reader :account_number, :site_id

          def initialize(incoming={})
            super(:name => Credentials::Types::DHL_CREDENTIALS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:account_number, :site_id], 'DhlCredentials')
            @account_number = HttpClient::Preconditions.assert_class('account_number', opts.delete(:account_number), String)
            @site_id = HttpClient::Preconditions.assert_class('site_id', opts.delete(:site_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DhlCredentials.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :account_number => account_number,
              :site_id => site_id
            }
          end

        end

        class Dimension

          attr_reader :type, :depth, :length, :weight, :width

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'Dimension')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::DimensionType) ? x : ::Io::Flow::V0::Models::DimensionType.apply(x))
            @depth = (x = opts.delete(:depth); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @length = (x = opts.delete(:length); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @width = (x = opts.delete(:width); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimension.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :depth => depth.nil? ? nil : depth.to_hash,
              :length => length.nil? ? nil : length.to_hash,
              :weight => weight.nil? ? nil : weight.to_hash,
              :width => width.nil? ? nil : width.to_hash
            }
          end

        end

        # Defines elements of a localized cost available for display (e.g on a localized
        # product page or checkout)
        class Display

          attr_reader :id, :key, :name, :component, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name, :component, :experience], 'Display')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @component = (x = opts.delete(:component); x.is_a?(::Io::Flow::V0::Models::Component) ? x : ::Io::Flow::V0::Models::Component.new(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Display.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :component => component.to_hash,
              :experience => experience.to_hash
            }
          end

        end

        class DisplayForm

          attr_reader :name, :component, :experience_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :component, :experience_id], 'DisplayForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @component = (x = opts.delete(:component); x.is_a?(::Io::Flow::V0::Models::Component) ? x : ::Io::Flow::V0::Models::Component.new(x))
            @experience_id = HttpClient::Preconditions.assert_class('experience_id', opts.delete(:experience_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DisplayForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :component => component.to_hash,
              :experience_id => experience_id
            }
          end

        end

        class DisplayVersion

          attr_reader :id, :timestamp, :type, :display

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :display], 'DisplayVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @display = (x = opts.delete(:display); x.is_a?(::Io::Flow::V0::Models::Display) ? x : ::Io::Flow::V0::Models::Display.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DisplayVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :display => display.to_hash
            }
          end

        end

        class DocumentAttribute

          attr_reader :name, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :value], 'DocumentAttribute')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DocumentAttribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :value => value
            }
          end

        end

        # Represents a simple model of duties that apply to a given item / trade lane.
        class Duty

          attr_reader :rate, :components, :deminimus

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :components], 'Duty')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimus = (x = opts.delete(:deminimus); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimus) ? x : ::Io::Flow::V0::Models::Deminimus.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimus => deminimus.nil? ? nil : deminimus.to_hash
            }
          end

        end

        # Represents the successful response of an email verification token. We return
        # the email address in this case to allow the UI to display which email address
        # was verified.
        class EmailVerification

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'EmailVerification')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailVerification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        # Represents an error of some sort (e.g. invalid input). Each error will contain
        # a code and a specific message describing the failure.
        class Error

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Error')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Error.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        # Range of time given a from and to number and the unit. For example: 1-4 hours
        # or 4-7 days
        class EstimatedWindow

          attr_reader :from, :to, :unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to, :unit], 'EstimatedWindow')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EstimatedWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :unit => unit.value
            }
          end

        end

        class Event

          attr_reader :id, :label, :location, :status, :timestamp, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :label, :location, :status, :timestamp], 'Event')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @label = (x = opts.delete(:label); x.is_a?(::Io::Flow::V0::Models::LabelSummary) ? x : ::Io::Flow::V0::Models::LabelSummary.new(x))
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::ExpandableLocation) ? x : ::Io::Flow::V0::Models::ExpandableLocation.from_json(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Event.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :label => label.to_hash,
              :location => location.to_hash,
              :status => status.value,
              :timestamp => timestamp,
              :description => description
            }
          end

        end

        class EventForm

          attr_reader :label_id, :timestamp, :status, :description, :location

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label_id, :timestamp, :status], 'EventForm')
            @label_id = HttpClient::Preconditions.assert_class('label_id', opts.delete(:label_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @location = (x = opts.delete(:location); x.nil? ? nil : HttpClient::Preconditions.assert_class('location', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EventForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label_id => label_id,
              :timestamp => timestamp,
              :status => status.value,
              :description => description,
              :location => location
            }
          end

        end

        class EventSummary

          attr_reader :id, :status, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :timestamp], 'EventSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EventSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :timestamp => timestamp
            }
          end

        end

        class EventVersion

          attr_reader :id, :timestamp, :type, :event

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :event], 'EventVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @event = (x = opts.delete(:event); x.is_a?(::Io::Flow::V0::Models::EventSummary) ? x : ::Io::Flow::V0::Models::EventSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EventVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :event => event.to_hash
            }
          end

        end

        # Represents an exception to the schedule of a location.
        class Exception

          attr_reader :type, :datetime_range

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :datetime_range], 'Exception')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExceptionType) ? x : ::Io::Flow::V0::Models::ExceptionType.apply(x))
            @datetime_range = (x = opts.delete(:datetime_range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Exception.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :datetime_range => datetime_range.to_hash
            }
          end

        end

        # Properties that define a customized local experience for a given country
        class Experience

          attr_reader :id, :key, :country, :currency, :language, :measurement_system, :name, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :country, :currency, :language, :measurement_system, :name, :subcatalog], 'Experience')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = HttpClient::Preconditions.assert_class('measurement_system', opts.delete(:measurement_system), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Experience.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system,
              :name => name,
              :subcatalog => subcatalog.to_hash
            }
          end

        end

        class ExperienceForm

          attr_reader :country, :name, :currency, :language, :measurement_system, :subcatalog_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :name], 'ExperienceForm')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @measurement_system = (x = opts.delete(:measurement_system); x.nil? ? nil : HttpClient::Preconditions.assert_class('measurement_system', x, String))
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country,
              :name => name,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class ExperienceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ExperienceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Some important fields related to experiences used in various APIs
        class ExperienceSummary

          attr_reader :id, :key, :name, :currency, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name], 'ExperienceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :currency => currency,
              :country => country
            }
          end

        end

        class ExperienceVersion

          attr_reader :id, :timestamp, :type, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :experience], 'ExperienceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::Experience) ? x : ::Io::Flow::V0::Models::Experience.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :experience => experience.to_hash
            }
          end

        end

        # The month and year at which a card expires
        class Expiration

          attr_reader :month, :year

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:month, :year], 'Expiration')
            @month = HttpClient::Preconditions.assert_class('month', opts.delete(:month), Integer)
            @year = HttpClient::Preconditions.assert_class('year', opts.delete(:year), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Expiration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :month => month,
              :year => year
            }
          end

        end

        # Credentials used to communicate with Fedex on behalf of client organization.
        class FedexCredentials < Credentials

          attr_reader :account_number, :meter_number, :username_password, :smartpost_hub_id

          def initialize(incoming={})
            super(:name => Credentials::Types::FEDEX_CREDENTIALS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:account_number, :meter_number, :username_password], 'FedexCredentials')
            @account_number = HttpClient::Preconditions.assert_class('account_number', opts.delete(:account_number), String)
            @meter_number = HttpClient::Preconditions.assert_class('meter_number', opts.delete(:meter_number), String)
            @username_password = (x = opts.delete(:username_password); x.is_a?(::Io::Flow::V0::Models::UsernamePassword) ? x : ::Io::Flow::V0::Models::UsernamePassword.new(x))
            @smartpost_hub_id = (x = opts.delete(:smartpost_hub_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('smartpost_hub_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FedexCredentials.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :account_number => account_number,
              :meter_number => meter_number,
              :username_password => username_password.to_hash,
              :smartpost_hub_id => smartpost_hub_id
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is pre-defined flat rate
        class FlatRate < RuleOutcome

          attr_reader :price

          def initialize(incoming={})
            super(:name => RuleOutcome::Types::FLAT_RATE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'FlatRate')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlatRate.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        # Flow internal model containing an item's origin and classified harmonization
        # code (6 digit)
        class Flow

          attr_reader :origin, :function, :hs6

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @function = (x = opts.delete(:function); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExpandableFunction) ? x : ::Io::Flow::V0::Models::ExpandableFunction.from_json(x)))
            @hs6 = (x = opts.delete(:hs6); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs6', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Flow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin => origin,
              :function => function.nil? ? nil : function.to_hash,
              :hs6 => hs6
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is free
        class FreeShipping < RuleOutcome

          attr_reader :free_shipping

          def initialize(incoming={})
            super(:name => RuleOutcome::Types::FREE_SHIPPING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:free_shipping], 'FreeShipping')
            @free_shipping = HttpClient::Preconditions.assert_class('free_shipping', opts.delete(:free_shipping), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FreeShipping.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :free_shipping => free_shipping
            }
          end

        end

        # Prioritized calculation yielding a localized price (also allows for custom
        # defined price function)
        class Function < ExpandableFunction

          attr_reader :id, :subcatalog_id, :key, :name, :position, :presets, :code, :q

          def initialize(incoming={})
            super(:name => ExpandableFunction::Types::FUNCTION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :subcatalog_id, :key, :name, :position, :presets, :code], 'Function')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @presets = (x = opts.delete(:presets); x.is_a?(::Io::Flow::V0::Models::Presets) ? x : ::Io::Flow::V0::Models::Presets.new(x))
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Function.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :subcatalog_id => subcatalog_id,
              :key => key,
              :name => name,
              :position => position,
              :presets => presets.to_hash,
              :code => code,
              :q => q
            }
          end

        end

        class FunctionForm

          attr_reader :name, :subcatalog_id, :q, :presets, :code, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :subcatalog_id], 'FunctionForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            @presets = (x = opts.delete(:presets); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Presets) ? x : ::Io::Flow::V0::Models::Presets.new(x)))
            @code = (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :subcatalog_id => subcatalog_id,
              :q => q,
              :presets => presets.nil? ? nil : presets.to_hash,
              :code => code,
              :position => position
            }
          end

        end

        class FunctionReference < ExpandableFunction

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableFunction::Types::FUNCTION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'FunctionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class FunctionSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'FunctionSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class FunctionVersion

          attr_reader :id, :timestamp, :type, :function

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :function], 'FunctionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @function = (x = opts.delete(:function); x.is_a?(::Io::Flow::V0::Models::Function) ? x : ::Io::Flow::V0::Models::Function.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :function => function.to_hash
            }
          end

        end

        class HarmonizationDocument < Document

          attr_reader :code, :categories, :origin

          def initialize(incoming={})
            super(:name => Document::Types::HARMONIZATION_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :categories], 'HarmonizationDocument')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CategorySummary) ? x : ::Io::Flow::V0::Models::CategorySummary.new(x)) }
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :code => code,
              :categories => categories.map { |o| o.to_hash },
              :origin => origin
            }
          end

        end

        # Organization level settings.
        class HarmonizationSettings

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = (x = opts.delete(:duty_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
            @tax_strategy = (x = (x = opts.delete(:tax_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.value,
              :tax_strategy => tax_strategy.value
            }
          end

        end

        class HarmonizationSettingsForm

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = opts.delete(:duty_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
            @tax_strategy = (x = opts.delete(:tax_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.nil? ? nil : duty_strategy.value,
              :tax_strategy => tax_strategy.nil? ? nil : tax_strategy.value
            }
          end

        end

        # A harmonized item stores explicit information about this item for the purposes
        # of harmonization / classification. The harmonization process begins by
        # creating a harmonized item; this kicks off the internal processes. Once
        # assigned, codes will be available via the hs6 and hs10 resources
        class HarmonizedItem

          attr_reader :id, :number, :name, :description, :categories, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :name], 'HarmonizedItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @metadata = HttpClient::Preconditions.assert_class('metadata', (x = opts.delete(:metadata); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :name => name,
              :description => description,
              :categories => categories,
              :metadata => metadata
            }
          end

        end

        # Used to specifically set an item's duty rate for a given trade lane.
        class HarmonizedItemDuty

          attr_reader :id, :item, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :rate], 'HarmonizedItemDuty')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDuty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyForm

          attr_reader :number, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :origin, :destination, :rate], 'HarmonizedItemDutyForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyVersion

          attr_reader :id, :timestamp, :type, :harmonized_item_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item_duty], 'HarmonizedItemDutyVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item_duty = (x = opts.delete(:harmonized_item_duty); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemDuty) ? x : ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item_duty => harmonized_item_duty.to_hash
            }
          end

        end

        class HarmonizedItemForm

          attr_reader :name, :number, :categories, :description, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :number], 'HarmonizedItemForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :number => number,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :metadata => metadata.nil? ? nil : metadata
            }
          end

        end

        class HarmonizedItemPutForm

          attr_reader :name, :categories, :description, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'HarmonizedItemPutForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :metadata => metadata.nil? ? nil : metadata
            }
          end

        end

        class HarmonizedItemReference

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'HarmonizedItemReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class HarmonizedItemVersion

          attr_reader :id, :timestamp, :type, :harmonized_item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item], 'HarmonizedItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item = (x = opts.delete(:harmonized_item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItem) ? x : ::Io::Flow::V0::Models::HarmonizedItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item => harmonized_item.to_hash
            }
          end

        end

        class Healthcheck

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Healthcheck')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Healthcheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # The (Harmonized System) HS-10 code assigned to an item with a given
        # origin/destination pair.
        class Hs10

          attr_reader :id, :item, :origin, :destination, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :code], 'Hs10')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :code => code
            }
          end

        end

        class Hs10Version

          attr_reader :id, :timestamp, :type, :hs10

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs10], 'Hs10Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs10 = (x = opts.delete(:hs10); x.is_a?(::Io::Flow::V0::Models::Hs10) ? x : ::Io::Flow::V0::Models::Hs10.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs10 => hs10.to_hash
            }
          end

        end

        # The (Harmonized System) HS-6 code assigned to an item.
        class Hs6

          attr_reader :id, :item, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :code], 'Hs6')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :code => code
            }
          end

        end

        class Hs6Version

          attr_reader :id, :timestamp, :type, :hs6

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs6], 'Hs6Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs6 = (x = opts.delete(:hs6); x.is_a?(::Io::Flow::V0::Models::Hs6) ? x : ::Io::Flow::V0::Models::Hs6.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs6 => hs6.to_hash
            }
          end

        end

        # The URL to an image, with optional tags. Flow Commerce primarily uses images
        # to enhance the administrative tools (e.g. showing an item image in console)
        class Image

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'Image')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = HttpClient::Preconditions.assert_class('tags', (x = opts.delete(:tags); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Image.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags
            }
          end

        end

        # Image form defines the data needed to create an image
        class ImageForm

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'ImageForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = (x = opts.delete(:tags); x.nil? ? nil : HttpClient::Preconditions.assert_class('tags', x, Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImageForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags.nil? ? nil : tags
            }
          end

        end

        # An invitation via email to a user to join this organization. The user will
        # then walk through a user login/registration process and will immediately
        # become a member of the organization.
        class Invitation

          attr_reader :id, :organization, :email, :name, :role, :expiration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :email, :name, :role, :expiration], 'Invitation')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expiration)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Invitation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :email => email,
              :name => name.to_hash,
              :role => role.value,
              :expiration => expiration
            }
          end

        end

        class InvitationAcceptsForm

          attr_reader :user_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:user_id], 'InvitationAcceptsForm')
            @user_id = HttpClient::Preconditions.assert_class('user_id', opts.delete(:user_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationAcceptsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :user_id => user_id
            }
          end

        end

        class InvitationForm

          attr_reader :organization, :email, :name, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :email], 'InvitationForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :role => role.value
            }
          end

        end

        class InvitationVersion

          attr_reader :id, :timestamp, :type, :invitation

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :invitation], 'InvitationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @invitation = (x = opts.delete(:invitation); x.is_a?(::Io::Flow::V0::Models::Invitation) ? x : ::Io::Flow::V0::Models::Invitation.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :invitation => invitation.to_hash
            }
          end

        end

        # The Flow item defines a specific item that can be purchased by a consumer. For
        # many clients, this will map to a Sku.
        class Item

          attr_reader :id, :number, :locale, :name, :price, :categories, :description, :attributes, :dimensions, :images, :flow, :local

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :locale, :name, :price], 'Item')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AttributeMetadata) ? x : ::Io::Flow::V0::Models::AttributeMetadata.new(x)) }
            @dimensions = HttpClient::Preconditions.assert_class('dimensions', (x = opts.delete(:dimensions); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)) }
            @images = HttpClient::Preconditions.assert_class('images', (x = opts.delete(:images); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)) }
            @flow = (x = opts.delete(:flow); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Flow) ? x : ::Io::Flow::V0::Models::Flow.new(x)))
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Local) ? x : ::Io::Flow::V0::Models::Local.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :locale => locale,
              :name => name,
              :price => price.to_hash,
              :categories => categories,
              :description => description,
              :attributes => attributes.map { |o| o.to_hash },
              :dimensions => dimensions.map { |o| o.to_hash },
              :images => images.map { |o| o.to_hash },
              :flow => flow.nil? ? nil : flow.to_hash,
              :local => local.nil? ? nil : local.to_hash
            }
          end

        end

        # The item form defines the data required to create an item.
        class ItemForm

          attr_reader :number, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :locale, :name, :currency, :price], 'ItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AttributeMetadata) ? x : ::Io::Flow::V0::Models::AttributeMetadata.new(x)) })
            @dimensions = (x = opts.delete(:dimensions); x.nil? ? nil : HttpClient::Preconditions.assert_class('dimensions', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)) })
            @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageForm) ? x : ::Io::Flow::V0::Models::ImageForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes.map { |o| o.to_hash },
              :dimensions => dimensions.nil? ? nil : dimensions.map { |o| o.to_hash },
              :images => images.nil? ? nil : images.map { |o| o.to_hash }
            }
          end

        end

        # Represents metadata about the customer's line item product
        class ItemSummary

          attr_reader :number, :categories, :dimensions, :price

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :price], 'ItemSummary')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @dimensions = HttpClient::Preconditions.assert_class('dimensions', (x = opts.delete(:dimensions); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)) }
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :categories => categories,
              :dimensions => dimensions.map { |o| o.to_hash },
              :price => price.to_hash
            }
          end

        end

        class ItemVersion

          attr_reader :id, :timestamp, :type, :item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item], 'ItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item => item.to_hash
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class Label

          attr_reader :id, :tracking, :status, :carrier, :tracking_number, :timestamp, :delivery_estimate, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number, :timestamp], 'Label')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Label.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number,
              :timestamp => timestamp,
              :delivery_estimate => delivery_estimate,
              :description => description
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class LabelForm

          attr_reader :tracking_id, :status, :carrier, :tracking_number, :delivery_estimate, :description, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_id, :carrier, :tracking_number], 'LabelForm')
            @tracking_id = HttpClient::Preconditions.assert_class('tracking_id', opts.delete(:tracking_id), String)
            @status = (x = (x = opts.delete(:status); x.nil? ? "pending" : x); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @timestamp = (x = opts.delete(:timestamp); x.nil? ? nil : HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_id => tracking_id,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number,
              :delivery_estimate => delivery_estimate,
              :description => description,
              :timestamp => timestamp
            }
          end

        end

        class LabelSummary

          attr_reader :id, :tracking, :status, :carrier, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number], 'LabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number
            }
          end

        end

        class LabelVersion

          attr_reader :id, :timestamp, :type, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :label], 'LabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @label = (x = opts.delete(:label); x.is_a?(::Io::Flow::V0::Models::LabelSummary) ? x : ::Io::Flow::V0::Models::LabelSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :label => label.to_hash
            }
          end

        end

        # Available origin/destination mapping and available metadata for lanes of a
        # carrier Service. e.g. UPS Ground only US-US, UPS Intl only US-Intl, etc
        class Lane < ExpandableLane

          attr_reader :id, :service, :origin, :destination, :window, :exceptions

          def initialize(incoming={})
            super(:name => ExpandableLane::Types::LANE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :origin, :destination, :window, :exceptions], 'Lane')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
            @exceptions = HttpClient::Preconditions.assert_class('exceptions', opts.delete(:exceptions), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LaneException) ? x : ::Io::Flow::V0::Models::LaneException.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Lane.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :service => service.to_hash,
              :origin => origin,
              :destination => destination,
              :window => window.to_hash,
              :exceptions => exceptions.map { |o| o.to_hash }
            }
          end

        end

        class LaneException

          attr_reader :keyword, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:keyword, :type], 'LaneException')
            @keyword = HttpClient::Preconditions.assert_class('keyword', opts.delete(:keyword), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::Reason) ? x : ::Io::Flow::V0::Models::Reason.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneException.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :keyword => keyword,
              :type => type.value
            }
          end

        end

        class LaneForm

          attr_reader :service, :origin_country, :destination_country, :window, :exceptions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :origin_country, :destination_country, :window, :exceptions], 'LaneForm')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @origin_country = HttpClient::Preconditions.assert_class('origin_country', opts.delete(:origin_country), String)
            @destination_country = HttpClient::Preconditions.assert_class('destination_country', opts.delete(:destination_country), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
            @exceptions = HttpClient::Preconditions.assert_class('exceptions', opts.delete(:exceptions), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LaneException) ? x : ::Io::Flow::V0::Models::LaneException.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :origin_country => origin_country,
              :destination_country => destination_country,
              :window => window.to_hash,
              :exceptions => exceptions.map { |o| o.to_hash }
            }
          end

        end

        class LaneReference < ExpandableLane

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableLane::Types::LANE_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'LaneReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class LaneVersion

          attr_reader :id, :timestamp, :type, :lane

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :lane], 'LaneVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @lane = (x = opts.delete(:lane); x.is_a?(::Io::Flow::V0::Models::ExpandableLane) ? x : ::Io::Flow::V0::Models::ExpandableLane.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :lane => lane.to_hash
            }
          end

        end

        # ISO 639 2-character language code. See
        # https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
        class Language

          attr_reader :name, :iso_639_2

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_639_2], 'Language')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_639_2 = HttpClient::Preconditions.assert_class('iso_639_2', opts.delete(:iso_639_2), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Language.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_639_2 => iso_639_2
            }
          end

        end

        # Represents an order line for checkout
        class Line

          attr_reader :number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'Line')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Line.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity
            }
          end

        end

        class Local

          attr_reader :prices

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:prices], 'Local')
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Local.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :prices => prices.map { |o| o.to_hash }
            }
          end

        end

        class LocalizedPrice

          attr_reader :key, :currency, :amount, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label], 'LocalizedPrice')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedPrice.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :currency => currency,
              :amount => amount,
              :label => label
            }
          end

        end

        # Defines structured fields for address to be used in user/form input. Either
        # text or the structured input needs to be present.
        class Location < ExpandableLocation

          attr_reader :text, :streets, :city, :province, :postal, :country, :latitude, :longitude

          def initialize(incoming={})
            super(:name => ExpandableLocation::Types::LOCATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @latitude = (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String))
            @longitude = (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Location.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :text => text,
              :streets => streets.nil? ? nil : streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :latitude => latitude,
              :longitude => longitude
            }
          end

        end

        class LocationReference < ExpandableLocation

          attr_reader :text

          def initialize(incoming={})
            super(:name => ExpandableLocation::Types::LOCATION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocationReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :text => text
            }
          end

        end

        class Margin < Adjustment

          attr_reader :name, :value

          def initialize(incoming={})
            super(:name => Adjustment::Types::MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :value], 'Margin')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::AdjustmentType) ? x : ::Io::Flow::V0::Models::AdjustmentType.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Margin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :name => name.value,
              :value => value
            }
          end

        end

        class Measurement

          attr_reader :value, :units

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :units], 'Measurement')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            @units = (x = opts.delete(:units); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Measurement.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value,
              :units => units.value
            }
          end

        end

        # Represents the users that are part of this organization. Primary purpose is to
        # manage which users have access to the organization's data and to provide a
        # simple user interface to assign roles and permissions to each member of the
        # organization
        class Membership

          attr_reader :id, :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :user, :role], 'Membership')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::ExpandableUser) ? x : ::Io::Flow::V0::Models::ExpandableUser.from_json(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Membership.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :user => user.to_hash,
              :role => role.value
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipForm

          attr_reader :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :user], 'MembershipForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @user = HttpClient::Preconditions.assert_class('user', opts.delete(:user), String)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :user => user,
              :role => role.value
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipPutForm

          attr_reader :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value
            }
          end

        end

        class MembershipVersion

          attr_reader :id, :timestamp, :type, :membership

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :membership], 'MembershipVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @membership = (x = opts.delete(:membership); x.is_a?(::Io::Flow::V0::Models::Membership) ? x : ::Io::Flow::V0::Models::Membership.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :membership => membership.to_hash
            }
          end

        end

        class Name

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Name.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        class NameForm

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NameForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class Option < ExpandableOption

          attr_reader :id, :cost, :price, :service, :tier, :window

          def initialize(incoming={})
            super(:name => ExpandableOption::Types::OPTION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :price, :service, :tier, :window], 'Option')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierSummary) ? x : ::Io::Flow::V0::Models::TierSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Option.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class OptionForm

          attr_reader :delivery, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivery, :items, :destination], 'OptionForm')
            @delivery = HttpClient::Preconditions.assert_class('delivery', opts.delete(:delivery), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivery => delivery,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        class OptionReference < ExpandableOption

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableOption::Types::OPTION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OptionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OptionReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class OptionVersion

          attr_reader :id, :timestamp, :type, :option

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :option], 'OptionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @option = (x = opts.delete(:option); x.is_a?(::Io::Flow::V0::Models::ExpandableOption) ? x : ::Io::Flow::V0::Models::ExpandableOption.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OptionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :option => option.to_hash
            }
          end

        end

        # Flags to indicate whether a feature is enabled/disabled on a particular model
        # (e.g. show/do not show attribute as a column in harmonization table view of
        # items)
        class Options

          attr_reader :show_in_catalog, :show_in_harmonization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @show_in_catalog = HttpClient::Preconditions.assert_boolean('show_in_catalog', (x = opts.delete(:show_in_catalog); x.nil? ? false : x))
            @show_in_harmonization = HttpClient::Preconditions.assert_boolean('show_in_harmonization', (x = opts.delete(:show_in_harmonization); x.nil? ? false : x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Options.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :show_in_catalog => show_in_catalog,
              :show_in_harmonization => show_in_harmonization
            }
          end

        end

        # Represents a single organization in the system
        class Organization < ExpandableOrganization

          attr_reader :id, :name

          def initialize(incoming={})
            super(:name => ExpandableOrganization::Types::ORGANIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'Organization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Organization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        # Either id or name is required.
        class OrganizationForm

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @id = (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class OrganizationReference < ExpandableOrganization

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableOrganization::Types::ORGANIZATION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrganizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class OrganizationSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'OrganizationSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class OrganizationVersion

          attr_reader :id, :timestamp, :type, :organization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization], 'OrganizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::Organization) ? x : ::Io::Flow::V0::Models::Organization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization => organization.to_hash
            }
          end

        end

        class PasswordChangeForm

          attr_reader :current, :new

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:current, :new], 'PasswordChangeForm')
            @current = HttpClient::Preconditions.assert_class('current', opts.delete(:current), String)
            @new = HttpClient::Preconditions.assert_class('new', opts.delete(:new), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordChangeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :current => current,
              :new => new
            }
          end

        end

        class PasswordResetForm

          attr_reader :token, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :password], 'PasswordResetForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token,
              :password => password
            }
          end

        end

        class PasswordResetRequestForm

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'PasswordResetRequestForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetRequestForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        # Presentation for UI that is used to generate a localized price function
        class Presets

          attr_reader :adjustments, :levies

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @adjustments = HttpClient::Preconditions.assert_class('adjustments', (x = opts.delete(:adjustments); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Adjustment) ? x : ::Io::Flow::V0::Models::Adjustment.from_json(x)) }
            @levies = HttpClient::Preconditions.assert_class('levies', (x = opts.delete(:levies); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Levy) ? x : ::Io::Flow::V0::Models::Levy.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Presets.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :adjustments => adjustments.map { |o| o.to_hash },
              :levies => levies.map { |o| o.value }
            }
          end

        end

        # Represents an amount-currency pair for a basic price
        class Price

          attr_reader :amount, :currency, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency, :label], 'Price')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Price.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency,
              :label => label
            }
          end

        end

        # Represents a collection of deliveries and available options for fulfillment of
        # that delivery
        class Quote < ExpandableQuote

          attr_reader :id, :destination, :deliveries, :exceptions, :customs

          def initialize(incoming={})
            super(:name => ExpandableQuote::Types::QUOTE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination, :deliveries, :exceptions], 'Quote')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @exceptions = HttpClient::Preconditions.assert_class('exceptions', opts.delete(:exceptions), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::QuoteException) ? x : ::Io::Flow::V0::Models::QuoteException.new(x)) }
            @customs = (x = opts.delete(:customs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Customs) ? x : ::Io::Flow::V0::Models::Customs.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Quote.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :exceptions => exceptions.map { |o| o.to_hash },
              :customs => customs.nil? ? nil : customs.to_hash
            }
          end

        end

        # For whatever reason, if an item cannot be shipped and slotted into a quote
        # delivery, then item(s) are exceptions to shipping and surface a reason.
        class QuoteException

          attr_reader :items, :reason

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :reason], 'QuoteException')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @reason = (x = opts.delete(:reason); x.is_a?(::Io::Flow::V0::Models::Reason) ? x : ::Io::Flow::V0::Models::Reason.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteException.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :reason => reason.value
            }
          end

        end

        class QuoteForm

          attr_reader :items, :destination, :customs, :origin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :destination], 'QuoteForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @customs = (x = opts.delete(:customs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Customs) ? x : ::Io::Flow::V0::Models::Customs.new(x)))
            @origin = (x = opts.delete(:origin); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash,
              :customs => customs.nil? ? nil : customs.to_hash,
              :origin => origin.nil? ? nil : origin.to_hash
            }
          end

        end

        class QuoteReference < ExpandableQuote

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableQuote::Types::QUOTE_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'QuoteReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class QuoteVersion

          attr_reader :id, :timestamp, :type, :quote

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :quote], 'QuoteVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @quote = (x = opts.delete(:quote); x.is_a?(::Io::Flow::V0::Models::ExpandableQuote) ? x : ::Io::Flow::V0::Models::ExpandableQuote.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :quote => quote.to_hash
            }
          end

        end

        # Refunds are used to issue refunds against a prior capture.
        class Refund

          attr_reader :id, :reference, :capture, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :capture, :amount, :currency], 'Refund')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Refund.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :capture => capture.to_hash,
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Refund actually transfers funds. You can refund as many times as you'd like up
        # until the total amount of the capture has been refunded.
        class RefundForm

          attr_reader :capture_id, :reference, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:capture_id], 'RefundForm')
            @capture_id = HttpClient::Preconditions.assert_class('capture_id', opts.delete(:capture_id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :capture_id => capture_id,
              :reference => reference,
              :amount => amount,
              :currency => currency
            }
          end

        end

        class RefundVersion

          attr_reader :id, :timestamp, :type, :refund

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :refund], 'RefundVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :refund => refund.to_hash
            }
          end

        end

        class Rounding < Adjustment

          attr_reader :name, :rounding_method, :value

          def initialize(incoming={})
            super(:name => Adjustment::Types::ROUNDING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :rounding_method, :value], 'Rounding')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::AdjustmentType) ? x : ::Io::Flow::V0::Models::AdjustmentType.apply(x))
            @rounding_method = (x = opts.delete(:rounding_method); x.is_a?(::Io::Flow::V0::Models::RoundingMethod) ? x : ::Io::Flow::V0::Models::RoundingMethod.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rounding.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :name => name.value,
              :rounding_method => rounding_method.value,
              :value => value
            }
          end

        end

        # System to filter incoming quote for a shipment request based on a query and
        # output corresponding outcomes.
        class Rule

          attr_reader :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:query, :outcome], 'Rule')
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), Array).map { |v| HttpClient::Preconditions.assert_class('query', v, String) }
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::RuleOutcome) ? x : ::Io::Flow::V0::Models::RuleOutcome.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        # Represents operating calendar and holidays of a location
        class Schedule

          attr_reader :calendar, :holiday, :exception, :cutoff

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:holiday, :exception], 'Schedule')
            @calendar = (x = opts.delete(:calendar); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Calendar) ? x : ::Io::Flow::V0::Models::Calendar.apply(x)))
            @holiday = (x = opts.delete(:holiday); x.is_a?(::Io::Flow::V0::Models::HolidayCalendar) ? x : ::Io::Flow::V0::Models::HolidayCalendar.apply(x))
            @exception = HttpClient::Preconditions.assert_class('exception', opts.delete(:exception), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Exception) ? x : ::Io::Flow::V0::Models::Exception.new(x)) }
            @cutoff = (x = opts.delete(:cutoff); x.nil? ? nil : HttpClient::Preconditions.assert_class('cutoff', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Schedule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :calendar => calendar.nil? ? nil : calendar.value,
              :holiday => holiday.value,
              :exception => exception.map { |o| o.to_hash },
              :cutoff => cutoff
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class Service < ExpandableService

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            super(:name => ExpandableService::Types::SERVICE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'Service')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::ExpandableCarrier) ? x : ::Io::Flow::V0::Models::ExpandableCarrier.from_json(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Service.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class ServiceForm

          attr_reader :name, :carrier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :carrier], 'ServiceForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :carrier => carrier
            }
          end

        end

        class ServiceReference < ExpandableService

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableService::Types::SERVICE_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ServiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class ServiceVersion

          attr_reader :id, :timestamp, :type, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :service], 'ServiceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ExpandableService) ? x : ::Io::Flow::V0::Models::ExpandableService.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :service => service.to_hash
            }
          end

        end

        # Represents a subset of items from an order grouped into a single physical
        # shipment. Flow provides a generated tracking number to track this shipment
        # across multiple possible hops and carriers.
        class Shipment < ExpandableShipment

          attr_reader :id, :commercial_invoice, :destination, :items, :shipment_labels, :tracking_number

          def initialize(incoming={})
            super(:name => ExpandableShipment::Types::SHIPMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :commercial_invoice, :destination, :items, :shipment_labels, :tracking_number], 'Shipment')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @commercial_invoice = HttpClient::Preconditions.assert_class('commercial_invoice', opts.delete(:commercial_invoice), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @shipment_labels = HttpClient::Preconditions.assert_class('shipment_labels', opts.delete(:shipment_labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentLabel) ? x : ::Io::Flow::V0::Models::ShipmentLabel.new(x)) }
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Shipment.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :commercial_invoice => commercial_invoice,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :shipment_labels => shipment_labels.map { |o| o.to_hash },
              :tracking_number => tracking_number
            }
          end

        end

        # Represents a subset of items from an order grouped into a single physical
        # shipment.
        class ShipmentForm

          attr_reader :destination, :items, :shipment_labels

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :items], 'ShipmentForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @shipment_labels = (x = opts.delete(:shipment_labels); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipment_labels', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentLabelForm) ? x : ::Io::Flow::V0::Models::ShipmentLabelForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :shipment_labels => shipment_labels.nil? ? nil : shipment_labels.map { |o| o.to_hash }
            }
          end

        end

        # Top-level information on shipment tracking shipment_label and number
        class ShipmentLabel < ExpandableShipmentLabel

          attr_reader :id, :service, :tracking_number, :window, :pdf, :zpl

          def initialize(incoming={})
            super(:name => ExpandableShipmentLabel::Types::SHIPMENT_LABEL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :tracking_number], 'ShipmentLabel')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x))
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabel.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :service => service.to_hash,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :pdf => pdf,
              :zpl => zpl
            }
          end

        end

        # Top-level information on shipment tracking shipment_label and number
        class ShipmentLabelForm

          attr_reader :service, :tracking_number, :window, :data, :shipment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :tracking_number], 'ShipmentLabelForm')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @data = (x = opts.delete(:data); x.nil? ? nil : HttpClient::Preconditions.assert_class('data', x, String))
            @shipment = (x = opts.delete(:shipment); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipment', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :data => data,
              :shipment => shipment
            }
          end

        end

        class ShipmentLabelReference < ExpandableShipmentLabel

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableShipmentLabel::Types::SHIPMENT_LABEL_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ShipmentLabelReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class ShipmentLabelVersion

          attr_reader :id, :timestamp, :type, :shipment_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipment_label], 'ShipmentLabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipment_label = (x = opts.delete(:shipment_label); x.is_a?(::Io::Flow::V0::Models::ExpandableShipmentLabel) ? x : ::Io::Flow::V0::Models::ExpandableShipmentLabel.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipment_label => shipment_label.to_hash
            }
          end

        end

        class ShipmentReference < ExpandableShipment

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableShipment::Types::SHIPMENT_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ShipmentReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class ShipmentVersion

          attr_reader :id, :timestamp, :type, :shipment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipment], 'ShipmentVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipment = (x = opts.delete(:shipment); x.is_a?(::Io::Flow::V0::Models::ExpandableShipment) ? x : ::Io::Flow::V0::Models::ExpandableShipment.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipment => shipment.to_hash
            }
          end

        end

        # A configuration with custom query to select a subset of master catalog items
        # for a localized experience
        class Subcatalog < ExpandableSubcatalog

          attr_reader :id, :catalog, :country, :key, :settings, :query

          def initialize(incoming={})
            super(:name => ExpandableSubcatalog::Types::SUBCATALOG)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :catalog, :country, :key, :settings], 'Subcatalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::V0::Models::SubcatalogSettings) ? x : ::Io::Flow::V0::Models::SubcatalogSettings.new(x))
            @query = (x = opts.delete(:query); x.nil? ? nil : HttpClient::Preconditions.assert_class('query', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Subcatalog.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :catalog => catalog.to_hash,
              :country => country,
              :key => key,
              :settings => settings.to_hash,
              :query => query
            }
          end

        end

        class SubcatalogForm

          attr_reader :country, :key, :query, :settings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country], 'SubcatalogForm')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @query = (x = opts.delete(:query); x.nil? ? nil : HttpClient::Preconditions.assert_class('query', x, String))
            @settings = (x = opts.delete(:settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogSettingsForm) ? x : ::Io::Flow::V0::Models::SubcatalogSettingsForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country,
              :key => key,
              :query => query,
              :settings => settings.nil? ? nil : settings.to_hash
            }
          end

        end

        class SubcatalogItem

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SubcatalogItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class SubcatalogReference < ExpandableSubcatalog

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableSubcatalog::Types::SUBCATALOG_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SubcatalogReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class SubcatalogSettings

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = (x = opts.delete(:update_policy); x.nil? ? "auto" : x); x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.value
            }
          end

        end

        class SubcatalogSettingsForm

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = opts.delete(:update_policy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.nil? ? nil : update_policy.value
            }
          end

        end

        class SubcatalogVersion

          attr_reader :id, :timestamp, :type, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog], 'SubcatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::Subcatalog) ? x : ::Io::Flow::V0::Models::Subcatalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog => subcatalog.to_hash
            }
          end

        end

        class Suggestion

          attr_reader :label, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label, :count], 'Suggestion')
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Suggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label => label,
              :count => count
            }
          end

        end

        # Represents a simple model of taxes that apply to a given item / destination.
        class Tax

          attr_reader :name, :rate, :components, :deminimus

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :rate, :components], 'Tax')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimus = (x = opts.delete(:deminimus); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimus) ? x : ::Io::Flow::V0::Models::Deminimus.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tax.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimus => deminimus.nil? ? nil : deminimus.to_hash
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class Tier < ExpandableTier

          attr_reader :id, :experience, :integration, :name, :rules, :services, :strategy, :visibility

          def initialize(incoming={})
            super(:name => ExpandableTier::Types::TIER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'Tier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::Integration) ? x : ::Io::Flow::V0::Models::Integration.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Rule) ? x : ::Io::Flow::V0::Models::Rule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x)) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tier.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services.map { |o| o.to_hash },
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class TierForm

          attr_reader :experience, :integration, :name, :rules, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:experience, :integration, :name, :rules, :services, :strategy, :visibility], 'TierForm')
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::Integration) ? x : ::Io::Flow::V0::Models::Integration.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Rule) ? x : ::Io::Flow::V0::Models::Rule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', v, String) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :experience => experience,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services,
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        class TierReference < ExpandableTier

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableTier::Types::TIER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'TierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class TierSummary

          attr_reader :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'TierSummary')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name
            }
          end

        end

        class TierVersion

          attr_reader :id, :timestamp, :type, :tier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier], 'TierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::ExpandableTier) ? x : ::Io::Flow::V0::Models::ExpandableTier.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier => tier.to_hash
            }
          end

        end

        # Time zone data is provided by the public IANA time zone database. See
        # http://www.iana.org/time-zones
        class Timezone

          attr_reader :name, :description, :offset

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :description, :offset], 'Timezone')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @offset = HttpClient::Preconditions.assert_class('offset', opts.delete(:offset), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Timezone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :description => description,
              :offset => offset
            }
          end

        end

        # All of the metadata associated with a given token.
        class Token

          attr_reader :id, :user, :partial, :created_at, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user, :partial, :created_at], 'Token')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @partial = HttpClient::Preconditions.assert_class('partial', opts.delete(:partial), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Token.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash,
              :partial => partial,
              :created_at => created_at,
              :description => description
            }
          end

        end

        # Used to authenticate a given token.
        class TokenAuthenticationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'TokenAuthenticationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenAuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        # Used to create a new token for the user authorized by the request. You can
        # only create an API token for your own account.
        class TokenForm

          attr_reader :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :description => description
            }
          end

        end

        # Summary data for a given token
        class TokenReference

          attr_reader :id, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user], 'TokenReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash
            }
          end

        end

        class TokenVersion

          attr_reader :id, :timestamp, :type, :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :token], 'TokenVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @token = (x = opts.delete(:token); x.is_a?(::Io::Flow::V0::Models::Token) ? x : ::Io::Flow::V0::Models::Token.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :token => token.to_hash
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class Tracking

          attr_reader :id, :status, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :metadata], 'Tracking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
            @metadata = HttpClient::Preconditions.assert_class('metadata', HttpClient::Helper.to_object(opts.delete(:metadata)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tracking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :metadata => metadata
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class TrackingForm

          attr_reader :organization, :status, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization], 'TrackingForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x)))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :status => status.nil? ? nil : status.value,
              :metadata => metadata
            }
          end

        end

        class TrackingSummary

          attr_reader :id, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status], 'TrackingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::Status) ? x : ::Io::Flow::V0::Models::Status.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value
            }
          end

        end

        class TrackingVersion

          attr_reader :id, :timestamp, :type, :tracking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking], 'TrackingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking => tracking.to_hash
            }
          end

        end

        # Credentials used to communicate with UPS on behalf of client organization.
        class UpsCredentials < Credentials

          attr_reader :account_number, :username_password

          def initialize(incoming={})
            super(:name => Credentials::Types::UPS_CREDENTIALS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:account_number, :username_password], 'UpsCredentials')
            @account_number = HttpClient::Preconditions.assert_class('account_number', opts.delete(:account_number), String)
            @username_password = (x = opts.delete(:username_password); x.is_a?(::Io::Flow::V0::Models::UsernamePassword) ? x : ::Io::Flow::V0::Models::UsernamePassword.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UpsCredentials.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :account_number => account_number,
              :username_password => username_password.to_hash
            }
          end

        end

        # Represents a single user in the system
        class User < ExpandableUser

          attr_reader :id, :email, :name

          def initialize(incoming={})
            super(:name => ExpandableUser::Types::USER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'User')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            User.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :email => email,
              :name => name.to_hash
            }
          end

        end

        class UserForm

          attr_reader :email, :password, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @password = (x = opts.delete(:password); x.nil? ? nil : HttpClient::Preconditions.assert_class('password', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserPutForm

          attr_reader :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserReference < ExpandableUser

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableUser::Types::USER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'UserReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class UserSummary

          attr_reader :id, :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'UserSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :email => email,
              :name => name
            }
          end

        end

        class UserVersion

          attr_reader :id, :timestamp, :type, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :user], 'UserVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::User) ? x : ::Io::Flow::V0::Models::User.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :user => user.to_hash
            }
          end

        end

        # Username and password credentials.
        class UsernamePassword

          attr_reader :username, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:username, :password], 'UsernamePassword')
            @username = HttpClient::Preconditions.assert_class('username', opts.delete(:username), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UsernamePassword.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :username => username,
              :password => password
            }
          end

        end

        # Credentials used to communicate with USPS on behalf of client organization.
        class UspsCredentials < Credentials

          attr_reader :account_number, :username_password

          def initialize(incoming={})
            super(:name => Credentials::Types::USPS_CREDENTIALS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:account_number, :username_password], 'UspsCredentials')
            @account_number = HttpClient::Preconditions.assert_class('account_number', opts.delete(:account_number), String)
            @username_password = (x = opts.delete(:username_password); x.is_a?(::Io::Flow::V0::Models::UsernamePassword) ? x : ::Io::Flow::V0::Models::UsernamePassword.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UspsCredentials.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :account_number => account_number,
              :username_password => username_password.to_hash
            }
          end

        end

        # Model used to report whether or not a given token is valid
        class Validation

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Validation')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Validation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # Defines the payload of a request to validate a token, with primary goal of
        # preventing the token from being included in an HTTP GET.
        class ValidationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'ValidationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ValidationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

      end

      # ===== END OF SERVICE DEFINITION =====
      module HttpClient

        class Request

          def initialize(uri)
            @uri = Preconditions.assert_class('uri', uri, URI)
            @params = nil
            @body = nil
            @auth = nil
            @headers = {}
            @header_keys_lower_case = []
          end

          def with_header(name, value)
            Preconditions.check_not_blank('name', name, "Header name is required")
            Preconditions.check_not_blank('value', value, "Header value is required")
            Preconditions.check_state(!@headers.has_key?(name),
                                      "Duplicate header named[%s]" % name)
            @headers[name] = value
            @header_keys_lower_case << name.downcase
            self
          end

          def with_auth(auth)
            Preconditions.assert_class('auth', auth, HttpClient::Authorization)
            Preconditions.check_state(@auth.nil?, "auth previously set")

            if auth.scheme.name == AuthScheme::BASIC.name
              @auth = auth
            else
              raise "Auth Scheme[#{auth.scheme.name}] not supported"
            end
            self
          end

          def with_query(params)
            Preconditions.assert_class('params', params, Hash)
            Preconditions.check_state(@params.nil?, "Already have query parameters")
            @params = params
            self
          end

          # Wrapper to set Content-Type header to application/json and set
          # the provided json document as the body
          def with_json(json)
            @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
            with_body(json)
          end

          def with_body(body)
            Preconditions.check_not_blank('body', body)
            @body = body
            self
          end

          # Creates a new Net:HTTP client. The client returned should be
          # fully configured to make a request.
          def new_http_client
            client = Net::HTTP.new(@uri.host, @uri.port)
            if @uri.scheme == "https"
              configure_ssl(client)
            end
            client
          end

          # If HTTPS is required, this method accepts an HTTP Client and configures SSL
          def configure_ssl(http)
            Preconditions.assert_class('http', http, Net::HTTP)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_PEER
            http.cert_store = OpenSSL::X509::Store.new
            http.cert_store.set_default_paths
          end

          def get(&block)
            do_request(Net::HTTP::Get, &block)
          end

          def delete(&block)
            do_request(Net::HTTP::Delete, &block)
          end

          def options(&block)
            do_request(Net::HTTP::Options, &block)
          end

          def post(&block)
            do_request(Net::HTTP::Post, &block)
          end

          def put(&block)
            do_request(Net::HTTP::Put, &block)
          end

          class PATCH < Net::HTTP::Put
            METHOD = "PATCH"
          end

          def patch(&block)
            do_request(PATCH, &block)
          end

          def do_request(klass)
            Preconditions.assert_class('klass', klass, Class)

            uri = @uri.to_s
            if q = to_query(@params)
              uri += "?%s" % q
            end

            request = klass.send(:new, uri)

            curl = ['curl']
            if klass != Net::HTTP::Get
              curl << "-X%s" % klass.name.split("::").last.upcase
            end

            if @body
              # DEBUG path = "/tmp/rest_client.tmp"
              # DEBUG File.open(path, "w") { |os| os << @body.to_s }
              # DEBUG curl << "-d@%s" % path
              request.body = @body
            end

            if @auth
              curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
              Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                        "Cannot specify both an Authorization header and an auth instance")
              user_pass = "%s:%s" % [@auth.username, @auth.password]
              encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
              request.add_field("Authorization", "Basic %s" % encoded)
            end

            @headers.each { |key, value|
              curl <<  "-H \"%s: %s\"" % [key, value]
              request.add_field(key, value)
            }

            curl << "'%s'" % uri
            # DEBUG puts curl.join(" ")

            raw_response = http_request(request)
            response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

            if block_given?
              yield response
            else
              response
            end
          end

          private
          def to_query(params={})
            parts = (params || {}).map { |k,v|
              if v.respond_to?(:each)
                v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
              else
                "%s=%s" % [k, CGI.escape(v.to_s)]
              end
            }
            parts.empty? ? nil : parts.join("&")
          end

          def http_request(request)
            response = begin
                         new_http_client.request(request)
                       rescue SocketError => e
                         raise Exception.new("Error accessing uri[#{@uri}]: #{e}")
                       end

            case response
            when Net::HTTPSuccess
              response.body
            else
              body = response.body rescue nil
              raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => @uri.to_s)
            end
          end
        end

        class ServerError < StandardError

          attr_reader :code, :details, :body, :uri

          def initialize(code, details, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @code = HttpClient::Preconditions.assert_class('code', code, Integer)
            @details = HttpClient::Preconditions.assert_class('details', details, String)
            @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
            @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
            super(self.message)
          end

          def message
            m = "%s %s" % [@code, @details]
            if @body
              m << ": %s" % @body
            end
            m
          end

          def body_json
            JSON.parse(@body)
          end

        end

        class PreconditionException < Exception

          attr_reader :message

          def initialize(message)
            super(message)
            @message = message
          end

        end

        module Preconditions

          def Preconditions.check_argument(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_argument failed")
            end
            nil
          end

          def Preconditions.check_state(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_state failed")
            end
            nil
          end

          def Preconditions.check_not_nil(field_name, reference, error_message=nil)
            if reference.nil?
              raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
            end
            reference
          end

          def Preconditions.check_not_blank(field_name, reference, error_message=nil)
            if reference.to_s.strip == ""
              raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
            end
            reference
          end

          # Throws an error if opts is not empty. Useful when parsing
          # arguments to a function
          def Preconditions.assert_empty_opts(opts)
            if !opts.empty?
              raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
            end
          end

          # Requires that the provided hash has the specified keys.
          # @param fields A list of symbols
          def Preconditions.require_keys(hash, fields, error_prefix=nil)
            missing = fields.select { |f| !hash.has_key?(f) }
            if !missing.empty?
              msg = "Missing required fields: " + missing.join(", ")
              raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
            end
          end

          # Asserts that value is not nill and is_?(klass). Returns
          # value. Common use is
          #
          # amount = Preconditions.assert_class('amount', amount, BigDecimal)
          def Preconditions.assert_class(field_name, value, klass)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('klass', klass)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
            Preconditions.check_state(value.is_a?(klass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_class_or_nil(field_name, value, klass)
            if !value.nil?
              Preconditions.assert_class(field_name, value, klass)
            end
          end

          def Preconditions.assert_boolean(field_name, value)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
            Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_boolean_or_nil(field_name, value)
            if !value.nil?
              Preconditions.assert_boolean(field_name, value)
            end
          end

          def Preconditions.assert_collection_of_class(field_name, values, klass)
            Preconditions.assert_class(field_name, values, Array)
            values.each { |v| Preconditions.assert_class(field_name, v, klass) }
          end

          def Preconditions.assert_hash_of_class(field_name, hash, klass)
            Preconditions.assert_class(field_name, hash, Hash)
            values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
          end

        end

        class AuthScheme

          attr_reader :name

          def initialize(name)
            @name = HttpClient::Preconditions.check_not_blank('name', name)
          end

          BASIC = AuthScheme.new("basic") unless defined?(BASIC)

        end

        class Authorization

          attr_reader :scheme, :username, :password

          def initialize(scheme, username, opts={})
            @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
            @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
            @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
          end

          def Authorization.basic(username, password=nil)
            Authorization.new(AuthScheme::BASIC, username, :password => password)
          end

        end

        module Helper

          def Helper.symbolize_keys(hash)
            Preconditions.assert_class('hash', hash, Hash)
            new_hash = {}
            hash.each { |k, v|
              new_hash[k.to_sym] = v
            }
            new_hash
          end

          def Helper.to_big_decimal(value)
            value ? BigDecimal.new(value.to_s) : nil
          end

          def Helper.to_object(value)
            value ? JSON.parse(value) : nil
          end

          def Helper.to_uuid(value)
            Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                      "Invalid guid[%s]" % value)
            value
          end

          def Helper.to_date_iso8601(value)
            if value.is_a?(Date)
              value
            elsif value
              Date.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.to_date_time_iso8601(value)
            if value.is_a?(DateTime)
              value
            elsif value
              DateTime.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.date_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%d')
          end

          def Helper.date_time_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
          end

          TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
          FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

          def Helper.to_boolean(field_name, value)
            string = value.to_s.strip.downcase
            if TRUE_STRINGS.include?(string)
              true
            elsif FALSE_STRINGS.include?(string)
              false
            elsif string != ""
              raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
            else
              nil
            end
          end

        end

      end
    end
  end
end