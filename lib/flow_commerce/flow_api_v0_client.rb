# Generated by apidoc - http://www.apidoc.me
# Service version: 0.0.82
# apidoc:0.11.33 http://www.apidoc.me/flow/api/0.0.82/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

# The Flow Commerce REST API provides full access to the global ecommerce
# platform.
module Io
  module Flow
    module V0

      class Client

        module Constants

          BASE_URL = 'https://api.flow.io' unless defined?(Constants::BASE_URL)
          NAMESPACE = 'io.flow.v0' unless defined?(Constants::NAMESPACE)
          USER_AGENT = 'apidoc:0.11.33 http://www.apidoc.me/flow/api/0.0.82/ruby_client' unless defined?(Constants::USER_AGENT)
          VERSION = '0.0.82' unless defined?(Constants::VERSION)
          VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

        end

        attr_reader :url

        def initialize(url, opts={})
          @url = HttpClient::Preconditions.assert_class('url', url, String)
          @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
          @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
          HttpClient::Preconditions.assert_empty_opts(opts)
          HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
        end

        # Creates an instance of the client using the base url specified in the API spec.
        def Client.at_base_url(opts={})
          Client.new(Constants::BASE_URL, opts)
        end

        def request(path=nil)
          HttpClient::Preconditions.assert_class_or_nil('path', path, String)
          request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

          @default_headers.each do |key, value|
            request = request.with_header(key, value)
          end

          if @authorization
            request = request.with_auth(@authorization)
          end

          request
        end

        def attributes
          @attributes ||= ::Io::Flow::V0::Clients::Attributes.new(self)
        end

        def catalogs
          @catalogs ||= ::Io::Flow::V0::Clients::Catalogs.new(self)
        end

        def experiences
          @experiences ||= ::Io::Flow::V0::Clients::Experiences.new(self)
        end

        def items
          @items ||= ::Io::Flow::V0::Clients::Items.new(self)
        end

        def orders
          @orders ||= ::Io::Flow::V0::Clients::Orders.new(self)
        end

        def subcatalogs
          @subcatalogs ||= ::Io::Flow::V0::Clients::Subcatalogs.new(self)
        end

        def subcatalog_items
          @subcatalog_items ||= ::Io::Flow::V0::Clients::SubcatalogItems.new(self)
        end

        def item_functions
          @item_functions ||= ::Io::Flow::V0::Clients::ItemFunctions.new(self)
        end

        def organization_currency_settings
          @organization_currency_settings ||= ::Io::Flow::V0::Clients::OrganizationCurrencySettings.new(self)
        end

        def rates
          @rates ||= ::Io::Flow::V0::Clients::Rates.new(self)
        end

        def spot_rates
          @spot_rates ||= ::Io::Flow::V0::Clients::SpotRates.new(self)
        end

        def duties
          @duties ||= ::Io::Flow::V0::Clients::Duties.new(self)
        end

        def harmonization_settings
          @harmonization_settings ||= ::Io::Flow::V0::Clients::HarmonizationSettings.new(self)
        end

        def harmonized_items
          @harmonized_items ||= ::Io::Flow::V0::Clients::HarmonizedItems.new(self)
        end

        def harmonized_item_duties
          @harmonized_item_duties ||= ::Io::Flow::V0::Clients::HarmonizedItemDuties.new(self)
        end

        def harmonized_landed_costs
          @harmonized_landed_costs ||= ::Io::Flow::V0::Clients::HarmonizedLandedCosts.new(self)
        end

        def hs10
          @hs10 ||= ::Io::Flow::V0::Clients::Hs10.new(self)
        end

        def hs6
          @hs6 ||= ::Io::Flow::V0::Clients::Hs6.new(self)
        end

        def taxes
          @taxes ||= ::Io::Flow::V0::Clients::Taxes.new(self)
        end

        def authorizations
          @authorizations ||= ::Io::Flow::V0::Clients::Authorizations.new(self)
        end

        def captures
          @captures ||= ::Io::Flow::V0::Clients::Captures.new(self)
        end

        def cards
          @cards ||= ::Io::Flow::V0::Clients::Cards.new(self)
        end

        def refunds
          @refunds ||= ::Io::Flow::V0::Clients::Refunds.new(self)
        end

        def bookings
          @bookings ||= ::Io::Flow::V0::Clients::Bookings.new(self)
        end

        def carriers
          @carriers ||= ::Io::Flow::V0::Clients::Carriers.new(self)
        end

        def carrier_accounts
          @carrier_accounts ||= ::Io::Flow::V0::Clients::CarrierAccounts.new(self)
        end

        def centers
          @centers ||= ::Io::Flow::V0::Clients::Centers.new(self)
        end

        def delivery_windows
          @delivery_windows ||= ::Io::Flow::V0::Clients::DeliveryWindows.new(self)
        end

        def inventory_rules
          @inventory_rules ||= ::Io::Flow::V0::Clients::InventoryRules.new(self)
        end

        def inventory_snapshots
          @inventory_snapshots ||= ::Io::Flow::V0::Clients::InventorySnapshots.new(self)
        end

        def inventory_updates
          @inventory_updates ||= ::Io::Flow::V0::Clients::InventoryUpdates.new(self)
        end

        def labels
          @labels ||= ::Io::Flow::V0::Clients::Labels.new(self)
        end

        def label_events
          @label_events ||= ::Io::Flow::V0::Clients::LabelEvents.new(self)
        end

        def lanes
          @lanes ||= ::Io::Flow::V0::Clients::Lanes.new(self)
        end

        def quotes
          @quotes ||= ::Io::Flow::V0::Clients::Quotes.new(self)
        end

        def ratecards
          @ratecards ||= ::Io::Flow::V0::Clients::Ratecards.new(self)
        end

        def ratecard_estimates
          @ratecard_estimates ||= ::Io::Flow::V0::Clients::RatecardEstimates.new(self)
        end

        def ratecard_lanes
          @ratecard_lanes ||= ::Io::Flow::V0::Clients::RatecardLanes.new(self)
        end

        def ratecard_rates
          @ratecard_rates ||= ::Io::Flow::V0::Clients::RatecardRates.new(self)
        end

        def services
          @services ||= ::Io::Flow::V0::Clients::Services.new(self)
        end

        def shipments
          @shipments ||= ::Io::Flow::V0::Clients::Shipments.new(self)
        end

        def shipment_labels
          @shipment_labels ||= ::Io::Flow::V0::Clients::ShipmentLabels.new(self)
        end

        def tiers
          @tiers ||= ::Io::Flow::V0::Clients::Tiers.new(self)
        end

        def tier_defaults
          @tier_defaults ||= ::Io::Flow::V0::Clients::TierDefaults.new(self)
        end

        def tier_rules
          @tier_rules ||= ::Io::Flow::V0::Clients::TierRules.new(self)
        end

        def trackings
          @trackings ||= ::Io::Flow::V0::Clients::Trackings.new(self)
        end

        def addresses
          @addresses ||= ::Io::Flow::V0::Clients::Addresses.new(self)
        end

        def countries
          @countries ||= ::Io::Flow::V0::Clients::Countries.new(self)
        end

        def currencies
          @currencies ||= ::Io::Flow::V0::Clients::Currencies.new(self)
        end

        def languages
          @languages ||= ::Io::Flow::V0::Clients::Languages.new(self)
        end

        def regions
          @regions ||= ::Io::Flow::V0::Clients::Regions.new(self)
        end

        def timezones
          @timezones ||= ::Io::Flow::V0::Clients::Timezones.new(self)
        end

        def documents
          @documents ||= ::Io::Flow::V0::Clients::Documents.new(self)
        end

        def email_verifications
          @email_verifications ||= ::Io::Flow::V0::Clients::EmailVerifications.new(self)
        end

        def healthchecks
          @healthchecks ||= ::Io::Flow::V0::Clients::Healthchecks.new(self)
        end

        def invitations
          @invitations ||= ::Io::Flow::V0::Clients::Invitations.new(self)
        end

        def memberships
          @memberships ||= ::Io::Flow::V0::Clients::Memberships.new(self)
        end

        def organizations
          @organizations ||= ::Io::Flow::V0::Clients::Organizations.new(self)
        end

        def organization_authorizations
          @organization_authorizations ||= ::Io::Flow::V0::Clients::OrganizationAuthorizations.new(self)
        end

        def password_reset_forms
          @password_reset_forms ||= ::Io::Flow::V0::Clients::PasswordResetForms.new(self)
        end

        def suggestions
          @suggestions ||= ::Io::Flow::V0::Clients::Suggestions.new(self)
        end

        def tokens
          @tokens ||= ::Io::Flow::V0::Clients::Tokens.new(self)
        end

        def users
          @users ||= ::Io::Flow::V0::Clients::Users.new(self)
        end

        def validations
          @validations ||= ::Io::Flow::V0::Clients::Validations.new(self)
        end
      end

      module Clients

        class Attributes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search attributes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "key" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Attribute.new(x) }
          end

          # Add attribute
          def post(organization, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('attribute_form', attribute_form, ::Io::Flow::V0::Models::AttributeForm)
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_json(attribute_form.to_json).post
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Returns information about a specific attribute.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Create or update an attribute with the specified key.
          def put_by_key(organization, key, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('attribute_form', attribute_form, ::Io::Flow::V0::Models::AttributeForm)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").with_json(attribute_form.to_json).put
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Delete an attribute with the specified key.
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AttributeVersion.new(x) }
          end

        end

        class Catalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns information about a specific catalog.
          def get_catalog(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog").get
            ::Io::Flow::V0::Models::Catalog.new(r)
          end

          # Get statistics for this organization's catalog.
          def get_catalog_and_statistics(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/statistics").get
            ::Io::Flow::V0::Models::CatalogStatistics.new(r)
          end

        end

        class Experiences

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search experiences. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :region => (x = opts.delete(:region); x.nil? ? nil : HttpClient::Preconditions.assert_class('region', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :subcatalog => (x = opts.delete(:subcatalog); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Experience.new(x) }
          end

          # Add experience
          def post(organization, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_json(experience_form.to_json).post
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Returns information about a specific experience.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Update experience with the specified key, creating if it does not exist.
          def put_by_key(organization, key, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").with_json(experience_form.to_json).put
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Delete the experience with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").delete
            nil
          end

          # Returns detailed information on the pricing of this item within this
          # experience
          def get_items_and_price_by_key_and_number(organization, key, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/items/#{CGI.escape(number)}/price").get
            ::Io::Flow::V0::Models::ItemPriceDetails.new(r)
          end

          def get_margins_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/margins").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemMargin.new(x) }
          end

          def post_margins_by_key(organization, key, item_margin_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('item_margin_form', item_margin_form, ::Io::Flow::V0::Models::ItemMarginForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/margins").with_json(item_margin_form.to_json).post
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def get_margins_by_key_and_id(organization, key, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/margins/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def put_margins_by_key_and_id(organization, key, id, item_margin_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('item_margin_form', item_margin_form, ::Io::Flow::V0::Models::ItemMarginForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/margins/#{CGI.escape(id)}").with_json(item_margin_form.to_json).put
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def delete_margins_by_key_and_id(organization, key, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/margins/#{CGI.escape(id)}").delete
            nil
          end

          def get_margins_and_versions_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/margins/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemMarginVersion.new(x) }
          end

          # Get the pricing settings for this experience
          def get_pricing_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/pricing").get
            ::Io::Flow::V0::Models::Pricing.new(r)
          end

          # Update the pricing settings for this experience
          def put_pricing_by_key(organization, key, pricing)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('pricing', pricing, ::Io::Flow::V0::Models::Pricing)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/pricing").with_json(pricing.to_json).put
            ::Io::Flow::V0::Models::Pricing.new(r)
          end

          # Returns localized information about 1 or more items. The items will be
          # localized based on the experience selected by the query parameters in the
          # order of experience, then country, then ip address.
          def get_items(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about this item localized based on the query parameters
          def get_items_by_number(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items/#{CGI.escape(number)}").with_query(query).get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExperienceVersion.new(x) }
          end

        end

        class Items

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search items. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Add catalog item(s)
          def post(organization, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_json(item_form.to_json).post
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Returns information about a specific item.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update item with the specified number, creating if it does not exist.
          def put_by_number(organization, number, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").with_json(item_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the item with this number
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemVersion.new(x) }
          end

        end

        class Orders

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search orders. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Order.new(x) }
          end

          # Create an order, using the localized information from the experience
          # selected by the query parameters. Note the order must be booked (see
          # bookings) before its expiration
          def post(organization, order_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('order_form', order_form, ::Io::Flow::V0::Models::OrderForm)
            r = @client.request("/#{CGI.escape(organization)}/orders").with_query(query).with_json(order_form.to_json).post
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Returns information about a specific order.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Update an order.
          def put_by_number(organization, number, order_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('order_put_form', order_put_form, ::Io::Flow::V0::Models::OrderPutForm)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").with_json(order_put_form.to_json).put
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Delete an order. Note that only orders that have not yet been booked may be
          # deleted.
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").delete
            nil
          end

          # Books an order. You will get a validation error if the order has already
          # expired (and a new quote could not be automatically recreated for a lower or
          # same price). This method is idempotent - booking an order a second time has
          # no effect.
          def put_bookings_by_number(organization, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/bookings").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::OrderBooking.new(r)
          end

          # Provides visibility into recent changes of each order, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderVersion.new(x) }
          end

        end

        class Subcatalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalogs. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Subcatalog.new(x) }
          end

          # Add subcatalog
          def post(organization, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_json(subcatalog_form.to_json).post
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Returns information about a specific subcatalog.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Update subcatalog with the specified id, creating if it does not exist.
          def put_by_id(organization, id, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").with_json(subcatalog_form.to_json).put
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Delete the subcatalog with this id
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").delete
            nil
          end

          # Returns information about a specific subcatalog's settings.
          def get_settings_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").get
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Update subcatalog settings for the specified subcatalog.
          def put_settings_by_id(organization, id, subcatalog_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('subcatalog_settings_form', subcatalog_settings_form, ::Io::Flow::V0::Models::SubcatalogSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").with_json(subcatalog_settings_form.to_json).put
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Search exclusions. Always paginated.
          def get_exclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific exclusion by catalog item number.
          def get_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add exclusion
          def put_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an exclusion with this catalog item number
          def delete_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Gets the ordered list of item functions for this subcatalog
          def get_functions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogFunction.new(x) }
          end

          # Associates a function with this subcatalog
          def post_functions_by_subcatalog_id(organization, subcatalog_id, subcatalog_function_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('subcatalog_function_form', subcatalog_function_form, ::Io::Flow::V0::Models::SubcatalogFunctionForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions").with_json(subcatalog_function_form.to_json).post
            ::Io::Flow::V0::Models::SubcatalogFunction.new(r)
          end

          def get_functions_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::SubcatalogFunction.new(r)
          end

          # Deletes the subcatalog item function - note that this removes the
          # association between the function and subcatalog / does not actually delete
          # the function itself.
          def delete_functions_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_functions_and_versions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogFunctionVersion.new(x) }
          end

          # Search inclusions. Always paginated.
          def get_inclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific inclusion by catalog item number.
          def get_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add inclusion
          def put_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an inclusion with this catalog item number
          def delete_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Search queries. Always paginated.
          def get_queries_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :type => (x = opts.delete(:type); x.nil? ? nil : HttpClient::Preconditions.assert_class('type', x, Array).map { |v| HttpClient::Preconditions.assert_class('type', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Query.new(x) }
          end

          # Add query
          def post_queries_by_subcatalog_id(organization, subcatalog_id, query_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('query_form', query_form, ::Io::Flow::V0::Models::QueryForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_json(query_form.to_json).post
            ::Io::Flow::V0::Models::Query.new(r)
          end

          # Returns information about a specific query.
          def get_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Query.new(r)
          end

          # Delete a query with this id
          def delete_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").delete
            nil
          end

          # Get statistics for the specified subcatalog
          def get_statistics_by_subcatalog_id(organization, subcatalog_id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/statistics").get
            ::Io::Flow::V0::Models::SubcatalogStatistics.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

        end

        class SubcatalogItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalog items. Always paginated.
          def get(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogItem.new(x) }
          end

          # Returns information about specific subcatalog items.
          def get_by_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::SubcatalogItem.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

        end

        class ItemFunctions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search item functions. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/item-functions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemFunction.new(x) }
          end

          # Create item function
          def post(organization, item_function_post_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('item_function_post_form', item_function_post_form, ::Io::Flow::V0::Models::ItemFunctionPostForm)
            r = @client.request("/#{CGI.escape(organization)}/item-functions").with_json(item_function_post_form.to_json).post
            ::Io::Flow::V0::Models::ItemFunction.new(r)
          end

          # Returns information about a specific item function.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/item-functions/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ItemFunction.new(r)
          end

          # Upsert item function
          def put_by_key(organization, key, item_function_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('item_function_put_form', item_function_put_form, ::Io::Flow::V0::Models::ItemFunctionPutForm)
            r = @client.request("/#{CGI.escape(organization)}/item-functions/#{CGI.escape(key)}").with_json(item_function_put_form.to_json).put
            ::Io::Flow::V0::Models::ItemFunction.new(r)
          end

          # Delete the item function with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/item-functions/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/item-functions/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemFunctionVersion.new(x) }
          end

        end

        class OrganizationCurrencySettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organization currency settings. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, String)),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/settings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(x) }
          end

          # Create organization currency settings.
          def post(organization, organization_currency_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('organization_currency_setting_form', organization_currency_setting_form, ::Io::Flow::V0::Models::OrganizationCurrencySettingForm)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings").with_json(organization_currency_setting_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          # Create organization currency settings, or update if they already exist.
          def put(organization, organization_currency_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('organization_currency_setting_form', organization_currency_setting_form, ::Io::Flow::V0::Models::OrganizationCurrencySettingForm)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings").with_json(organization_currency_setting_form.to_json).put
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationCurrencySettingVersion.new(x) }
          end

        end

        class Rates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organization currency conversion rates. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, Array).map { |v| HttpClient::Preconditions.assert_class('base', v, String) }),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/rates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Rate.new(x) }
          end

          # Create a currency conversion rate for an organization.
          def post(organization, rate_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('rate_form', rate_form, ::Io::Flow::V0::Models::RateForm)
            r = @client.request("/#{CGI.escape(organization)}/currency/rates").with_json(rate_form.to_json).post
            ::Io::Flow::V0::Models::Rate.new(r)
          end

          # Create a currency conversion rate for an organization, or update the rate if
          # it already exists.
          def put(organization, rate_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('rate_form', rate_form, ::Io::Flow::V0::Models::RateForm)
            r = @client.request("/#{CGI.escape(organization)}/currency/rates").with_json(rate_form.to_json).put
            ::Io::Flow::V0::Models::Rate.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, String)),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/rates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RateVersion.new(x) }
          end

        end

        class SpotRates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search spot rates. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, String)),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/spot_rates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SpotRate.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion.
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/spot_rates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SpotRateVersion.new(x) }
          end

        end

        class Duties

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, origin, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('origin', origin, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => HttpClient::Preconditions.assert_class('number', opts.delete(:number), String),
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/duties/#{CGI.escape(origin)}").with_query(query).get
            ::Io::Flow::V0::Models::Duty.new(r)
          end

        end

        class HarmonizationSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").get
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

          def put(organization, harmonization_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonization_settings_form', harmonization_settings_form, ::Io::Flow::V0::Models::HarmonizationSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").with_json(harmonization_settings_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

        end

        class HarmonizedItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItem.new(x) }
          end

          def post(organization, harmonized_item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_form', harmonized_item_form, ::Io::Flow::V0::Models::HarmonizedItemForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_json(harmonized_item_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          # Create or update an item to harmonize
          def put_by_number(organization, number, harmonized_item_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('harmonized_item_put_form', harmonized_item_put_form, ::Io::Flow::V0::Models::HarmonizedItemPutForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").with_json(harmonized_item_put_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_id => (x = opts.delete(:item_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemVersion.new(x) }
          end

        end

        class HarmonizedItemDuties

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x) }
          end

          def post(organization, harmonized_item_duty_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_duty_form', harmonized_item_duty_form, ::Io::Flow::V0::Models::HarmonizedItemDutyForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_json(harmonized_item_duty_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :harmonized_item_duty_id => (x = opts.delete(:harmonized_item_duty_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('harmonized_item_duty_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('harmonized_item_duty_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDutyVersion.new(x) }
          end

        end

        class HarmonizedLandedCosts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Single operation that provides harmonization landed costs (i.e. duties and
          # taxes) for 1 or more items. This method is designed to enable a single call
          # from applications that need it (like checkout) to get all data for a
          # collection of items
          def post(organization, harmonized_landed_cost_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_landed_cost_form', harmonized_landed_cost_form, ::Io::Flow::V0::Models::HarmonizedLandedCostForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/landed-costs").with_json(harmonized_landed_cost_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedLandedCost.new(r)
          end

        end

        class Hs10

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs10_id => (x = opts.delete(:hs10_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs10_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs10_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10Version.new(x) }
          end

        end

        class Hs6

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs6_id => (x = opts.delete(:hs6_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs6_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs6_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6Version.new(x) }
          end

        end

        class Taxes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/taxes").with_query(query).get
            ::Io::Flow::V0::Models::Tax.new(r)
          end

        end

        class Authorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Authorization.new(x) }
          end

          # Create a new authorization.
          def post(organization, authorization_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('authorization_form', authorization_form, ::Io::Flow::V0::Models::AuthorizationForm)
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_json(authorization_form.to_json).post
            ::Io::Flow::V0::Models::Authorization.new(r)
          end

          # Returns information about a specific authorization.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Authorization.new(r)
          end

          # Deletes a given authorization. This method will return a 422 if funds have
          # already been captured.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('authorization_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AuthorizationVersion.new(x) }
          end

        end

        class Captures

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_reference => (x = opts.delete(:authorization_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_reference', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Capture.new(x) }
          end

          # Create a new capture.
          def post(organization, capture_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('capture_form', capture_form, ::Io::Flow::V0::Models::CaptureForm)
            r = @client.request("/#{CGI.escape(organization)}/captures").with_json(capture_form.to_json).post
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Returns information about a specific capture.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('capture_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CaptureVersion.new(x) }
          end

        end

        class Cards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Card.new(x) }
          end

          # Create a new card.
          def post(organization, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('card_form', card_form, ::Io::Flow::V0::Models::CardForm)
            r = @client.request("/#{CGI.escape(organization)}/cards").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Returns information about a specific card.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Deletes the card with the specified ID.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}").delete
            nil
          end

          # Updates are implemented as copy on write. This method is a convenience
          # method that will transactionally DELETE the card with the specified ID, then
          # CREATE a new card with the data from this request. Note that this means the
          # returned credit card token will be DIFFERENT from the one used in the
          # request.
          def post_updates_by_id(organization, id, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('card_form', card_form, ::Io::Flow::V0::Models::CardForm)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}/updates").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :card_id => (x = opts.delete(:card_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('card_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CardVersion.new(x) }
          end

        end

        class Refunds

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_reference => (x = opts.delete(:authorization_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_reference', x, String)),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, String)),
              :capture_reference => (x = opts.delete(:capture_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_reference', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Refund.new(x) }
          end

          # Create a new refund.
          def post(organization, refund_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('refund_form', refund_form, ::Io::Flow::V0::Models::RefundForm)
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_json(refund_form.to_json).post
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Returns information about a specific refund.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :refund_id => (x = opts.delete(:refund_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('refund_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RefundVersion.new(x) }
          end

        end

        class Bookings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/bookings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Booking.new(x) }
          end

          def post(organization, booking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('booking_form', booking_form, ::Io::Flow::V0::Models::BookingForm)
            r = @client.request("/#{CGI.escape(organization)}/bookings").with_json(booking_form.to_json).post
            ::Io::Flow::V0::Models::Booking.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/bookings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Booking.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :booking => (x = opts.delete(:booking); x.nil? ? nil : HttpClient::Preconditions.assert_class('booking', x, Array).map { |v| HttpClient::Preconditions.assert_class('booking', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/bookings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::BookingVersion.new(x) }
          end

        end

        class Carriers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/carriers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Carrier.new(x) }
          end

          def post(carrier_form)
            HttpClient::Preconditions.assert_class('carrier_form', carrier_form, ::Io::Flow::V0::Models::CarrierForm)
            r = @client.request("/carriers").with_json(carrier_form.to_json).post
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/carriers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def put_by_id(id, carrier_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('carrier_form', carrier_form, ::Io::Flow::V0::Models::CarrierForm)
            r = @client.request("/carriers/#{CGI.escape(id)}").with_json(carrier_form.to_json).put
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/carriers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier => (x = opts.delete(:carrier); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/carriers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierVersion.new(x) }
          end

        end

        class CarrierAccounts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierAccount.new(x) }
          end

          def post(organization, carrier_account_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('carrier_account_form', carrier_account_form, ::Io::Flow::V0::Models::CarrierAccountForm)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts").with_json(carrier_account_form.to_json).post
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def put_by_id(organization, id, carrier_account_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('carrier_account_form', carrier_account_form, ::Io::Flow::V0::Models::CarrierAccountForm)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").with_json(carrier_account_form.to_json).put
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier_account => (x = opts.delete(:carrier_account); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_account', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_account', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierAccountVersion.new(x) }
          end

        end

        class Centers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Center.new(x) }
          end

          def post(organization, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers").with_json(center_form.to_json).post
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def put_by_id(organization, id, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").with_json(center_form.to_json).put
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CenterVersion.new(x) }
          end

        end

        class DeliveryWindows

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Endpoint to request a delivery window. Requires some knowledge of origin
          # (based on organization, center, or specified address string) and destination
          # (based on ip, lat/long, or address string). Other attributes allow us to
          # narrow down delivery windows even more such as service level to be used and
          # timestamp of expected shipment date.
          def get_summary(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :strategy => (x = (x = opts.delete(:strategy); x.nil? ? "range" : x); x.is_a?(::Io::Flow::V0::Models::Strategy) ? x : ::Io::Flow::V0::Models::Strategy.apply(x)).value,
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String)),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/delivery-windows/summary").with_query(query).get
            ::Io::Flow::V0::Models::DeliveryWindow.new(r)
          end

        end

        class InventoryRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRule.new(x) }
          end

          def post(organization, inventory_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('inventory_rule_form', inventory_rule_form, ::Io::Flow::V0::Models::InventoryRuleForm)
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_json(inventory_rule_form.to_json).post
            ::Io::Flow::V0::Models::InventoryRule.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRuleVersion.new(x) }
          end

        end

        class InventorySnapshots

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshot.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventorySnapshot.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_snapshot => (x = opts.delete(:inventory_snapshot); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_snapshot', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_snapshot', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshotVersion.new(x) }
          end

        end

        class InventoryUpdates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdate.new(x) }
          end

          def post(organization, inventory_update_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('inventory_update_form', inventory_update_form, ::Io::Flow::V0::Models::InventoryUpdateForm)
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_json(inventory_update_form.to_json).post
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_update => (x = opts.delete(:inventory_update); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_update', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_update', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdateVersion.new(x) }
          end

        end

        class Labels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Label.new(x) }
          end

          def post(organization, label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('label_form', label_form, ::Io::Flow::V0::Models::LabelForm)
            r = @client.request("/#{CGI.escape(organization)}/labels").with_json(label_form.to_json).post
            ::Io::Flow::V0::Models::Label.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/labels/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Label.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :label_id => (x = opts.delete(:label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LabelVersion.new(x) }
          end

        end

        class LabelEvents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :label_id => (x = opts.delete(:label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/label_events").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LabelEvent.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/label_events/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::LabelEvent.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :label_event_id => (x = opts.delete(:label_event_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_event_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_event_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/label_events/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LabelEventVersion.new(x) }
          end

        end

        class Lanes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, Array).map { |v| HttpClient::Preconditions.assert_class('origin', v, String) }),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, Array).map { |v| HttpClient::Preconditions.assert_class('destination', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/lanes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Lane.new(x) }
          end

          def post(lane_form)
            HttpClient::Preconditions.assert_class('lane_form', lane_form, ::Io::Flow::V0::Models::LaneForm)
            r = @client.request("/lanes").with_json(lane_form.to_json).post
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/lanes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def put_by_id(id, lane_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('lane_form', lane_form, ::Io::Flow::V0::Models::LaneForm)
            r = @client.request("/lanes/#{CGI.escape(id)}").with_json(lane_form.to_json).put
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/lanes/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :lane => (x = opts.delete(:lane); x.nil? ? nil : HttpClient::Preconditions.assert_class('lane', x, Array).map { |v| HttpClient::Preconditions.assert_class('lane', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/lanes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LaneVersion.new(x) }
          end

        end

        class Quotes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search quotes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Quote.new(x) }
          end

          def post(organization, quote_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('quote_form', quote_form, ::Io::Flow::V0::Models::QuoteForm)
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_json(quote_form.to_json).post
            ::Io::Flow::V0::Models::Quote.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/quotes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Quote.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :quote => (x = opts.delete(:quote); x.nil? ? nil : HttpClient::Preconditions.assert_class('quote', x, Array).map { |v| HttpClient::Preconditions.assert_class('quote', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::QuoteVersion.new(x) }
          end

        end

        class Ratecards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Ratecard.new(x) }
          end

          def post(organization, ratecard_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_form', ratecard_form, ::Io::Flow::V0::Models::RatecardForm)
            r = @client.request("/#{CGI.escape(organization)}/ratecards").with_json(ratecard_form.to_json).post
            ::Io::Flow::V0::Models::Ratecard.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Ratecard.new(r)
          end

          def put_publish_by_id(organization, id, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(id)}/publish").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Ratecard.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardVersion.new(x) }
          end

        end

        class RatecardEstimates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Endpoint to get shipment cost estimates based on applicable rate cards. An
          # origin and destination address must be provided. Final amounts are based on
          # either gravitational weight or dimensional weight. When estimating based off
          # gravitational weight, the weight field must be set. When estimating based
          # off dimensional weight, then length/width/depth must be set. For either one,
          # the appropriate unit of measurement must be given.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :weight_unit => (x = opts.delete(:weight_unit); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x)).value),
              :distance_unit => (x = opts.delete(:distance_unit); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x)).value),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String)),
              :weight => (x = opts.delete(:weight); x.nil? ? nil : HttpClient::Preconditions.assert_class('weight', x, Numeric)),
              :length => (x = opts.delete(:length); x.nil? ? nil : HttpClient::Preconditions.assert_class('length', x, Numeric)),
              :width => (x = opts.delete(:width); x.nil? ? nil : HttpClient::Preconditions.assert_class('width', x, Numeric)),
              :depth => (x = opts.delete(:depth); x.nil? ? nil : HttpClient::Preconditions.assert_class('depth', x, Numeric)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecard_estimates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardEstimate.new(x) }
          end

        end

        class RatecardLanes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, ratecard_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardLane.new(x) }
          end

          def post(organization, ratecard_id, ratecard_lane_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('ratecard_lane_form', ratecard_lane_form, ::Io::Flow::V0::Models::RatecardLaneForm)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes").with_json(ratecard_lane_form.to_json).post
            ::Io::Flow::V0::Models::RatecardLane.new(r)
          end

          def get_by_id(organization, ratecard_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::RatecardLane.new(r)
          end

          def put_by_id(organization, ratecard_id, id, ratecard_lane_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('ratecard_lane_form', ratecard_lane_form, ::Io::Flow::V0::Models::RatecardLaneForm)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(id)}").with_json(ratecard_lane_form.to_json).put
            ::Io::Flow::V0::Models::RatecardLane.new(r)
          end

          def get_versions(organization, ratecard_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardLaneVersion.new(x) }
          end

        end

        class RatecardRates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, ratecard_id, lane_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :weight => (x = opts.delete(:weight); x.nil? ? nil : HttpClient::Preconditions.assert_class('weight', x, Array).map { |v| HttpClient::Preconditions.assert_class('weight', v, Numeric) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardRate.new(x) }
          end

          def post(organization, ratecard_id, lane_id, ratecard_rate_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            HttpClient::Preconditions.assert_class('ratecard_rate_form', ratecard_rate_form, ::Io::Flow::V0::Models::RatecardRateForm)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates").with_json(ratecard_rate_form.to_json).post
            ::Io::Flow::V0::Models::RatecardRate.new(r)
          end

          def get_by_id(organization, ratecard_id, lane_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::RatecardRate.new(r)
          end

          def put_by_id(organization, ratecard_id, lane_id, id, ratecard_lane_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('ratecard_lane_form', ratecard_lane_form, ::Io::Flow::V0::Models::RatecardLaneForm)
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates/#{CGI.escape(id)}").with_json(ratecard_lane_form.to_json).put
            ::Io::Flow::V0::Models::RatecardRate.new(r)
          end

          def get_versions(organization, ratecard_id, lane_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('ratecard_id', ratecard_id, String)
            HttpClient::Preconditions.assert_class('lane_id', lane_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/ratecards/#{CGI.escape(ratecard_id)}/lanes/#{CGI.escape(lane_id)}/rates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RatecardRateVersion.new(x) }
          end

        end

        class Services

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/services").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Service.new(x) }
          end

          def post(service_form)
            HttpClient::Preconditions.assert_class('service_form', service_form, ::Io::Flow::V0::Models::ServiceForm)
            r = @client.request("/services").with_json(service_form.to_json).post
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/services/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def put_by_id(id, service_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('service_form', service_form, ::Io::Flow::V0::Models::ServiceForm)
            r = @client.request("/services/#{CGI.escape(id)}").with_json(service_form.to_json).put
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/services/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/services/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ServiceVersion.new(x) }
          end

        end

        class Shipments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Shipment.new(x) }
          end

          def post(organization, shipment_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('shipment_form', shipment_form, ::Io::Flow::V0::Models::ShipmentForm)
            r = @client.request("/#{CGI.escape(organization)}/shipments").with_json(shipment_form.to_json).post
            ::Io::Flow::V0::Models::Shipment.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Shipment.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentVersion.new(x) }
          end

        end

        class ShipmentLabels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, tracking_number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentLabel.new(x) }
          end

          def post(organization, tracking_number, shipment_label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            HttpClient::Preconditions.assert_class('shipment_label_form', shipment_label_form, ::Io::Flow::V0::Models::ShipmentLabelForm)
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels").with_json(shipment_label_form.to_json).post
            ::Io::Flow::V0::Models::ShipmentLabel.new(r)
          end

          def get_versions(organization, tracking_number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentLabelVersion.new(x) }
          end

        end

        class Tiers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tier.new(x) }
          end

          def post(organization, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_json(tier_form.to_json).post
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def put_by_id(organization, id, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").with_json(tier_form.to_json).put
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier => (x = opts.delete(:tier); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierVersion.new(x) }
          end

        end

        class TierDefaults

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, Array).map { |v| HttpClient::Preconditions.assert_class('experience', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierDefault.new(x) }
          end

          def post(organization, tier_default_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_default_form', tier_default_form, ::Io::Flow::V0::Models::TierDefaultForm)
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults").with_json(tier_default_form.to_json).post
            ::Io::Flow::V0::Models::TierDefault.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TierDefault.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier_default => (x = opts.delete(:tier_default); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier_default', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier_default', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierDefaultVersion.new(x) }
          end

        end

        class TierRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, tier_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierRule.new(x) }
          end

          def post(organization, tier_id, tier_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('tier_rule_form', tier_rule_form, ::Io::Flow::V0::Models::TierRuleForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules").with_json(tier_rule_form.to_json).post
            ::Io::Flow::V0::Models::TierRule.new(r)
          end

          def get_by_id(organization, tier_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TierRule.new(r)
          end

          def put_by_id(organization, tier_id, id, tier_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('tier_rule_form', tier_rule_form, ::Io::Flow::V0::Models::TierRuleForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/#{CGI.escape(id)}").with_json(tier_rule_form.to_json).put
            ::Io::Flow::V0::Models::TierRule.new(r)
          end

          def delete_by_id(organization, tier_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, tier_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier_rule => (x = opts.delete(:tier_rule); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier_rule', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier_rule', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierRuleVersion.new(x) }
          end

        end

        class Trackings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tracking.new(x) }
          end

          def post(organization, tracking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_form', tracking_form, ::Io::Flow::V0::Models::TrackingForm)
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_json(tracking_form.to_json).post
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/trackings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingVersion.new(x) }
          end

        end

        class Addresses

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Geolocates the request based on the provided parameters, returning a list of
          # potential matching addresses.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/addresses").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Address.new(x) }
          end

        end

        class Countries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of countries.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/countries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

        end

        class Currencies

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of currencies.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/currencies").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Currency.new(x) }
          end

        end

        class Languages

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of languages.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/languages").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Language.new(x) }
          end

        end

        class Regions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of regions.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/regions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Region.new(x) }
          end

          # Returns the region with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/regions/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Region.new(r)
          end

        end

        class Timezones

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of timezones.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/timezones").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Timezone.new(x) }
          end

        end

        class Documents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns items based on search criteria
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :attributes => (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Array).map { |v| HttpClient::Preconditions.assert_class('attributes', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CatalogItemDocument.new(x) }
          end

          # Returns harmonization information based on search criteria
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizationDocument.new(x) }
          end

        end

        class EmailVerifications

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_token(token, hash)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/users/emails/verifications/#{CGI.escape(token)}").with_json(hash.to_json).post
            ::Io::Flow::V0::Models::EmailVerification.new(r)
          end

        end

        class Healthchecks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_healthcheck
            r = @client.request("/_internal_/healthcheck").get
            ::Io::Flow::V0::Models::Healthcheck.new(r)
          end

        end

        class Invitations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search invitations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Invitation.new(x) }
          end

          # Create a new invitation.
          def post(invitation_form)
            HttpClient::Preconditions.assert_class('invitation_form', invitation_form, ::Io::Flow::V0::Models::InvitationForm)
            r = @client.request("/invitations").with_json(invitation_form.to_json).post
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Returns information about a specific invitation.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/invitations/#{CGI.escape(id)}").delete
            nil
          end

          # Lookup an invitation by its token.
          def get_tokens_by_token(token, incoming={})
            HttpClient::Preconditions.assert_class('token', token, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Accepts the invitation w/ the specified token, creating a membership record
          # for this user within this organization. Invitations are one time use only -
          # you will get a validation error if the invitation has previously been
          # accepted.
          def put_tokens_by_token(token, invitation_accepts_form)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('invitation_accepts_form', invitation_accepts_form, ::Io::Flow::V0::Models::InvitationAcceptsForm)
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_json(invitation_accepts_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :invitation => (x = opts.delete(:invitation); x.nil? ? nil : HttpClient::Preconditions.assert_class('invitation', x, Array).map { |v| HttpClient::Preconditions.assert_class('invitation', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InvitationVersion.new(x) }
          end

        end

        class Memberships

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search memberships. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x)).value }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Membership.new(x) }
          end

          # Create a new membership.
          def post(membership_form)
            HttpClient::Preconditions.assert_class('membership_form', membership_form, ::Io::Flow::V0::Models::MembershipForm)
            r = @client.request("/memberships").with_json(membership_form.to_json).post
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Returns information about a specific membership.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Change the role for a specific membership record. If the user already has
          # the specified role within the organization, does nothing.
          def put_by_id(id, membership_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('membership_put_form', membership_put_form, ::Io::Flow::V0::Models::MembershipPutForm)
            r = @client.request("/memberships/#{CGI.escape(id)}").with_json(membership_put_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/memberships/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :membership => (x = opts.delete(:membership); x.nil? ? nil : HttpClient::Preconditions.assert_class('membership', x, Array).map { |v| HttpClient::Preconditions.assert_class('membership', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::MembershipVersion.new(x) }
          end

        end

        class Organizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organizations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :environment => (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)).value),
              :parent => (x = opts.delete(:parent); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Organization.new(x) }
          end

          # Create a new organization.
          def post(organization_form)
            HttpClient::Preconditions.assert_class('organization_form', organization_form, ::Io::Flow::V0::Models::OrganizationForm)
            r = @client.request("/organizations").with_json(organization_form.to_json).post
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Returns information about a specific organization.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Update or create an organization with the specified id.
          def put_by_id(id, organization_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('organization_put_form', organization_put_form, ::Io::Flow::V0::Models::OrganizationPutForm)
            r = @client.request("/organizations/#{CGI.escape(id)}").with_json(organization_put_form.to_json).put
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Delete the organization with this id
          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, Array).map { |v| HttpClient::Preconditions.assert_class('organization', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationVersion.new(x) }
          end

        end

        class OrganizationAuthorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # For the authorized user, if the specified organization exists, and the user
          # is an active member of this organization, returns the authorization data
          # used throughout APIs at Flow, including the user's role in that organization
          # and the organization environment. Otherwise, returns 401 - this indicates
          # either the org does not exist or the user does not have access to the org.
          def get_by_organization(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/organization-authorizations/#{CGI.escape(organization)}").get
            ::Io::Flow::V0::Models::OrganizationAuthorization.new(r)
          end

        end

        class PasswordResetForms

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(password_reset_form, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('password_reset_form', password_reset_form, ::Io::Flow::V0::Models::PasswordResetForm)
            r = @client.request("/users/passwords").with_query(query).with_json(password_reset_form.to_json).post
            ::Io::Flow::V0::Models::ExpandableUser.from_json(r)
          end

          def post_resets(password_reset_request_form)
            HttpClient::Preconditions.assert_class('password_reset_request_form', password_reset_request_form, ::Io::Flow::V0::Models::PasswordResetRequestForm)
            r = @client.request("/users/passwords/resets").with_json(password_reset_request_form.to_json).post
            nil
          end

        end

        class Suggestions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns search suggestions for catalog items
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-count" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

          # Returns search suggestions for harmonization data
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

        end

        class Tokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens that you are authorized to view. Note that the cleartext
          # token value is never sent. To view the API token itself, see the resource
          # path /:id/cleartext
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Token.new(x) }
          end

          # Create a new token for the requesting user
          def post(token_form)
            HttpClient::Preconditions.assert_class('token_form', token_form, ::Io::Flow::V0::Models::TokenForm)
            r = @client.request("/tokens").with_json(token_form.to_json).post
            ::Io::Flow::V0::Models::Token.new(r)
          end

          # Get metadata for the token with this ID
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Token.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").delete
            nil
          end

          # Retrieves the token with the actual string token in cleartext
          def get_cleartext_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}/cleartext").get
            ::Io::Flow::V0::Models::Cleartext.new(r)
          end

          # Preferred method to validate a token, obtaining user information if the
          # token is valid (or a 404 if the token does not exist). We use an HTTP POST
          # with a form body to enusre that the token itself is not logged in the
          # request logs.
          def post_authentications(token_authentication_form)
            HttpClient::Preconditions.assert_class('token_authentication_form', token_authentication_form, ::Io::Flow::V0::Models::TokenAuthenticationForm)
            r = @client.request("/tokens/authentications").with_json(token_authentication_form.to_json).post
            ::Io::Flow::V0::Models::TokenReference.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token_id => (x = opts.delete(:token_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('token_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('token_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TokenVersion.new(x) }
          end

        end

        class Users

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search users. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::User.new(x) }
          end

          # Create a new user.
          def post(user_form)
            HttpClient::Preconditions.assert_class('user_form', user_form, ::Io::Flow::V0::Models::UserForm)
            r = @client.request("/users").with_json(user_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Returns information about a specific user.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update a user.
          def put_by_id(id, user_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('user_put_form', user_put_form, ::Io::Flow::V0::Models::UserPutForm)
            r = @client.request("/users/#{CGI.escape(id)}").with_json(user_put_form.to_json).put
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update the password for a user.
          def patch_passwords_by_id(id, password_change_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('password_change_form', password_change_form, ::Io::Flow::V0::Models::PasswordChangeForm)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").with_json(password_change_form.to_json).patch
            nil
          end

          # Deletes a password for the given user.
          def delete_passwords_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").delete
            nil
          end

          # Authenticates a user by email / password.
          def post_authenticate(authentication_form)
            HttpClient::Preconditions.assert_class('authentication_form', authentication_form, ::Io::Flow::V0::Models::AuthenticationForm)
            r = @client.request("/users/authenticate").with_json(authentication_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user_id => (x = opts.delete(:user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('user_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::UserVersion.new(x) }
          end

        end

        class Validations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(validation_form)
            HttpClient::Preconditions.assert_class('validation_form', validation_form, ::Io::Flow::V0::Models::ValidationForm)
            r = @client.request("/token-validations").with_json(validation_form.to_json).post
            ::Io::Flow::V0::Models::Validation.new(r)
          end

        end

      end

      module Models

        # Represents all possible responses from an authorization attempt
        class AuthorizationDetails

          module Types
            AUTHORIZATION_DETAILS_DECLINE = 'authorization_details_decline' unless defined?(AUTHORIZATION_DETAILS_DECLINE)
            AUTHORIZATION_DETAILS_SUCCESS = 'authorization_details_success' unless defined?(AUTHORIZATION_DETAILS_SUCCESS)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'AuthorizationDetails')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def AuthorizationDetails.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::AUTHORIZATION_DETAILS_DECLINE; AuthorizationDetailsDecline.new(hash)
              when Types::AUTHORIZATION_DETAILS_SUCCESS; AuthorizationDetailsSuccess.new(hash)
              else AuthorizationDetailsUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class AuthorizationDetailsUndefinedType < AuthorizationDetails

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Deminimus

          module Types
            DEMINIMUS_SIMPLE = 'deminimus_simple' unless defined?(DEMINIMUS_SIMPLE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Deminimus')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Deminimus.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::DEMINIMUS_SIMPLE; DeminimusSimple.new(hash)
              else DeminimusUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class DeminimusUndefinedType < Deminimus

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Document

          module Types
            CATALOG_ITEM_DOCUMENT = 'catalog_item_document' unless defined?(CATALOG_ITEM_DOCUMENT)
            HARMONIZATION_DOCUMENT = 'harmonization_document' unless defined?(HARMONIZATION_DOCUMENT)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Document')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Document.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::CATALOG_ITEM_DOCUMENT; CatalogItemDocument.new(hash)
              when Types::HARMONIZATION_DOCUMENT; HarmonizationDocument.new(hash)
              else DocumentUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class DocumentUndefinedType < Document

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # An item function can be represented with just it's Id, or the entire model
        class ExpandableItemFunction

          module Types
            ITEM_FUNCTION = 'item_function' unless defined?(ITEM_FUNCTION)
            ITEM_FUNCTION_REFERENCE = 'item_function_reference' unless defined?(ITEM_FUNCTION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableItemFunction')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableItemFunction.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::ITEM_FUNCTION; ItemFunction.new(hash)
              when Types::ITEM_FUNCTION_REFERENCE; ItemFunctionReference.new(hash)
              else ExpandableItemFunctionUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableItemFunctionUndefinedType < ExpandableItemFunction

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableOrganization

          module Types
            ORGANIZATION = 'organization' unless defined?(ORGANIZATION)
            ORGANIZATION_REFERENCE = 'organization_reference' unless defined?(ORGANIZATION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableOrganization')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableOrganization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::ORGANIZATION; Organization.new(hash)
              when Types::ORGANIZATION_REFERENCE; OrganizationReference.new(hash)
              else ExpandableOrganizationUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableOrganizationUndefinedType < ExpandableOrganization

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A subcatalog can be represented with just it's ID, or the entire model
        class ExpandableSubcatalog

          module Types
            SUBCATALOG = 'subcatalog' unless defined?(SUBCATALOG)
            SUBCATALOG_REFERENCE = 'subcatalog_reference' unless defined?(SUBCATALOG_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableSubcatalog')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableSubcatalog.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::SUBCATALOG; Subcatalog.new(hash)
              when Types::SUBCATALOG_REFERENCE; SubcatalogReference.new(hash)
              else ExpandableSubcatalogUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableSubcatalogUndefinedType < ExpandableSubcatalog

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableUser

          module Types
            USER = 'user' unless defined?(USER)
            USER_REFERENCE = 'user_reference' unless defined?(USER_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableUser')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableUser.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::USER; User.new(hash)
              when Types::USER_REFERENCE; UserReference.new(hash)
              else ExpandableUserUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableUserUndefinedType < ExpandableUser

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Types of rules used to apply on inventory to calculate available quantity
        class InventoryStrategy

          module Types
            # Enables backorders, setting an optional number of units that we allow for
            # backorder. For example, a backorder w/ quantity 10 will enable selling until
            # the actual inventory quantity is -10.
            INVENTORY_BACKORDER = 'inventory_backorder' unless defined?(INVENTORY_BACKORDER)
            # Treats inventory as available as long as the actual inventory quantity is >
            # the specified quantity. A common use case is to set quantity to zero to
            # indicate availability as long as there is at least 1 unit available.
            INVENTORY_STOCK = 'inventory_stock' unless defined?(INVENTORY_STOCK)
            # Items affected with rules pursuing an unlimited strategy will always be
            # available
            INVENTORY_UNLIMITED = 'inventory_unlimited' unless defined?(INVENTORY_UNLIMITED)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'InventoryStrategy')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def InventoryStrategy.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::INVENTORY_BACKORDER; InventoryBackorder.new(hash)
              when Types::INVENTORY_STOCK; InventoryStock.new(hash)
              when Types::INVENTORY_UNLIMITED; InventoryUnlimited.new(hash)
              else InventoryStrategyUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class InventoryStrategyUndefinedType < InventoryStrategy

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class RatecardFee

          module Types
            DDP = 'ddp' unless defined?(DDP)
            FUEL_SURCHARGE = 'fuel_surcharge' unless defined?(FUEL_SURCHARGE)
            OVERSIZED_SHIPMENT = 'oversized_shipment' unless defined?(OVERSIZED_SHIPMENT)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'RatecardFee')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def RatecardFee.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::DDP; Ddp.new(hash)
              when Types::FUEL_SURCHARGE; FuelSurcharge.new(hash)
              when Types::OVERSIZED_SHIPMENT; OversizedShipment.new(hash)
              else RatecardFeeUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class RatecardFeeUndefinedType < RatecardFee

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Possible outcome types from a tier rule
        class TierRuleOutcome

          module Types
            # Add a certain amount on the actual base cost
            AMOUNT_MARGIN = 'amount_margin' unless defined?(AMOUNT_MARGIN)
            AT_COST = 'at_cost' unless defined?(AT_COST)
            FLAT_RATE = 'flat_rate' unless defined?(FLAT_RATE)
            FREE_SHIPPING = 'free_shipping' unless defined?(FREE_SHIPPING)
            # Add a certain percentage of the actual base cost
            PERCENT_MARGIN = 'percent_margin' unless defined?(PERCENT_MARGIN)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'TierRuleOutcome')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def TierRuleOutcome.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::AMOUNT_MARGIN; AmountMargin.new(hash)
              when Types::AT_COST; AtCost.new(hash)
              when Types::FLAT_RATE; FlatRate.new(hash)
              when Types::FREE_SHIPPING; FreeShipping.new(hash)
              when Types::PERCENT_MARGIN; PercentMargin.new(hash)
              else TierRuleOutcomeUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class TierRuleOutcomeUndefinedType < TierRuleOutcome

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Calendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Calendar for this value, creating a new instance for an unknown value
          def Calendar.apply(value)
            if value.instance_of?(Calendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Calendar.new(value))
            end
          end

          # Returns the instance of Calendar for this value, or nil if not found
          def Calendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Calendar.ALL.find { |v| v.value == value }
          end

          def Calendar.ALL
            @@all ||= [Calendar.weekdays, Calendar.everyday]
          end

          # Mon - Fri
          def Calendar.weekdays
            @@_weekdays ||= Calendar.new('weekdays')
          end

          # 7 days per week
          def Calendar.everyday
            @@_everyday ||= Calendar.new('everyday')
          end

          def to_hash
            value
          end

        end

        class Capability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Capability for this value, creating a new instance for an unknown value
          def Capability.apply(value)
            if value.instance_of?(Capability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Capability.new(value))
            end
          end

          # Returns the instance of Capability for this value, or nil if not found
          def Capability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Capability.ALL.find { |v| v.value == value }
          end

          def Capability.ALL
            @@all ||= [Capability.crossdock]
          end

          def Capability.crossdock
            @@_crossdock ||= Capability.new('crossdock')
          end

          def to_hash
            value
          end

        end

        class CardType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CardType for this value, creating a new instance for an unknown value
          def CardType.apply(value)
            if value.instance_of?(CardType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CardType.new(value))
            end
          end

          # Returns the instance of CardType for this value, or nil if not found
          def CardType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CardType.ALL.find { |v| v.value == value }
          end

          def CardType.ALL
            @@all ||= [CardType.visa, CardType.mastercard, CardType.american_express, CardType.diners_club, CardType.discover, CardType.jcb, CardType.china_union_pay]
          end

          def CardType.visa
            @@_visa ||= CardType.new('visa')
          end

          def CardType.mastercard
            @@_mastercard ||= CardType.new('mastercard')
          end

          def CardType.american_express
            @@_american_express ||= CardType.new('american_express')
          end

          def CardType.diners_club
            @@_diners_club ||= CardType.new('diners_club')
          end

          def CardType.discover
            @@_discover ||= CardType.new('discover')
          end

          def CardType.jcb
            @@_jcb ||= CardType.new('jcb')
          end

          def CardType.china_union_pay
            @@_china_union_pay ||= CardType.new('china_union_pay')
          end

          def to_hash
            value
          end

        end

        class ChangeType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ChangeType for this value, creating a new instance for an unknown value
          def ChangeType.apply(value)
            if value.instance_of?(ChangeType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ChangeType.new(value))
            end
          end

          # Returns the instance of ChangeType for this value, or nil if not found
          def ChangeType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ChangeType.ALL.find { |v| v.value == value }
          end

          def ChangeType.ALL
            @@all ||= [ChangeType.insert, ChangeType.update, ChangeType.delete]
          end

          def ChangeType.insert
            @@_insert ||= ChangeType.new('insert')
          end

          def ChangeType.update
            @@_update ||= ChangeType.new('update')
          end

          def ChangeType.delete
            @@_delete ||= ChangeType.new('delete')
          end

          def to_hash
            value
          end

        end

        class DeliveredDuty

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveredDuty for this value, creating a new instance for an unknown value
          def DeliveredDuty.apply(value)
            if value.instance_of?(DeliveredDuty)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveredDuty.new(value))
            end
          end

          # Returns the instance of DeliveredDuty for this value, or nil if not found
          def DeliveredDuty.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveredDuty.ALL.find { |v| v.value == value }
          end

          def DeliveredDuty.ALL
            @@all ||= [DeliveredDuty.paid, DeliveredDuty.unpaid, DeliveredDuty.choice]
          end

          # DDP
          def DeliveredDuty.paid
            @@_paid ||= DeliveredDuty.new('paid')
          end

          # DDU
          def DeliveredDuty.unpaid
            @@_unpaid ||= DeliveredDuty.new('unpaid')
          end

          def DeliveredDuty.choice
            @@_choice ||= DeliveredDuty.new('choice')
          end

          def to_hash
            value
          end

        end

        class Environment

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Environment for this value, creating a new instance for an unknown value
          def Environment.apply(value)
            if value.instance_of?(Environment)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Environment.new(value))
            end
          end

          # Returns the instance of Environment for this value, or nil if not found
          def Environment.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Environment.ALL.find { |v| v.value == value }
          end

          def Environment.ALL
            @@all ||= [Environment.sandbox, Environment.production]
          end

          # In sandbox, no external services (e.g. payments, logistics) will generate real
          # transactions
          def Environment.sandbox
            @@_sandbox ||= Environment.new('sandbox')
          end

          # In production, all external services are live and will generate real
          # transactions
          def Environment.production
            @@_production ||= Environment.new('production')
          end

          def to_hash
            value
          end

        end

        class ExceptionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExceptionType for this value, creating a new instance for an unknown value
          def ExceptionType.apply(value)
            if value.instance_of?(ExceptionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExceptionType.new(value))
            end
          end

          # Returns the instance of ExceptionType for this value, or nil if not found
          def ExceptionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExceptionType.ALL.find { |v| v.value == value }
          end

          def ExceptionType.ALL
            @@all ||= [ExceptionType.open, ExceptionType.closed]
          end

          def ExceptionType.open
            @@_open ||= ExceptionType.new('open')
          end

          def ExceptionType.closed
            @@_closed ||= ExceptionType.new('closed')
          end

          def to_hash
            value
          end

        end

        class HolidayCalendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of HolidayCalendar for this value, creating a new instance for an unknown value
          def HolidayCalendar.apply(value)
            if value.instance_of?(HolidayCalendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || HolidayCalendar.new(value))
            end
          end

          # Returns the instance of HolidayCalendar for this value, or nil if not found
          def HolidayCalendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            HolidayCalendar.ALL.find { |v| v.value == value }
          end

          def HolidayCalendar.ALL
            @@all ||= [HolidayCalendar.us_bank_holidays, HolidayCalendar.jewish_holidays]
          end

          def HolidayCalendar.us_bank_holidays
            @@_us_bank_holidays ||= HolidayCalendar.new('us_bank_holidays')
          end

          def HolidayCalendar.jewish_holidays
            @@_jewish_holidays ||= HolidayCalendar.new('jewish_holidays')
          end

          def to_hash
            value
          end

        end

        class LevyComponent

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyComponent for this value, creating a new instance for an unknown value
          def LevyComponent.apply(value)
            if value.instance_of?(LevyComponent)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyComponent.new(value))
            end
          end

          # Returns the instance of LevyComponent for this value, or nil if not found
          def LevyComponent.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyComponent.ALL.find { |v| v.value == value }
          end

          def LevyComponent.ALL
            @@all ||= [LevyComponent.goods, LevyComponent.duty, LevyComponent.insurance, LevyComponent.freight, LevyComponent.vat]
          end

          # The value of goods
          def LevyComponent.goods
            @@_goods ||= LevyComponent.new('goods')
          end

          def LevyComponent.duty
            @@_duty ||= LevyComponent.new('duty')
          end

          def LevyComponent.insurance
            @@_insurance ||= LevyComponent.new('insurance')
          end

          def LevyComponent.freight
            @@_freight ||= LevyComponent.new('freight')
          end

          # Value-Added Tax
          def LevyComponent.vat
            @@_vat ||= LevyComponent.new('vat')
          end

          def to_hash
            value
          end

        end

        class LevyStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyStrategy for this value, creating a new instance for an unknown value
          def LevyStrategy.apply(value)
            if value.instance_of?(LevyStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyStrategy.new(value))
            end
          end

          # Returns the instance of LevyStrategy for this value, or nil if not found
          def LevyStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyStrategy.ALL.find { |v| v.value == value }
          end

          def LevyStrategy.ALL
            @@all ||= [LevyStrategy.minimum, LevyStrategy.average, LevyStrategy.maximum]
          end

          def LevyStrategy.minimum
            @@_minimum ||= LevyStrategy.new('minimum')
          end

          def LevyStrategy.average
            @@_average ||= LevyStrategy.new('average')
          end

          def LevyStrategy.maximum
            @@_maximum ||= LevyStrategy.new('maximum')
          end

          def to_hash
            value
          end

        end

        class LocalizedPriceKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LocalizedPriceKey for this value, creating a new instance for an unknown value
          def LocalizedPriceKey.apply(value)
            if value.instance_of?(LocalizedPriceKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LocalizedPriceKey.new(value))
            end
          end

          # Returns the instance of LocalizedPriceKey for this value, or nil if not found
          def LocalizedPriceKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LocalizedPriceKey.ALL.find { |v| v.value == value }
          end

          def LocalizedPriceKey.ALL
            @@all ||= [LocalizedPriceKey.price, LocalizedPriceKey.subtotal, LocalizedPriceKey.vat, LocalizedPriceKey.duty, LocalizedPriceKey.shipping, LocalizedPriceKey.total]
          end

          # The calculated price, taking into account pricing settings. For example, if
          # vat is set to be included in the price, this value will be equal to subtotal +
          # vat, rounded per the settings. This is the price you should lead with when
          # displaying to consumers
          def LocalizedPriceKey.price
            @@_price ||= LocalizedPriceKey.new('price')
          end

          def LocalizedPriceKey.subtotal
            @@_subtotal ||= LocalizedPriceKey.new('subtotal')
          end

          def LocalizedPriceKey.vat
            @@_vat ||= LocalizedPriceKey.new('vat')
          end

          def LocalizedPriceKey.duty
            @@_duty ||= LocalizedPriceKey.new('duty')
          end

          def LocalizedPriceKey.shipping
            @@_shipping ||= LocalizedPriceKey.new('shipping')
          end

          def LocalizedPriceKey.total
            @@_total ||= LocalizedPriceKey.new('total')
          end

          def to_hash
            value
          end

        end

        class MarginType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MarginType for this value, creating a new instance for an unknown value
          def MarginType.apply(value)
            if value.instance_of?(MarginType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MarginType.new(value))
            end
          end

          # Returns the instance of MarginType for this value, or nil if not found
          def MarginType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MarginType.ALL.find { |v| v.value == value }
          end

          def MarginType.ALL
            @@all ||= [MarginType.fixed, MarginType.percent]
          end

          # A fixed amount to add, e.g $1.25.
          def MarginType.fixed
            @@_fixed ||= MarginType.new('fixed')
          end

          # A percent of the base cost to add, e.g. 0.52 (52%).
          def MarginType.percent
            @@_percent ||= MarginType.new('percent')
          end

          def to_hash
            value
          end

        end

        class MeasurementSystem

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MeasurementSystem for this value, creating a new instance for an unknown value
          def MeasurementSystem.apply(value)
            if value.instance_of?(MeasurementSystem)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MeasurementSystem.new(value))
            end
          end

          # Returns the instance of MeasurementSystem for this value, or nil if not found
          def MeasurementSystem.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MeasurementSystem.ALL.find { |v| v.value == value }
          end

          def MeasurementSystem.ALL
            @@all ||= [MeasurementSystem.imperial, MeasurementSystem.metric]
          end

          def MeasurementSystem.imperial
            @@_imperial ||= MeasurementSystem.new('imperial')
          end

          def MeasurementSystem.metric
            @@_metric ||= MeasurementSystem.new('metric')
          end

          def to_hash
            value
          end

        end

        class PricingLevySetting

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PricingLevySetting for this value, creating a new instance for an unknown value
          def PricingLevySetting.apply(value)
            if value.instance_of?(PricingLevySetting)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PricingLevySetting.new(value))
            end
          end

          # Returns the instance of PricingLevySetting for this value, or nil if not found
          def PricingLevySetting.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PricingLevySetting.ALL.find { |v| v.value == value }
          end

          def PricingLevySetting.ALL
            @@all ||= [PricingLevySetting.included, PricingLevySetting.displayed, PricingLevySetting.ignored]
          end

          def PricingLevySetting.included
            @@_included ||= PricingLevySetting.new('included')
          end

          def PricingLevySetting.displayed
            @@_displayed ||= PricingLevySetting.new('displayed')
          end

          def PricingLevySetting.ignored
            @@_ignored ||= PricingLevySetting.new('ignored')
          end

          def to_hash
            value
          end

        end

        class QueryType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of QueryType for this value, creating a new instance for an unknown value
          def QueryType.apply(value)
            if value.instance_of?(QueryType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || QueryType.new(value))
            end
          end

          # Returns the instance of QueryType for this value, or nil if not found
          def QueryType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            QueryType.ALL.find { |v| v.value == value }
          end

          def QueryType.ALL
            @@all ||= [QueryType.exclusion, QueryType.inclusion]
          end

          # Exclude items satisfied by the associated query
          def QueryType.exclusion
            @@_exclusion ||= QueryType.new('exclusion')
          end

          # Include items satisfied by the associated query
          def QueryType.inclusion
            @@_inclusion ||= QueryType.new('inclusion')
          end

          def to_hash
            value
          end

        end

        class Role

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Role for this value, creating a new instance for an unknown value
          def Role.apply(value)
            if value.instance_of?(Role)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Role.new(value))
            end
          end

          # Returns the instance of Role for this value, or nil if not found
          def Role.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Role.ALL.find { |v| v.value == value }
          end

          def Role.ALL
            @@all ||= [Role.admin, Role.member]
          end

          def Role.admin
            @@_admin ||= Role.new('admin')
          end

          def Role.member
            @@_member ||= Role.new('member')
          end

          def to_hash
            value
          end

        end

        class RoundingMethod

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingMethod for this value, creating a new instance for an unknown value
          def RoundingMethod.apply(value)
            if value.instance_of?(RoundingMethod)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingMethod.new(value))
            end
          end

          # Returns the instance of RoundingMethod for this value, or nil if not found
          def RoundingMethod.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingMethod.ALL.find { |v| v.value == value }
          end

          def RoundingMethod.ALL
            @@all ||= [RoundingMethod.up, RoundingMethod.down, RoundingMethod.nearest]
          end

          # Round up to the specified rounding.value
          def RoundingMethod.up
            @@_up ||= RoundingMethod.new('up')
          end

          # Round down to the specified rounding.value
          def RoundingMethod.down
            @@_down ||= RoundingMethod.new('down')
          end

          # Round to the nearest specified rounding.value. If equidistant, will round up.
          def RoundingMethod.nearest
            @@_nearest ||= RoundingMethod.new('nearest')
          end

          def to_hash
            value
          end

        end

        class RoundingType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingType for this value, creating a new instance for an unknown value
          def RoundingType.apply(value)
            if value.instance_of?(RoundingType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingType.new(value))
            end
          end

          # Returns the instance of RoundingType for this value, or nil if not found
          def RoundingType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingType.ALL.find { |v| v.value == value }
          end

          def RoundingType.ALL
            @@all ||= [RoundingType.pattern, RoundingType.multiple]
          end

          # Rounds a value to an amount ending with a pattern, e.g. an amount ending in
          # '.99'.
          def RoundingType.pattern
            @@_pattern ||= RoundingType.new('pattern')
          end

          # Rounds a value to an amount that is the multiple of a value, e.g. rounding to
          # the nearest 1000.
          def RoundingType.multiple
            @@_multiple ||= RoundingType.new('multiple')
          end

          def to_hash
            value
          end

        end

        class ScheduleExceptionStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ScheduleExceptionStatus for this value, creating a new instance for an unknown value
          def ScheduleExceptionStatus.apply(value)
            if value.instance_of?(ScheduleExceptionStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ScheduleExceptionStatus.new(value))
            end
          end

          # Returns the instance of ScheduleExceptionStatus for this value, or nil if not found
          def ScheduleExceptionStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ScheduleExceptionStatus.ALL.find { |v| v.value == value }
          end

          def ScheduleExceptionStatus.ALL
            @@all ||= [ScheduleExceptionStatus.open, ScheduleExceptionStatus.closed]
          end

          def ScheduleExceptionStatus.open
            @@_open ||= ScheduleExceptionStatus.new('Open')
          end

          def ScheduleExceptionStatus.closed
            @@_closed ||= ScheduleExceptionStatus.new('Closed')
          end

          def to_hash
            value
          end

        end

        class ShipmentIntegrationType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShipmentIntegrationType for this value, creating a new instance for an unknown value
          def ShipmentIntegrationType.apply(value)
            if value.instance_of?(ShipmentIntegrationType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShipmentIntegrationType.new(value))
            end
          end

          # Returns the instance of ShipmentIntegrationType for this value, or nil if not found
          def ShipmentIntegrationType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShipmentIntegrationType.ALL.find { |v| v.value == value }
          end

          def ShipmentIntegrationType.ALL
            @@all ||= [ShipmentIntegrationType.direct, ShipmentIntegrationType.information, ShipmentIntegrationType.preadvice]
          end

          # Always generate a label for the chosen delivery option.
          def ShipmentIntegrationType.direct
            @@_direct ||= ShipmentIntegrationType.new('direct')
          end

          # Booking and label generation is not available. Just use Flow to calculate
          # delivery window estimates and shipment prices to display.
          def ShipmentIntegrationType.information
            @@_information ||= ShipmentIntegrationType.new('information')
          end

          # A generic label will be provided by the client organization when available as
          # pre-advice shipment notification to carrier partner.
          def ShipmentIntegrationType.preadvice
            @@_preadvice ||= ShipmentIntegrationType.new('preadvice')
          end

          def to_hash
            value
          end

        end

        class SortDirection

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SortDirection for this value, creating a new instance for an unknown value
          def SortDirection.apply(value)
            if value.instance_of?(SortDirection)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SortDirection.new(value))
            end
          end

          # Returns the instance of SortDirection for this value, or nil if not found
          def SortDirection.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SortDirection.ALL.find { |v| v.value == value }
          end

          def SortDirection.ALL
            @@all ||= [SortDirection.ascending, SortDirection.descending]
          end

          def SortDirection.ascending
            @@_ascending ||= SortDirection.new('ascending')
          end

          def SortDirection.descending
            @@_descending ||= SortDirection.new('descending')
          end

          def to_hash
            value
          end

        end

        class Strategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Strategy for this value, creating a new instance for an unknown value
          def Strategy.apply(value)
            if value.instance_of?(Strategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Strategy.new(value))
            end
          end

          # Returns the instance of Strategy for this value, or nil if not found
          def Strategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Strategy.ALL.find { |v| v.value == value }
          end

          def Strategy.ALL
            @@all ||= [Strategy.range, Strategy.from, Strategy.to]
          end

          # Tightest range
          def Strategy.range
            @@_range ||= Strategy.new('range')
          end

          # Lowest minimum of the ranges
          def Strategy.from
            @@_from ||= Strategy.new('from')
          end

          # Lowest maximum of the ranges
          def Strategy.to
            @@_to ||= Strategy.new('to')
          end

          def to_hash
            value
          end

        end

        class SubcatalogItemStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SubcatalogItemStatus for this value, creating a new instance for an unknown value
          def SubcatalogItemStatus.apply(value)
            if value.instance_of?(SubcatalogItemStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SubcatalogItemStatus.new(value))
            end
          end

          # Returns the instance of SubcatalogItemStatus for this value, or nil if not found
          def SubcatalogItemStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SubcatalogItemStatus.ALL.find { |v| v.value == value }
          end

          def SubcatalogItemStatus.ALL
            @@all ||= [SubcatalogItemStatus.excluded, SubcatalogItemStatus.included, SubcatalogItemStatus.restricted]
          end

          # Item is excluded based on targeting query.  This is separate from an item
          # marked as restricted.
          def SubcatalogItemStatus.excluded
            @@_excluded ||= SubcatalogItemStatus.new('excluded')
          end

          # Item is included
          def SubcatalogItemStatus.included
            @@_included ||= SubcatalogItemStatus.new('included')
          end

          # Item is restricted and will be treated as excluded
          def SubcatalogItemStatus.restricted
            @@_restricted ||= SubcatalogItemStatus.new('restricted')
          end

          def to_hash
            value
          end

        end

        class TierStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TierStrategy for this value, creating a new instance for an unknown value
          def TierStrategy.apply(value)
            if value.instance_of?(TierStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TierStrategy.new(value))
            end
          end

          # Returns the instance of TierStrategy for this value, or nil if not found
          def TierStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TierStrategy.ALL.find { |v| v.value == value }
          end

          def TierStrategy.ALL
            @@all ||= [TierStrategy.fastest, TierStrategy.lowest_cost]
          end

          # Optimize for fastest first, then cheapest
          def TierStrategy.fastest
            @@_fastest ||= TierStrategy.new('fastest')
          end

          # Optimize for lowest cost first, then fastest
          def TierStrategy.lowest_cost
            @@_lowest_cost ||= TierStrategy.new('lowest_cost')
          end

          def to_hash
            value
          end

        end

        class TrackingStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TrackingStatus for this value, creating a new instance for an unknown value
          def TrackingStatus.apply(value)
            if value.instance_of?(TrackingStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TrackingStatus.new(value))
            end
          end

          # Returns the instance of TrackingStatus for this value, or nil if not found
          def TrackingStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TrackingStatus.ALL.find { |v| v.value == value }
          end

          def TrackingStatus.ALL
            @@all ||= [TrackingStatus.pending, TrackingStatus.info_received, TrackingStatus.in_transit, TrackingStatus.out_for_delivery, TrackingStatus.attempt_fail, TrackingStatus.delivered, TrackingStatus.exception, TrackingStatus.expired]
          end

          def TrackingStatus.pending
            @@_pending ||= TrackingStatus.new('pending')
          end

          def TrackingStatus.info_received
            @@_info_received ||= TrackingStatus.new('info_received')
          end

          def TrackingStatus.in_transit
            @@_in_transit ||= TrackingStatus.new('in_transit')
          end

          def TrackingStatus.out_for_delivery
            @@_out_for_delivery ||= TrackingStatus.new('out_for_delivery')
          end

          def TrackingStatus.attempt_fail
            @@_attempt_fail ||= TrackingStatus.new('attempt_fail')
          end

          def TrackingStatus.delivered
            @@_delivered ||= TrackingStatus.new('delivered')
          end

          def TrackingStatus.exception
            @@_exception ||= TrackingStatus.new('exception')
          end

          def TrackingStatus.expired
            @@_expired ||= TrackingStatus.new('expired')
          end

          def to_hash
            value
          end

        end

        class UnitOfMeasurement

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfMeasurement for this value, creating a new instance for an unknown value
          def UnitOfMeasurement.apply(value)
            if value.instance_of?(UnitOfMeasurement)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfMeasurement.new(value))
            end
          end

          # Returns the instance of UnitOfMeasurement for this value, or nil if not found
          def UnitOfMeasurement.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfMeasurement.ALL.find { |v| v.value == value }
          end

          def UnitOfMeasurement.ALL
            @@all ||= [UnitOfMeasurement.millimeter, UnitOfMeasurement.centimeter, UnitOfMeasurement.inch, UnitOfMeasurement.foot, UnitOfMeasurement.cubic_inch, UnitOfMeasurement.cubic_meter, UnitOfMeasurement.gram, UnitOfMeasurement.kilogram, UnitOfMeasurement.meter, UnitOfMeasurement.ounce, UnitOfMeasurement.pound]
          end

          # Equivalent to MILLI(METRE).
          def UnitOfMeasurement.millimeter
            @@_millimeter ||= UnitOfMeasurement.new('millimeter')
          end

          # Equivalent to CENTI(METRE).
          def UnitOfMeasurement.centimeter
            @@_centimeter ||= UnitOfMeasurement.new('centimeter')
          end

          # A unit of length equal to 0.01004 m (standard name in).
          def UnitOfMeasurement.inch
            @@_inch ||= UnitOfMeasurement.new('inch')
          end

          # A unit of length equal to 0.3048 m (standard name ft).
          def UnitOfMeasurement.foot
            @@_foot ||= UnitOfMeasurement.new('foot')
          end

          # A unit of volume equal to one cubic inch (in).
          def UnitOfMeasurement.cubic_inch
            @@_cubic_inch ||= UnitOfMeasurement.new('cubic_inch')
          end

          # The metric unit for volume quantities (m).
          def UnitOfMeasurement.cubic_meter
            @@_cubic_meter ||= UnitOfMeasurement.new('cubic_meter')
          end

          # A unit of mass equal to 1 / 1000 kilogram (standard name g).
          def UnitOfMeasurement.gram
            @@_gram ||= UnitOfMeasurement.new('gram')
          end

          # The base unit for mass quantities (kg).
          def UnitOfMeasurement.kilogram
            @@_kilogram ||= UnitOfMeasurement.new('kilogram')
          end

          # The base unit for length quantities (m).
          def UnitOfMeasurement.meter
            @@_meter ||= UnitOfMeasurement.new('meter')
          end

          # A unit of mass equal to 1 / 16 POUND (standard name oz).
          def UnitOfMeasurement.ounce
            @@_ounce ||= UnitOfMeasurement.new('ounce')
          end

          # A unit of mass equal to 453.59237 grams (avoirdupois pound, standard name lb).
          def UnitOfMeasurement.pound
            @@_pound ||= UnitOfMeasurement.new('pound')
          end

          def to_hash
            value
          end

        end

        class UnitOfTime

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfTime for this value, creating a new instance for an unknown value
          def UnitOfTime.apply(value)
            if value.instance_of?(UnitOfTime)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfTime.new(value))
            end
          end

          # Returns the instance of UnitOfTime for this value, or nil if not found
          def UnitOfTime.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfTime.ALL.find { |v| v.value == value }
          end

          def UnitOfTime.ALL
            @@all ||= [UnitOfTime.day, UnitOfTime.hour, UnitOfTime.minute]
          end

          def UnitOfTime.day
            @@_day ||= UnitOfTime.new('day')
          end

          def UnitOfTime.hour
            @@_hour ||= UnitOfTime.new('hour')
          end

          def UnitOfTime.minute
            @@_minute ||= UnitOfTime.new('minute')
          end

          def to_hash
            value
          end

        end

        class UpdatePolicy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdatePolicy for this value, creating a new instance for an unknown value
          def UpdatePolicy.apply(value)
            if value.instance_of?(UpdatePolicy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdatePolicy.new(value))
            end
          end

          # Returns the instance of UpdatePolicy for this value, or nil if not found
          def UpdatePolicy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdatePolicy.ALL.find { |v| v.value == value }
          end

          def UpdatePolicy.ALL
            @@all ||= [UpdatePolicy.auto, UpdatePolicy.queue, UpdatePolicy.discard]
          end

          def UpdatePolicy.auto
            @@_auto ||= UpdatePolicy.new('auto')
          end

          # Queue item update for approval.
          def UpdatePolicy.queue
            @@_queue ||= UpdatePolicy.new('queue')
          end

          def UpdatePolicy.discard
            @@_discard ||= UpdatePolicy.new('discard')
          end

          def to_hash
            value
          end

        end

        class UpdateType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdateType for this value, creating a new instance for an unknown value
          def UpdateType.apply(value)
            if value.instance_of?(UpdateType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdateType.new(value))
            end
          end

          # Returns the instance of UpdateType for this value, or nil if not found
          def UpdateType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdateType.ALL.find { |v| v.value == value }
          end

          def UpdateType.ALL
            @@all ||= [UpdateType.change, UpdateType.set]
          end

          # Long value to increment or decrement. Positive quantities are added to
          # inventory while negative quantities are decrement from inventory.
          def UpdateType.change
            @@_change ||= UpdateType.new('change')
          end

          # Set aboluste quantity to new value with no regard for previous updates
          def UpdateType.set
            @@_set ||= UpdateType.new('set')
          end

          def to_hash
            value
          end

        end

        class ValueAddedService

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ValueAddedService for this value, creating a new instance for an unknown value
          def ValueAddedService.apply(value)
            if value.instance_of?(ValueAddedService)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ValueAddedService.new(value))
            end
          end

          # Returns the instance of ValueAddedService for this value, or nil if not found
          def ValueAddedService.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ValueAddedService.ALL.find { |v| v.value == value }
          end

          def ValueAddedService.ALL
            @@all ||= [ValueAddedService.hazardous_material]
          end

          # See https://en.wikipedia.org/wiki/ORM-D
          def ValueAddedService.hazardous_material
            @@_hazardous_material ||= ValueAddedService.new('Hazardous Material')
          end

          def to_hash
            value
          end

        end

        class Visibility

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Visibility for this value, creating a new instance for an unknown value
          def Visibility.apply(value)
            if value.instance_of?(Visibility)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Visibility.new(value))
            end
          end

          # Returns the instance of Visibility for this value, or nil if not found
          def Visibility.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Visibility.ALL.find { |v| v.value == value }
          end

          def Visibility.ALL
            @@all ||= [Visibility.public, Visibility.private]
          end

          def Visibility.public
            @@_public ||= Visibility.new('public')
          end

          def Visibility.private
            @@_private ||= Visibility.new('private')
          end

          def to_hash
            value
          end

        end

        # Defines structured fields for address to be used in user/form input. Either
        # text or the structured input needs to be present.
        class Address

          attr_reader :text, :streets, :city, :province, :postal, :country, :latitude, :longitude

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @latitude = (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String))
            @longitude = (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Address.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :text => text,
              :streets => streets.nil? ? nil : streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :latitude => latitude,
              :longitude => longitude
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin price
        class AmountMargin < TierRuleOutcome

          attr_reader :addition

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::AMOUNT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:addition], 'AmountMargin')
            @addition = (x = opts.delete(:addition); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AmountMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :addition => addition.to_hash
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost of the service
        class AtCost < TierRuleOutcome

          attr_reader :ignore

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::AT_COST)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ignore = (x = opts.delete(:ignore); x.nil? ? nil : HttpClient::Preconditions.assert_class('ignore', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AtCost.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :ignore => ignore
            }
          end

        end

        # An attribute can be configured to be used in different ways throughout Flow. A
        # common example is to identify a meaningful attribute (e.g. brand) that can
        # then be displayed throughout the Flow console.
        class Attribute

          attr_reader :id, :key, :options, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :options], 'Attribute')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Attribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :options => options.to_hash,
              :label => label
            }
          end

        end

        class AttributeForm

          attr_reader :key, :options, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :options], 'AttributeForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :options => options.to_hash,
              :label => label
            }
          end

        end

        # Retrieve journaled history of an attribute
        class AttributeVersion

          attr_reader :id, :timestamp, :type, :attribute

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :attribute], 'AttributeVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @attribute = (x = opts.delete(:attribute); x.is_a?(::Io::Flow::V0::Models::Attribute) ? x : ::Io::Flow::V0::Models::Attribute.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :attribute => attribute.to_hash
            }
          end

        end

        class AuthenticationForm

          attr_reader :email, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email, :password], 'AuthenticationForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class Authorization

          attr_reader :id, :reference, :card, :amount, :currency, :customer, :attributes, :shipping, :ip, :cvv, :details

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :card, :amount, :currency, :customer, :attributes, :details], 'Authorization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::CardReference) ? x : ::Io::Flow::V0::Models::CardReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @details = (x = opts.delete(:details); x.is_a?(::Io::Flow::V0::Models::AuthorizationDetails) ? x : ::Io::Flow::V0::Models::AuthorizationDetails.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Authorization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :card => card.to_hash,
              :amount => amount,
              :currency => currency,
              :customer => customer.to_hash,
              :attributes => attributes,
              :shipping => shipping.nil? ? nil : shipping.to_hash,
              :ip => ip,
              :cvv => cvv,
              :details => details.to_hash
            }
          end

        end

        # Represents a declined authorization
        class AuthorizationDetailsDecline < AuthorizationDetails

          attr_reader :reason, :avs, :cvv

          def initialize(incoming={})
            super(:name => AuthorizationDetails::Types::AUTHORIZATION_DETAILS_DECLINE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:reason], 'AuthorizationDetailsDecline')
            @reason = HttpClient::Preconditions.assert_class('reason', opts.delete(:reason), String)
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDetailsDecline.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :reason => reason,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        # Represents a successful authorization
        class AuthorizationDetailsSuccess < AuthorizationDetails

          attr_reader :avs, :cvv

          def initialize(incoming={})
            super(:name => AuthorizationDetails::Types::AUTHORIZATION_DETAILS_SUCCESS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDetailsSuccess.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class AuthorizationForm

          attr_reader :reference, :token, :amount, :currency, :customer, :cvv, :attributes, :shipping, :ip

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :amount, :currency, :customer], 'AuthorizationForm')
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :reference => reference,
              :token => token,
              :amount => amount,
              :currency => currency,
              :customer => customer.to_hash,
              :cvv => cvv,
              :attributes => attributes.nil? ? nil : attributes,
              :shipping => shipping.nil? ? nil : shipping.to_hash,
              :ip => ip
            }
          end

        end

        class AuthorizationReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'AuthorizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class AuthorizationVersion

          attr_reader :id, :timestamp, :type, :authorization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :authorization], 'AuthorizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::Authorization) ? x : ::Io::Flow::V0::Models::Authorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :authorization => authorization.to_hash
            }
          end

        end

        # Representation of a service level available at a center, including misc
        # attributes. Only ID for now, more attributes will be added in the future.
        class AvailableService

          attr_reader :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service], 'AvailableService')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailableService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service
            }
          end

        end

        # Represents data from the address verification check
        class Avs

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Avs')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Avs.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        # Represents second step of two-step purchase of Flow services.
        class Booking

          attr_reader :id, :number, :shipments

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :shipments], 'Booking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @shipments = HttpClient::Preconditions.assert_class('shipments', opts.delete(:shipments), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentReference) ? x : ::Io::Flow::V0::Models::ShipmentReference.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Booking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :shipments => shipments.map { |o| o.to_hash }
            }
          end

        end

        # Represents second step of two-step purchase of Flow services.
        class BookingForm

          attr_reader :number, :quote, :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quote, :options], 'BookingForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quote = HttpClient::Preconditions.assert_class('quote', opts.delete(:quote), String)
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| HttpClient::Preconditions.assert_class('options', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quote => quote,
              :options => options
            }
          end

        end

        class BookingSummary

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'BookingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class BookingVersion

          attr_reader :id, :timestamp, :type, :booking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :booking], 'BookingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @booking = (x = opts.delete(:booking); x.is_a?(::Io::Flow::V0::Models::BookingSummary) ? x : ::Io::Flow::V0::Models::BookingSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :booking => booking.to_hash
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class Capture

          attr_reader :id, :reference, :authorization, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :authorization, :amount, :currency], 'Capture')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Capture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :authorization => authorization.to_hash,
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class CaptureForm

          attr_reader :reference, :authorization_id, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authorization_id], 'CaptureForm')
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @authorization_id = HttpClient::Preconditions.assert_class('authorization_id', opts.delete(:authorization_id), String)
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :reference => reference,
              :authorization_id => authorization_id,
              :amount => amount,
              :currency => currency
            }
          end

        end

        class CaptureVersion

          attr_reader :id, :timestamp, :type, :capture

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :capture], 'CaptureVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :capture => capture.to_hash
            }
          end

        end

        # Card represents the metadata about a secure, tokenized card. The card 'id' is
        # a unique, cryptographically secure token by which this card can be identified
        # in the future.
        class Card

          attr_reader :id, :type, :expiration, :last4, :name, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :expiration, :last4, :name], 'Card')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CardType) ? x : ::Io::Flow::V0::Models::CardType.apply(x))
            @expiration = (x = opts.delete(:expiration); x.is_a?(::Io::Flow::V0::Models::Expiration) ? x : ::Io::Flow::V0::Models::Expiration.new(x))
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Card.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :expiration => expiration.to_hash,
              :last4 => last4,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CardForm

          attr_reader :number, :expiration_month, :expiration_year, :name, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :expiration_month, :expiration_year, :name], 'CardForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @expiration_month = HttpClient::Preconditions.assert_class('expiration_month', opts.delete(:expiration_month), Integer)
            @expiration_year = HttpClient::Preconditions.assert_class('expiration_year', opts.delete(:expiration_year), Integer)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :expiration_month => expiration_month,
              :expiration_year => expiration_year,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CardReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CardReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CardVersion

          attr_reader :id, :timestamp, :type, :card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :card], 'CardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :card => card.to_hash
            }
          end

        end

        # Partner that actually take a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class Carrier

          attr_reader :id, :name, :facilities, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :facilities, :visibility], 'Carrier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @facilities = HttpClient::Preconditions.assert_class('facilities', opts.delete(:facilities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)) }
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Carrier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :facilities => facilities.map { |o| o.to_hash },
              :visibility => visibility.value
            }
          end

        end

        # carrier_account an organization has with a carrier. A carrier can have
        # multiple carrier_accounts with a single carrier. This represents the
        # many-to-many relationship between organizations and carriers.
        class CarrierAccount

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'CarrierAccount')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccount.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class CarrierAccountForm

          attr_reader :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:carrier], 'CarrierAccountForm')
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :carrier => carrier,
              :name => name
            }
          end

        end

        class CarrierAccountReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierAccountReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CarrierAccountSummary

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'CarrierAccountSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::CarrierReference) ? x : ::Io::Flow::V0::Models::CarrierReference.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class CarrierAccountVersion

          attr_reader :id, :timestamp, :type, :carrier_account

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :carrier_account], 'CarrierAccountVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @carrier_account = (x = opts.delete(:carrier_account); x.is_a?(::Io::Flow::V0::Models::CarrierAccountSummary) ? x : ::Io::Flow::V0::Models::CarrierAccountSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :carrier_account => carrier_account.to_hash
            }
          end

        end

        # Partner that actually take a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class CarrierForm

          attr_reader :name, :facilities, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'CarrierForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @facilities = (x = opts.delete(:facilities); x.nil? ? nil : HttpClient::Preconditions.assert_class('facilities', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)) })
            @visibility = (x = opts.delete(:visibility); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :facilities => facilities.nil? ? nil : facilities.map { |o| o.to_hash },
              :visibility => visibility.nil? ? nil : visibility.value
            }
          end

        end

        class CarrierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CarrierVersion

          attr_reader :id, :timestamp, :type, :carrier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :carrier], 'CarrierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :carrier => carrier.to_hash
            }
          end

        end

        class Catalog

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'Catalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Catalog.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CatalogItemDocument < Document

          attr_reader :number, :name, :categories, :experiences, :attributes

          def initialize(incoming={})
            super(:name => Document::Types::CATALOG_ITEM_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :categories, :experiences, :attributes], 'CatalogItemDocument')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @experiences = HttpClient::Preconditions.assert_class('experiences', opts.delete(:experiences), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :number => number,
              :name => name,
              :categories => categories,
              :experiences => experiences.map { |o| o.to_hash },
              :attributes => attributes
            }
          end

        end

        # Statistics covering product catalog item information, including total catalog
        # item count, number of distinct categories, etc.
        class CatalogStatistics

          attr_reader :items, :categories

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :categories], 'CatalogStatistics')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Integer)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items,
              :categories => categories
            }
          end

        end

        class CatalogVersion

          attr_reader :id, :timestamp, :type, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :catalog], 'CatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :catalog => catalog.to_hash
            }
          end

        end

        class CategorySummary

          attr_reader :name, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:count], 'CategorySummary')
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CategorySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :count => count
            }
          end

        end

        # Represents a facility capable of fulfilling a shipment
        class Center

          attr_reader :id, :address, :packaging, :name, :services, :schedule, :timezone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :address, :packaging, :name, :services, :schedule, :timezone], 'Center')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Center.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone
            }
          end

        end

        class CenterForm

          attr_reader :address, :packaging, :name, :services, :schedule, :timezone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :packaging, :name, :services, :schedule, :timezone], 'CenterForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone
            }
          end

        end

        class CenterReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CenterReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CenterVersion

          attr_reader :id, :timestamp, :type, :center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :center], 'CenterVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::Center) ? x : ::Io::Flow::V0::Models::Center.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :center => center.to_hash
            }
          end

        end

        # The actual value of the API token. This is modeled as a separate resource as
        # it is fetched only on demand.
        class Cleartext

          attr_reader :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value], 'Cleartext')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cleartext.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value
            }
          end

        end

        # Defines structured fields for a contact person. Typically used for specifying
        # contact person for an account, shipment, or organization representative
        class Contact

          attr_reader :name, :email, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Contact')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Contact.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :email => email,
              :phone => phone
            }
          end

        end

        # Describes conversion information from a base currency to a target currency.
        class Conversion

          attr_reader :base, :target, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :rate], 'Conversion')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Conversion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :rate => rate
            }
          end

        end

        class Country

          attr_reader :name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system, :default_currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system], 'Country')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_3166_2 = HttpClient::Preconditions.assert_class('iso_3166_2', opts.delete(:iso_3166_2), String)
            @iso_3166_3 = HttpClient::Preconditions.assert_class('iso_3166_3', opts.delete(:iso_3166_3), String)
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_system = HttpClient::Preconditions.assert_class('measurement_system', opts.delete(:measurement_system), String)
            @default_currency = (x = opts.delete(:default_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Country.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_3166_2 => iso_3166_2,
              :iso_3166_3 => iso_3166_3,
              :languages => languages,
              :measurement_system => measurement_system,
              :default_currency => default_currency
            }
          end

        end

        # ISO 4217 3-character currency code. See
        # https://api.flow.io/reference/currencies
        class Currency

          attr_reader :name, :iso_4217_3, :number_decimals

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_4217_3, :number_decimals], 'Currency')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_4217_3 = HttpClient::Preconditions.assert_class('iso_4217_3', opts.delete(:iso_4217_3), String)
            @number_decimals = HttpClient::Preconditions.assert_class('number_decimals', opts.delete(:number_decimals), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Currency.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_4217_3 => iso_4217_3,
              :number_decimals => number_decimals
            }
          end

        end

        # A customer represents the actual person purchasing from you. This information
        # is needed primarily to support logistics (delivery to this person), fraud
        # management (verification of who the person is), and reporting. We also
        # recommend including your customer number whenever possible as doing so will
        # allow Flow to link up transactions for this customer making customer service
        # easier.
        class Customer

          attr_reader :name, :number, :phone, :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Customer')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Customer.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :number => number,
              :phone => phone,
              :email => email
            }
          end

        end

        # Represents data from the card verification number check
        class Cvv

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Cvv')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cvv.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        class DatetimeRange

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DatetimeRange')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DatetimeRange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class Ddp < RatecardFee

          attr_reader :amount

          def initialize(incoming={})
            super(:name => RatecardFee::Types::DDP)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'Ddp')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Ddp.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class Delivery

          attr_reader :id, :items, :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :options], 'Delivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOption) ? x : ::Io::Flow::V0::Models::DeliveryOption.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Delivery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash },
              :options => options.map { |o| o.to_hash }
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class DeliveryForm

          attr_reader :quote, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quote, :items, :destination], 'DeliveryForm')
            @quote = HttpClient::Preconditions.assert_class('quote', opts.delete(:quote), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :quote => quote,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOption

          attr_reader :id, :cost, :delivered_duty, :price, :service, :tier, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :delivered_duty, :price, :service, :tier, :window], 'DeliveryOption')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOption.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :delivered_duty => delivered_duty.value,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOptionForm

          attr_reader :delivery, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivery, :items, :destination], 'DeliveryOptionForm')
            @delivery = HttpClient::Preconditions.assert_class('delivery', opts.delete(:delivery), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivery => delivery,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        class DeliveryOptionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'DeliveryOptionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class DeliveryOptionSummary

          attr_reader :id, :cost, :delivered_duty, :price, :service, :tier, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :delivered_duty, :price, :service, :tier, :window], 'DeliveryOptionSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :delivered_duty => delivered_duty.value,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash
            }
          end

        end

        class DeliveryOptionVersion

          attr_reader :id, :timestamp, :type, :delivery_option

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery_option], 'DeliveryOptionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery_option = (x = opts.delete(:delivery_option); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionSummary) ? x : ::Io::Flow::V0::Models::DeliveryOptionSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery_option => delivery_option.to_hash
            }
          end

        end

        class DeliverySummary

          attr_reader :id, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items], 'DeliverySummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliverySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class DeliveryVersion

          attr_reader :id, :timestamp, :type, :delivery

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery], 'DeliveryVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery = (x = opts.delete(:delivery); x.is_a?(::Io::Flow::V0::Models::DeliverySummary) ? x : ::Io::Flow::V0::Models::DeliverySummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery => delivery.to_hash
            }
          end

        end

        class DeliveryWindow

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DeliveryWindow')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class DeminimusSimple < Deminimus

          attr_reader :value, :currency, :components, :minimum

          def initialize(incoming={})
            super(:name => Deminimus::Types::DEMINIMUS_SIMPLE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :currency, :components, :minimum], 'DeminimusSimple')
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @minimum = HttpClient::Preconditions.assert_class('minimum', HttpClient::Helper.to_big_decimal(opts.delete(:minimum)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeminimusSimple.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :value => value,
              :currency => currency,
              :components => components.map { |o| o.value },
              :minimum => minimum
            }
          end

        end

        class Dimension

          attr_reader :depth, :diameter, :length, :weight, :width

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @depth = (x = opts.delete(:depth); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @diameter = (x = opts.delete(:diameter); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @length = (x = opts.delete(:length); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @width = (x = opts.delete(:width); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimension.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :depth => depth.nil? ? nil : depth.to_hash,
              :diameter => diameter.nil? ? nil : diameter.to_hash,
              :length => length.nil? ? nil : length.to_hash,
              :weight => weight.nil? ? nil : weight.to_hash,
              :width => width.nil? ? nil : width.to_hash
            }
          end

        end

        class Dimensions

          attr_reader :product, :packaging

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @product = (x = opts.delete(:product); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
            @packaging = (x = opts.delete(:packaging); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimensions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :product => product.nil? ? nil : product.to_hash,
              :packaging => packaging.nil? ? nil : packaging.to_hash
            }
          end

        end

        # Represents a duration of time.
        class Duration

          attr_reader :unit, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:unit, :value], 'Duration')
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :unit => unit.value,
              :value => value
            }
          end

        end

        # Represents a simple model of duties that apply to a given item / trade lane.
        class Duty

          attr_reader :rate, :components, :deminimus

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :components], 'Duty')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimus = (x = opts.delete(:deminimus); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimus) ? x : ::Io::Flow::V0::Models::Deminimus.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimus => deminimus.nil? ? nil : deminimus.to_hash
            }
          end

        end

        # Represents the successful response of an email verification token. We return
        # the email address in this case to allow the UI to display which email address
        # was verified.
        class EmailVerification

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'EmailVerification')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailVerification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        # Represents an error of some sort (e.g. invalid input). Each error will contain
        # a code and a specific message describing the failure.
        class Error

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Error')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Error.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        # Range of time given a from and to number and the unit. For example: 1-4 hours
        # or 4-7 days
        class EstimatedWindow

          attr_reader :from, :to, :unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to, :unit], 'EstimatedWindow')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EstimatedWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :unit => unit.value
            }
          end

        end

        # Represents an exception to the schedule of a center.
        class Exception

          attr_reader :type, :datetime_range

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :datetime_range], 'Exception')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExceptionType) ? x : ::Io::Flow::V0::Models::ExceptionType.apply(x))
            @datetime_range = (x = opts.delete(:datetime_range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Exception.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :datetime_range => datetime_range.to_hash
            }
          end

        end

        # Experiences define a local experience for a given geographic region
        class Experience

          attr_reader :id, :key, :name, :delivered_duty, :region, :country, :currency, :language, :measurement_system, :subcatalog, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name, :delivered_duty, :region, :country, :currency, :language, :measurement_system, :subcatalog, :position], 'Experience')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @region = (x = opts.delete(:region); x.is_a?(::Io::Flow::V0::Models::RegionReference) ? x : ::Io::Flow::V0::Models::RegionReference.new(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x))
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Experience.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :delivered_duty => delivered_duty.value,
              :region => region.to_hash,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value,
              :subcatalog => subcatalog.to_hash,
              :position => position
            }
          end

        end

        # Experiences define a local experience for a given geographic region
        class ExperienceForm

          attr_reader :region_id, :name, :delivered_duty, :country, :currency, :language, :key, :measurement_system, :subcatalog_id, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:region_id, :name], 'ExperienceForm')
            @region_id = HttpClient::Preconditions.assert_class('region_id', opts.delete(:region_id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @measurement_system = (x = opts.delete(:measurement_system); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x)))
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :region_id => region_id,
              :name => name,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :country => country,
              :currency => currency,
              :language => language,
              :key => key,
              :measurement_system => measurement_system.nil? ? nil : measurement_system.value,
              :subcatalog_id => subcatalog_id,
              :position => position
            }
          end

        end

        class ExperienceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ExperienceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Some important fields related to experiences used in various APIs
        class ExperienceSummary

          attr_reader :id, :key, :name, :currency, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name], 'ExperienceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :currency => currency,
              :country => country
            }
          end

        end

        class ExperienceVersion

          attr_reader :id, :timestamp, :type, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :experience], 'ExperienceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::Experience) ? x : ::Io::Flow::V0::Models::Experience.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :experience => experience.to_hash
            }
          end

        end

        # The month and year at which a card expires
        class Expiration

          attr_reader :month, :year

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:month, :year], 'Expiration')
            @month = HttpClient::Preconditions.assert_class('month', opts.delete(:month), Integer)
            @year = HttpClient::Preconditions.assert_class('year', opts.delete(:year), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Expiration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :month => month,
              :year => year
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is pre-defined flat rate
        class FlatRate < TierRuleOutcome

          attr_reader :price

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::FLAT_RATE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'FlatRate')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlatRate.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        class FlowItemIndexMetadata

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'FlowItemIndexMetadata')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlowItemIndexMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is free
        class FreeShipping < TierRuleOutcome

          attr_reader :ignore

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::FREE_SHIPPING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ignore = (x = opts.delete(:ignore); x.nil? ? nil : HttpClient::Preconditions.assert_class('ignore', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FreeShipping.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :ignore => ignore
            }
          end

        end

        class FuelSurcharge < RatecardFee

          attr_reader :amount

          def initialize(incoming={})
            super(:name => RatecardFee::Types::FUEL_SURCHARGE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount], 'FuelSurcharge')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FuelSurcharge.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :amount => amount
            }
          end

        end

        class FulfillmentExperienceReference

          attr_reader :id, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :currency], 'FulfillmentExperienceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :currency => currency
            }
          end

        end

        class HarmonizationDocument < Document

          attr_reader :code, :categories, :origin

          def initialize(incoming={})
            super(:name => Document::Types::HARMONIZATION_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :categories], 'HarmonizationDocument')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CategorySummary) ? x : ::Io::Flow::V0::Models::CategorySummary.new(x)) }
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :code => code,
              :categories => categories.map { |o| o.to_hash },
              :origin => origin
            }
          end

        end

        # Organization level settings.
        class HarmonizationSettings

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = (x = opts.delete(:duty_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
            @tax_strategy = (x = (x = opts.delete(:tax_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.value,
              :tax_strategy => tax_strategy.value
            }
          end

        end

        class HarmonizationSettingsForm

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = opts.delete(:duty_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
            @tax_strategy = (x = opts.delete(:tax_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.nil? ? nil : duty_strategy.value,
              :tax_strategy => tax_strategy.nil? ? nil : tax_strategy.value
            }
          end

        end

        # A harmonized item stores explicit information about this item for the purposes
        # of harmonization / classification. The harmonization process begins by
        # creating a harmonized item; this kicks off the internal processes. Once
        # assigned, codes will be available via the hs6 and hs10 resources
        class HarmonizedItem

          attr_reader :id, :number, :name, :description, :categories, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :name], 'HarmonizedItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :name => name,
              :description => description,
              :categories => categories,
              :attributes => attributes
            }
          end

        end

        # Used to specifically set an item's duty rate for a given trade lane.
        class HarmonizedItemDuty

          attr_reader :id, :item, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :rate], 'HarmonizedItemDuty')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDuty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyForm

          attr_reader :number, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :origin, :destination, :rate], 'HarmonizedItemDutyForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyVersion

          attr_reader :id, :timestamp, :type, :harmonized_item_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item_duty], 'HarmonizedItemDutyVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item_duty = (x = opts.delete(:harmonized_item_duty); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemDuty) ? x : ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item_duty => harmonized_item_duty.to_hash
            }
          end

        end

        class HarmonizedItemForm

          attr_reader :name, :number, :categories, :description, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :number], 'HarmonizedItemForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :number => number,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class HarmonizedItemPutForm

          attr_reader :name, :categories, :description, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'HarmonizedItemPutForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class HarmonizedItemReference

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'HarmonizedItemReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class HarmonizedItemVersion

          attr_reader :id, :timestamp, :type, :harmonized_item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item], 'HarmonizedItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item = (x = opts.delete(:harmonized_item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItem) ? x : ::Io::Flow::V0::Models::HarmonizedItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item => harmonized_item.to_hash
            }
          end

        end

        # Summary of landed cost data (taxes and duties) for 1 or more items going to a
        # single destination country. Records are unique based on (item.number, country
        # of origin).
        class HarmonizedLandedCost

          attr_reader :address, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :items], 'HarmonizedLandedCost')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::HarmonizedLandedCostItem) ? x : ::Io::Flow::V0::Models::HarmonizedLandedCostItem.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCost.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        # Allows calculation of duty and tax for multiple items in one API call for
        # items going to a specific destination country
        class HarmonizedLandedCostForm

          attr_reader :address, :item_numbers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :item_numbers], 'HarmonizedLandedCostForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @item_numbers = HttpClient::Preconditions.assert_class('item_numbers', opts.delete(:item_numbers), Array).map { |v| HttpClient::Preconditions.assert_class('item_numbers', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCostForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :item_numbers => item_numbers
            }
          end

        end

        # Duty and tax information for a given item. Note that the internal
        # implementation supports multiple countries of origin.
        class HarmonizedLandedCostItem

          attr_reader :item, :duty, :tax

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :duty, :tax], 'HarmonizedLandedCostItem')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x))
            @tax = (x = opts.delete(:tax); x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCostItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :duty => duty.to_hash,
              :tax => tax.to_hash
            }
          end

        end

        class Healthcheck

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Healthcheck')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Healthcheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # The (Harmonized System) HS-10 code assigned to an item with a given
        # origin/destination pair.
        class Hs10

          attr_reader :id, :item, :origin, :destination, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :code], 'Hs10')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :code => code
            }
          end

        end

        class Hs10Version

          attr_reader :id, :timestamp, :type, :hs10

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs10], 'Hs10Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs10 = (x = opts.delete(:hs10); x.is_a?(::Io::Flow::V0::Models::Hs10) ? x : ::Io::Flow::V0::Models::Hs10.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs10 => hs10.to_hash
            }
          end

        end

        # The (Harmonized System) HS-6 code assigned to an item.
        class Hs6

          attr_reader :id, :item, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :code], 'Hs6')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :code => code
            }
          end

        end

        class Hs6Version

          attr_reader :id, :timestamp, :type, :hs6

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs6], 'Hs6Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs6 = (x = opts.delete(:hs6); x.is_a?(::Io::Flow::V0::Models::Hs6) ? x : ::Io::Flow::V0::Models::Hs6.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs6 => hs6.to_hash
            }
          end

        end

        # The URL to an image, with optional tags. Flow Commerce primarily uses images
        # to enhance the administrative tools (e.g. showing an item image in console)
        class Image

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'Image')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = HttpClient::Preconditions.assert_class('tags', (x = opts.delete(:tags); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Image.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags
            }
          end

        end

        # Image form defines the data needed to create an image
        class ImageForm

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'ImageForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = (x = opts.delete(:tags); x.nil? ? nil : HttpClient::Preconditions.assert_class('tags', x, Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImageForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags.nil? ? nil : tags
            }
          end

        end

        # Enables backorders, setting an optional number of units that we allow for
        # backorder. For example, a backorder w/ quantity 10 will enable selling until
        # the actual inventory quantity is -10.
        class InventoryBackorder < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:name => InventoryStrategy::Types::INVENTORY_BACKORDER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryBackorder')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryBackorder.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        class InventoryCenterReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'InventoryCenterReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryCenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class InventoryItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'InventoryItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        # Ordered list of rules to apply, from first to last, to get available quantity.
        # This is unique per organization
        class InventoryRule

          attr_reader :id, :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :position, :query, :strategy], 'InventoryRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleForm

          attr_reader :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:position, :query, :strategy], 'InventoryRuleForm')
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleVersion

          attr_reader :id, :timestamp, :type, :inventory_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_rule], 'InventoryRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_rule = (x = opts.delete(:inventory_rule); x.is_a?(::Io::Flow::V0::Models::InventoryRule) ? x : ::Io::Flow::V0::Models::InventoryRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_rule => inventory_rule.to_hash
            }
          end

        end

        # Inventory snapshot reflects the current quantity and available number of units
        # for a given center / item
        class InventorySnapshot

          attr_reader :id, :available, :center, :item, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :available, :center, :item, :quantity], 'InventorySnapshot')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Integer)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshot.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :available => available,
              :center => center.to_hash,
              :item => item.to_hash,
              :quantity => quantity
            }
          end

        end

        class InventorySnapshotVersion

          attr_reader :id, :timestamp, :type, :inventory_snapshot

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_snapshot], 'InventorySnapshotVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_snapshot = (x = opts.delete(:inventory_snapshot); x.is_a?(::Io::Flow::V0::Models::InventorySnapshot) ? x : ::Io::Flow::V0::Models::InventorySnapshot.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshotVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_snapshot => inventory_snapshot.to_hash
            }
          end

        end

        # Treats inventory as available as long as the actual inventory quantity is >
        # the specified quantity. A common use case is to set quantity to zero to
        # indicate availability as long as there is at least 1 unit available.
        class InventoryStock < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:name => InventoryStrategy::Types::INVENTORY_STOCK)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryStock')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryStock.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Items affected with rules pursuing an unlimited strategy will always be
        # available
        class InventoryUnlimited < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:name => InventoryStrategy::Types::INVENTORY_UNLIMITED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @quantity = HttpClient::Preconditions.assert_class('quantity', (x = opts.delete(:quantity); x.nil? ? "unlimited" : x), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUnlimited.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Represents a single update on inventory quantity
        class InventoryUpdate

          attr_reader :id, :idempotency_key, :center, :item, :notes, :quantity, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :idempotency_key, :center, :item, :notes, :quantity, :type], 'InventoryUpdate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @notes = HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(opts.delete(:notes)), Hash)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :idempotency_key => idempotency_key,
              :center => center.to_hash,
              :item => item.to_hash,
              :notes => notes,
              :quantity => quantity,
              :type => type.value
            }
          end

        end

        # Form used to create an update on inventory. If inventory for center/item has
        # not been previously created, a new row is created for the center/item tuple.
        class InventoryUpdateForm

          attr_reader :center, :idempotency_key, :item_number, :quantity, :type, :notes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:center, :idempotency_key, :item_number, :quantity, :type], 'InventoryUpdateForm')
            @center = HttpClient::Preconditions.assert_class('center', opts.delete(:center), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
            @notes = (x = opts.delete(:notes); x.nil? ? nil : HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :center => center,
              :idempotency_key => idempotency_key,
              :item_number => item_number,
              :quantity => quantity,
              :type => type.value,
              :notes => notes
            }
          end

        end

        class InventoryUpdateVersion

          attr_reader :id, :timestamp, :type, :inventory_update

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_update], 'InventoryUpdateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_update = (x = opts.delete(:inventory_update); x.is_a?(::Io::Flow::V0::Models::InventoryUpdate) ? x : ::Io::Flow::V0::Models::InventoryUpdate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_update => inventory_update.to_hash
            }
          end

        end

        # An invitation via email to a user to join this organization. The user will
        # then walk through a user login/registration process and will immediately
        # become a member of the organization.
        class Invitation

          attr_reader :id, :organization, :email, :name, :role, :expiration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :email, :name, :role, :expiration], 'Invitation')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expiration)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Invitation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :email => email,
              :name => name.to_hash,
              :role => role.value,
              :expiration => expiration
            }
          end

        end

        class InvitationAcceptsForm

          attr_reader :user_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:user_id], 'InvitationAcceptsForm')
            @user_id = HttpClient::Preconditions.assert_class('user_id', opts.delete(:user_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationAcceptsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :user_id => user_id
            }
          end

        end

        class InvitationForm

          attr_reader :organization, :email, :name, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :email], 'InvitationForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :role => role.value
            }
          end

        end

        class InvitationVersion

          attr_reader :id, :timestamp, :type, :invitation

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :invitation], 'InvitationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @invitation = (x = opts.delete(:invitation); x.is_a?(::Io::Flow::V0::Models::Invitation) ? x : ::Io::Flow::V0::Models::Invitation.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :invitation => invitation.to_hash
            }
          end

        end

        # The Flow item defines a specific item that can be purchased by a consumer. For
        # many clients, this will map to a Sku.
        class Item

          attr_reader :id, :number, :locale, :name, :price, :categories, :description, :attributes, :dimensions, :images, :local

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :locale, :name, :price, :dimensions], 'Item')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x))
            @images = HttpClient::Preconditions.assert_class('images', (x = opts.delete(:images); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)) }
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Local) ? x : ::Io::Flow::V0::Models::Local.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :locale => locale,
              :name => name,
              :price => price.to_hash,
              :categories => categories,
              :description => description,
              :attributes => attributes,
              :dimensions => dimensions.to_hash,
              :images => images.map { |o| o.to_hash },
              :local => local.nil? ? nil : local.to_hash
            }
          end

        end

        # The item form defines the data required to create an item.
        class ItemForm

          attr_reader :number, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :locale, :name, :currency, :price], 'ItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @dimensions = (x = opts.delete(:dimensions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x)))
            @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageForm) ? x : ::Io::Flow::V0::Models::ImageForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes,
              :dimensions => dimensions.nil? ? nil : dimensions.to_hash,
              :images => images.nil? ? nil : images.map { |o| o.to_hash }
            }
          end

        end

        # Item Functions are javascript code used to calculate the localized price of an
        # additional item. Each function can be associated with an optional query
        # identifying the products to which the function applies. Flow selects the first
        # function matching an item, then uses that function to calculate local prices
        # whenever any data relevant to the item changes (e.g. on update in master
        # catalog, on change in relevant exchange rate, etc.). Item functions are
        # immutable once created.
        class ItemFunction < ExpandableItemFunction

          attr_reader :id, :key, :description, :code

          def initialize(incoming={})
            super(:name => ExpandableItemFunction::Types::ITEM_FUNCTION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :description, :code], 'ItemFunction')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunction.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :description => description,
              :code => code
            }
          end

        end

        # Item Functions are javascript code used to calculate the localized price of an
        # additional item. Each function can be associated with an optional query
        # identifying the products to which the function applies. Flow selects the first
        # function matching an item, then uses that function to calculate local prices
        # whenever any data relevant to the item changes (e.g. on update in master
        # catalog, on change in relevant exchange rate, etc.). Item functions are
        # immutable once created.
        class ItemFunctionPostForm

          attr_reader :description, :code, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:description, :code], 'ItemFunctionPostForm')
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionPostForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :description => description,
              :code => code,
              :key => key
            }
          end

        end

        # Item Functions are javascript code used to calculate the localized price of an
        # additional item. Each function can be associated with an optional query
        # identifying the products to which the function applies. Flow selects the first
        # function matching an item, then uses that function to calculate local prices
        # whenever any data relevant to the item changes (e.g. on update in master
        # catalog, on change in relevant exchange rate, etc.). Item functions are
        # immutable once created.
        class ItemFunctionPutForm

          attr_reader :description, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:description, :code], 'ItemFunctionPutForm')
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :description => description,
              :code => code
            }
          end

        end

        class ItemFunctionReference < ExpandableItemFunction

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableItemFunction::Types::ITEM_FUNCTION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ItemFunctionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class ItemFunctionVersion

          attr_reader :id, :timestamp, :type, :item_function

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item_function], 'ItemFunctionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item_function = (x = opts.delete(:item_function); x.is_a?(::Io::Flow::V0::Models::ItemFunction) ? x : ::Io::Flow::V0::Models::ItemFunction.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item_function => item_function.to_hash
            }
          end

        end

        # A list of margin to apply to items based on query.
        class ItemMargin

          attr_reader :id, :name, :q, :margin, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :q, :margin, :position], 'ItemMargin')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @margin = (x = opts.delete(:margin); x.is_a?(::Io::Flow::V0::Models::Margin) ? x : ::Io::Flow::V0::Models::Margin.new(x))
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMargin.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :q => q,
              :margin => margin.to_hash,
              :position => position
            }
          end

        end

        # A list of margin to apply to items based on query.
        class ItemMarginForm

          attr_reader :name, :margin, :q, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :margin], 'ItemMarginForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @margin = (x = opts.delete(:margin); x.is_a?(::Io::Flow::V0::Models::Margin) ? x : ::Io::Flow::V0::Models::Margin.new(x))
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :margin => margin.to_hash,
              :q => q,
              :position => position
            }
          end

        end

        class ItemMarginVersion

          attr_reader :id, :timestamp, :type, :item_margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item_margin], 'ItemMarginVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item_margin = (x = opts.delete(:item_margin); x.is_a?(::Io::Flow::V0::Models::ItemMargin) ? x : ::Io::Flow::V0::Models::ItemMargin.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item_margin => item_margin.to_hash
            }
          end

        end

        # Detailed information for the pricing of a given item within an experience
        class ItemPriceDetails

          attr_reader :base, :local, :currency_margin, :item_margin, :vat, :duty, :shipping, :rounding, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :local, :currency_margin, :item_margin, :vat, :duty, :shipping, :rounding, :total], 'ItemPriceDetails')
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @currency_margin = (x = opts.delete(:currency_margin); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @item_margin = (x = opts.delete(:item_margin); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @vat = (x = opts.delete(:vat); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @shipping = (x = opts.delete(:shipping); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @rounding = (x = opts.delete(:rounding); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemPriceDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base.to_hash,
              :local => local.to_hash,
              :currency_margin => currency_margin.to_hash,
              :item_margin => item_margin.to_hash,
              :vat => vat.to_hash,
              :duty => duty.to_hash,
              :shipping => shipping.to_hash,
              :rounding => rounding.to_hash,
              :total => total.to_hash
            }
          end

        end

        # Statistics covering product catalog item information, including total catalog
        # item count, number of distinct categories, etc.
        class ItemStatistics

          attr_reader :items, :categories

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :categories], 'ItemStatistics')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Integer)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items,
              :categories => categories
            }
          end

        end

        # Summary of product line item
        class ItemSummary

          attr_reader :number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'ItemSummary')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity
            }
          end

        end

        class ItemVersion

          attr_reader :id, :timestamp, :type, :item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item], 'ItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item => item.to_hash
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class Label

          attr_reader :id, :tracking, :status, :carrier, :tracking_number, :timestamp, :delivery_estimate, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number, :timestamp], 'Label')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Label.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number,
              :timestamp => timestamp,
              :delivery_estimate => delivery_estimate,
              :description => description
            }
          end

        end

        class LabelEvent

          attr_reader :id, :label, :address, :status, :timestamp, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :label, :address, :status, :timestamp], 'LabelEvent')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @label = (x = opts.delete(:label); x.is_a?(::Io::Flow::V0::Models::LabelSummary) ? x : ::Io::Flow::V0::Models::LabelSummary.new(x))
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEvent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :label => label.to_hash,
              :address => address.to_hash,
              :status => status.value,
              :timestamp => timestamp,
              :description => description
            }
          end

        end

        class LabelEventForm

          attr_reader :label_id, :timestamp, :status, :description, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label_id, :timestamp, :status], 'LabelEventForm')
            @label_id = HttpClient::Preconditions.assert_class('label_id', opts.delete(:label_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEventForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label_id => label_id,
              :timestamp => timestamp,
              :status => status.value,
              :description => description,
              :address => address
            }
          end

        end

        class LabelEventSummary

          attr_reader :id, :status, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :timestamp], 'LabelEventSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEventSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :timestamp => timestamp
            }
          end

        end

        class LabelEventVersion

          attr_reader :id, :timestamp, :type, :label_event

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :label_event], 'LabelEventVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @label_event = (x = opts.delete(:label_event); x.is_a?(::Io::Flow::V0::Models::LabelEventSummary) ? x : ::Io::Flow::V0::Models::LabelEventSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEventVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :label_event => label_event.to_hash
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class LabelForm

          attr_reader :tracking_id, :status, :carrier, :tracking_number, :delivery_estimate, :description, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_id, :carrier, :tracking_number], 'LabelForm')
            @tracking_id = HttpClient::Preconditions.assert_class('tracking_id', opts.delete(:tracking_id), String)
            @status = (x = (x = opts.delete(:status); x.nil? ? "pending" : x); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @timestamp = (x = opts.delete(:timestamp); x.nil? ? nil : HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_id => tracking_id,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number,
              :delivery_estimate => delivery_estimate,
              :description => description,
              :timestamp => timestamp
            }
          end

        end

        class LabelSummary

          attr_reader :id, :tracking, :status, :carrier, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number], 'LabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number
            }
          end

        end

        class LabelVersion

          attr_reader :id, :timestamp, :type, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :label], 'LabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @label = (x = opts.delete(:label); x.is_a?(::Io::Flow::V0::Models::LabelSummary) ? x : ::Io::Flow::V0::Models::LabelSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :label => label.to_hash
            }
          end

        end

        # Available origin/destination mapping and available metadata for lanes of a
        # carrier Service. e.g. UPS Ground only US-US, UPS Intl only US-Intl, etc
        class Lane

          attr_reader :id, :service, :origin, :destination, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :origin, :destination, :window], 'Lane')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Lane.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :origin => origin,
              :destination => destination,
              :window => window.to_hash
            }
          end

        end

        class LaneForm

          attr_reader :service, :origin_country, :destination_country, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :origin_country, :destination_country, :window], 'LaneForm')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @origin_country = HttpClient::Preconditions.assert_class('origin_country', opts.delete(:origin_country), String)
            @destination_country = HttpClient::Preconditions.assert_class('destination_country', opts.delete(:destination_country), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :origin_country => origin_country,
              :destination_country => destination_country,
              :window => window.to_hash
            }
          end

        end

        class LaneSummary

          attr_reader :id, :service, :origin, :destination, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :origin, :destination, :window], 'LaneSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :origin => origin,
              :destination => destination,
              :window => window.to_hash
            }
          end

        end

        class LaneVersion

          attr_reader :id, :timestamp, :type, :lane

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :lane], 'LaneVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @lane = (x = opts.delete(:lane); x.is_a?(::Io::Flow::V0::Models::LaneSummary) ? x : ::Io::Flow::V0::Models::LaneSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :lane => lane.to_hash
            }
          end

        end

        # ISO 639 2-character language code. See https://api.flow.io/reference/languages
        class Language

          attr_reader :name, :iso_639_2

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_639_2], 'Language')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_639_2 = HttpClient::Preconditions.assert_class('iso_639_2', opts.delete(:iso_639_2), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Language.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_639_2 => iso_639_2
            }
          end

        end

        class Local

          attr_reader :prices

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:prices], 'Local')
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Local.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :prices => prices.map { |o| o.to_hash }
            }
          end

        end

        class LocalizedPrice

          attr_reader :key, :currency, :amount, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label], 'LocalizedPrice')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::LocalizedPriceKey) ? x : ::Io::Flow::V0::Models::LocalizedPriceKey.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedPrice.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :currency => currency,
              :amount => amount,
              :label => label
            }
          end

        end

        class Margin

          attr_reader :type, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :value], 'Margin')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::MarginType) ? x : ::Io::Flow::V0::Models::MarginType.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Margin.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :value => value
            }
          end

        end

        class Measurement

          attr_reader :value, :units

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :units], 'Measurement')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            @units = (x = opts.delete(:units); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Measurement.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value,
              :units => units.value
            }
          end

        end

        # Represents the users that are part of this organization. Primary purpose is to
        # manage which users have access to the organization's data and to provide a
        # simple user interface to assign roles and permissions to each member of the
        # organization
        class Membership

          attr_reader :id, :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :user, :role], 'Membership')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::ExpandableUser) ? x : ::Io::Flow::V0::Models::ExpandableUser.from_json(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Membership.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :user => user.to_hash,
              :role => role.value
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipForm

          attr_reader :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :user], 'MembershipForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @user = HttpClient::Preconditions.assert_class('user', opts.delete(:user), String)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :user => user,
              :role => role.value
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipPutForm

          attr_reader :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value
            }
          end

        end

        class MembershipVersion

          attr_reader :id, :timestamp, :type, :membership

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :membership], 'MembershipVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @membership = (x = opts.delete(:membership); x.is_a?(::Io::Flow::V0::Models::Membership) ? x : ::Io::Flow::V0::Models::Membership.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :membership => membership.to_hash
            }
          end

        end

        class Name

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Name.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        class NameForm

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NameForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        # Flags to indicate whether a feature is enabled/disabled on a particular model
        # (e.g. show/do not show attribute as a column in harmonization table view of
        # items)
        class Options

          attr_reader :required, :show_in_catalog, :show_in_harmonization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @required = HttpClient::Preconditions.assert_boolean('required', (x = opts.delete(:required); x.nil? ? false : x))
            @show_in_catalog = HttpClient::Preconditions.assert_boolean('show_in_catalog', (x = opts.delete(:show_in_catalog); x.nil? ? false : x))
            @show_in_harmonization = HttpClient::Preconditions.assert_boolean('show_in_harmonization', (x = opts.delete(:show_in_harmonization); x.nil? ? false : x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Options.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :required => required,
              :show_in_catalog => show_in_catalog,
              :show_in_harmonization => show_in_harmonization
            }
          end

        end

        # An order represents all of the information about a particular line item,
        # including pricing, currency rates, delivery options, etc. All information in
        # an order is guaranteed by Flow - if an order is booked before its expiration.
        # The intended use case is to create an order as a consumer enters checkout,
        # then to book that order in order processing.
        class Order

          attr_reader :id, :number, :customer, :expires_at, :destination, :deliveries, :selections, :prices, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :customer, :expires_at, :destination, :deliveries, :selections, :prices, :total], 'Order')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x)) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Order.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :customer => customer.to_hash,
              :expires_at => expires_at,
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :selections => selections,
              :prices => prices.map { |o| o.to_hash },
              :total => total.to_hash
            }
          end

        end

        # Represents an order that has been booked. Booked orders can no longer be
        # deleted as they represent transactions in the real world.
        class OrderBooking

          attr_reader :id, :order, :created_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order, :created_at], 'OrderBooking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderReference) ? x : ::Io::Flow::V0::Models::OrderReference.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBooking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :order => order.to_hash,
              :created_at => created_at
            }
          end

        end

        # The order form is used to create an open order, providing the details on
        # pricing and delivery options for destination and items/quantities specified
        class OrderForm

          attr_reader :number, :customer, :destination, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :customer, :destination, :items], 'OrderForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :customer => customer.to_hash,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        # Updates the selections on an order.
        class OrderPutForm

          attr_reader :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:options], 'OrderPutForm')
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| HttpClient::Preconditions.assert_class('options', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :options => options
            }
          end

        end

        class OrderReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrderReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class OrderVersion

          attr_reader :id, :timestamp, :type, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :order], 'OrderVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :order => order.to_hash
            }
          end

        end

        # Represents a single organization in the system, and what environment it is
        # currently operating in.
        class Organization < ExpandableOrganization

          attr_reader :id, :name, :environment, :parent

          def initialize(incoming={})
            super(:name => ExpandableOrganization::Types::ORGANIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :environment], 'Organization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent = (x = opts.delete(:parent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Organization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent => parent.nil? ? nil : parent.to_hash
            }
          end

        end

        # Defines the data used for broad authorization of user access to org level data
        class OrganizationAuthorization

          attr_reader :role, :environment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:role, :environment], 'OrganizationAuthorization')
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationAuthorization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value,
              :environment => environment.value
            }
          end

        end

        # Represents organization-specific currency conversion adjustments.
        class OrganizationCurrencySetting

          attr_reader :id, :base, :target, :margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :base, :target, :margin], 'OrganizationCurrencySetting')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @margin = HttpClient::Preconditions.assert_class('margin', HttpClient::Helper.to_big_decimal(opts.delete(:margin)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :base => base,
              :target => target,
              :margin => margin
            }
          end

        end

        # Represents the parts of an organization setting that can be updated.
        class OrganizationCurrencySettingForm

          attr_reader :base, :target, :margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :margin], 'OrganizationCurrencySettingForm')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @margin = HttpClient::Preconditions.assert_class('margin', HttpClient::Helper.to_big_decimal(opts.delete(:margin)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySettingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :margin => margin
            }
          end

        end

        class OrganizationCurrencySettingVersion

          attr_reader :id, :timestamp, :type, :organization_currency_setting

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization_currency_setting], 'OrganizationCurrencySettingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization_currency_setting = (x = opts.delete(:organization_currency_setting); x.is_a?(::Io::Flow::V0::Models::OrganizationCurrencySetting) ? x : ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySettingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization_currency_setting => organization_currency_setting.to_hash
            }
          end

        end

        # Either id or name is required.
        class OrganizationForm

          attr_reader :id, :name, :environment, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @id = (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = (x = opts.delete(:environment); x.nil? ? "production" : x); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent_id => parent_id
            }
          end

        end

        # Data required to upsert an organization.
        class OrganizationPutForm

          attr_reader :name, :environment, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :environment => environment.nil? ? nil : environment.value,
              :parent_id => parent_id
            }
          end

        end

        class OrganizationReference < ExpandableOrganization

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableOrganization::Types::ORGANIZATION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrganizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class OrganizationSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'OrganizationSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class OrganizationVersion

          attr_reader :id, :timestamp, :type, :organization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization], 'OrganizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::Organization) ? x : ::Io::Flow::V0::Models::Organization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization => organization.to_hash
            }
          end

        end

        class OversizedShipment < RatecardFee

          attr_reader :weight_threshold, :weight_unit, :percentage

          def initialize(incoming={})
            super(:name => RatecardFee::Types::OVERSIZED_SHIPMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:weight_threshold, :weight_unit, :percentage], 'OversizedShipment')
            @weight_threshold = HttpClient::Preconditions.assert_class('weight_threshold', opts.delete(:weight_threshold), Numeric)
            @weight_unit = (x = opts.delete(:weight_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @percentage = HttpClient::Preconditions.assert_class('percentage', opts.delete(:percentage), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OversizedShipment.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :weight_threshold => weight_threshold,
              :weight_unit => weight_unit.value,
              :percentage => percentage
            }
          end

        end

        # Represents packaging available to ship items
        class Packaging

          attr_reader :dimensions, :name, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:dimensions], 'Packaging')
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Packaging.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :dimensions => dimensions.to_hash,
              :name => name,
              :number => number
            }
          end

        end

        class PasswordChangeForm

          attr_reader :current, :new

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:current, :new], 'PasswordChangeForm')
            @current = HttpClient::Preconditions.assert_class('current', opts.delete(:current), String)
            @new = HttpClient::Preconditions.assert_class('new', opts.delete(:new), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordChangeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :current => current,
              :new => new
            }
          end

        end

        class PasswordResetForm

          attr_reader :token, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :password], 'PasswordResetForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token,
              :password => password
            }
          end

        end

        class PasswordResetRequestForm

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'PasswordResetRequestForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetRequestForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin percentage
        class PercentMargin < TierRuleOutcome

          attr_reader :percentage

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::PERCENT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:percentage], 'PercentMargin')
            @percentage = HttpClient::Preconditions.assert_class('percentage', opts.delete(:percentage), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PercentMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :percentage => percentage
            }
          end

        end

        # Represents an amount-currency pair for a basic price
        class Price

          attr_reader :amount, :currency, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency, :label], 'Price')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Price.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency,
              :label => label
            }
          end

        end

        class PriceEquation

          attr_reader :base_price, :conversion, :fixed_margin, :percent_margin, :insurance, :freight, :duty, :tax, :rounding

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base_price, :conversion, :fixed_margin, :percent_margin, :insurance, :freight, :duty, :tax], 'PriceEquation')
            @base_price = HttpClient::Preconditions.assert_class('base_price', HttpClient::Helper.to_big_decimal(opts.delete(:base_price)), BigDecimal)
            @conversion = (x = opts.delete(:conversion); x.is_a?(::Io::Flow::V0::Models::Conversion) ? x : ::Io::Flow::V0::Models::Conversion.new(x))
            @fixed_margin = (x = opts.delete(:fixed_margin); x.is_a?(::Io::Flow::V0::Models::Margin) ? x : ::Io::Flow::V0::Models::Margin.new(x))
            @percent_margin = (x = opts.delete(:percent_margin); x.is_a?(::Io::Flow::V0::Models::Margin) ? x : ::Io::Flow::V0::Models::Margin.new(x))
            @insurance = HttpClient::Preconditions.assert_class('insurance', HttpClient::Helper.to_big_decimal(opts.delete(:insurance)), BigDecimal)
            @freight = HttpClient::Preconditions.assert_class('freight', HttpClient::Helper.to_big_decimal(opts.delete(:freight)), BigDecimal)
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x))
            @tax = (x = opts.delete(:tax); x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x))
            @rounding = (x = opts.delete(:rounding); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceEquation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base_price => base_price,
              :conversion => conversion.to_hash,
              :fixed_margin => fixed_margin.to_hash,
              :percent_margin => percent_margin.to_hash,
              :insurance => insurance,
              :freight => freight,
              :duty => duty.to_hash,
              :tax => tax.to_hash,
              :rounding => rounding.nil? ? nil : rounding.to_hash
            }
          end

        end

        # Amount-currency paid for a basic price to be used in model forms, before a
        # price label is created. Label in the main price model is created by the
        # implementing api.
        class PriceForm

          attr_reader :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'PriceForm')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Pricing determines how the item price is calculated when items are requests
        # via the experience.
        class Pricing

          attr_reader :vat, :duty, :rounding

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:vat, :duty], 'Pricing')
            @vat = (x = opts.delete(:vat); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
            @rounding = (x = opts.delete(:rounding); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Pricing.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :vat => vat.value,
              :duty => duty.value,
              :rounding => rounding.nil? ? nil : rounding.to_hash
            }
          end

        end

        # Represents a typed query to indicate which items to include or exclude in a
        # subcatalog
        class Query

          attr_reader :id, :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :type], 'Query')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Query.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :type => type.value
            }
          end

        end

        # Defines a query specifying items to be included or excluded in a subcatalog
        class QueryForm

          attr_reader :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :type], 'QueryForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :type => type.value
            }
          end

        end

        # Represents a collection of deliveries and available options for fulfillment of
        # that delivery
        class Quote

          attr_reader :id, :destination, :deliveries, :selections

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination, :deliveries, :selections], 'Quote')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOptionReference) ? x : ::Io::Flow::V0::Models::DeliveryOptionReference.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Quote.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :selections => selections.map { |o| o.to_hash }
            }
          end

        end

        class QuoteForm

          attr_reader :destination, :experience, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :experience, :items], 'QuoteForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :experience => experience,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class QuoteSummary

          attr_reader :id, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination], 'QuoteSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash
            }
          end

        end

        class QuoteVersion

          attr_reader :id, :timestamp, :type, :quote

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :quote], 'QuoteVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @quote = (x = opts.delete(:quote); x.is_a?(::Io::Flow::V0::Models::QuoteSummary) ? x : ::Io::Flow::V0::Models::QuoteSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :quote => quote.to_hash
            }
          end

        end

        # Represents an organization-specific currency conversion rate at a point in
        # time.
        class Rate

          attr_reader :id, :base, :target, :effective_at, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :base, :target, :effective_at, :value], 'Rate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :base => base,
              :target => target,
              :effective_at => effective_at,
              :value => value
            }
          end

        end

        # Represents the parts of an organization rate that can be updated.
        class RateForm

          attr_reader :base, :target, :effective_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :effective_at], 'RateForm')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :effective_at => effective_at
            }
          end

        end

        class RateVersion

          attr_reader :id, :timestamp, :type, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :rate], 'RateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @rate = (x = opts.delete(:rate); x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :rate => rate.to_hash
            }
          end

        end

        # Snapshot of all lanes and rows across all service levels of an organization
        class Ratecard

          attr_reader :id, :number, :effective_at, :origination_zones, :service, :published_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :effective_at, :origination_zones, :service], 'Ratecard')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @origination_zones = HttpClient::Preconditions.assert_class('origination_zones', opts.delete(:origination_zones), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x)) }
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::RatecardServiceReference) ? x : ::Io::Flow::V0::Models::RatecardServiceReference.new(x))
            @published_at = (x = opts.delete(:published_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('published_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Ratecard.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :effective_at => effective_at,
              :origination_zones => origination_zones.map { |o| o.to_hash },
              :service => service.to_hash,
              :published_at => published_at
            }
          end

        end

        # Represents a summary of a cost estimate based on rate card data for an
        # origin/destination and weight, either gravitational or dimensional
        class RatecardEstimate

          attr_reader :service, :shipment_window, :currency, :amount, :fees, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :shipment_window, :currency, :amount, :fees, :total], 'RatecardEstimate')
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::RatecardServiceReference) ? x : ::Io::Flow::V0::Models::RatecardServiceReference.new(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @fees = HttpClient::Preconditions.assert_class('fees', opts.delete(:fees), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardFee) ? x : ::Io::Flow::V0::Models::RatecardFee.from_json(x)) }
            @total = HttpClient::Preconditions.assert_class('total', opts.delete(:total), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service.to_hash,
              :shipment_window => shipment_window.to_hash,
              :currency => currency,
              :amount => amount,
              :fees => fees.map { |o| o.to_hash },
              :total => total
            }
          end

        end

        class RatecardForm

          attr_reader :effective_at, :number, :origination_zones, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:effective_at, :number, :origination_zones, :service], 'RatecardForm')
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origination_zones = HttpClient::Preconditions.assert_class('origination_zones', opts.delete(:origination_zones), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x)) }
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :effective_at => effective_at,
              :number => number,
              :origination_zones => origination_zones.map { |o| o.to_hash },
              :service => service
            }
          end

        end

        # Describe list of rates applicable for a lane on the ratecard - defined by
        # origin and destination zone
        class RatecardLane

          attr_reader :id, :currency, :delivered_duty, :shipment_window, :destination, :dim_factor, :fees, :origin, :service, :rates, :rounding, :weight_unit, :distance_unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :currency, :delivered_duty, :shipment_window, :destination, :dim_factor, :fees, :origin, :service, :rates, :rounding, :weight_unit, :distance_unit], 'RatecardLane')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @dim_factor = HttpClient::Preconditions.assert_class('dim_factor', opts.delete(:dim_factor), Numeric)
            @fees = HttpClient::Preconditions.assert_class('fees', opts.delete(:fees), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardFee) ? x : ::Io::Flow::V0::Models::RatecardFee.from_json(x)) }
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::RatecardServiceReference) ? x : ::Io::Flow::V0::Models::RatecardServiceReference.new(x))
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardRate) ? x : ::Io::Flow::V0::Models::RatecardRate.new(x)) }
            @rounding = (x = opts.delete(:rounding); x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x))
            @weight_unit = (x = opts.delete(:weight_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @distance_unit = (x = opts.delete(:distance_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLane.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :currency => currency,
              :delivered_duty => delivered_duty.value,
              :shipment_window => shipment_window.to_hash,
              :destination => destination.to_hash,
              :dim_factor => dim_factor,
              :fees => fees.map { |o| o.to_hash },
              :origin => origin.to_hash,
              :service => service.to_hash,
              :rates => rates.map { |o| o.to_hash },
              :rounding => rounding.to_hash,
              :weight_unit => weight_unit.value,
              :distance_unit => distance_unit.value
            }
          end

        end

        class RatecardLaneForm

          attr_reader :currency, :destination, :shipment_window, :delivered_duty, :dim_factor, :fees, :origin, :rounding, :rates, :weight_unit, :distance_unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :destination, :shipment_window, :delivered_duty, :dim_factor, :fees, :origin, :rounding, :rates, :weight_unit, :distance_unit], 'RatecardLaneForm')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @shipment_window = (x = opts.delete(:shipment_window); x.is_a?(::Io::Flow::V0::Models::ShipmentWindow) ? x : ::Io::Flow::V0::Models::ShipmentWindow.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @dim_factor = HttpClient::Preconditions.assert_class('dim_factor', opts.delete(:dim_factor), Numeric)
            @fees = HttpClient::Preconditions.assert_class('fees', opts.delete(:fees), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardFee) ? x : ::Io::Flow::V0::Models::RatecardFee.from_json(x)) }
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::Zone) ? x : ::Io::Flow::V0::Models::Zone.new(x))
            @rounding = (x = opts.delete(:rounding); x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x))
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RatecardRateForm) ? x : ::Io::Flow::V0::Models::RatecardRateForm.new(x)) }
            @weight_unit = (x = opts.delete(:weight_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
            @distance_unit = (x = opts.delete(:distance_unit); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLaneForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :destination => destination.to_hash,
              :shipment_window => shipment_window.to_hash,
              :delivered_duty => delivered_duty.value,
              :dim_factor => dim_factor,
              :fees => fees.map { |o| o.to_hash },
              :origin => origin.to_hash,
              :rounding => rounding.to_hash,
              :rates => rates.map { |o| o.to_hash },
              :weight_unit => weight_unit.value,
              :distance_unit => distance_unit.value
            }
          end

        end

        class RatecardLaneVersion

          attr_reader :id, :timestamp, :type, :ratecard_lane

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :ratecard_lane], 'RatecardLaneVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @ratecard_lane = (x = opts.delete(:ratecard_lane); x.is_a?(::Io::Flow::V0::Models::RatecardLane) ? x : ::Io::Flow::V0::Models::RatecardLane.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardLaneVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :ratecard_lane => ratecard_lane.to_hash
            }
          end

        end

        # Specific line item in a ratecard lane with information on a weight threshold
        # and corresponding amount to charge
        class RatecardRate

          attr_reader :id, :amount, :weight

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :amount, :weight], 'RatecardRate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @weight = HttpClient::Preconditions.assert_class('weight', opts.delete(:weight), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardRate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :amount => amount,
              :weight => weight
            }
          end

        end

        class RatecardRateForm

          attr_reader :amount, :weight

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :weight], 'RatecardRateForm')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @weight = HttpClient::Preconditions.assert_class('weight', opts.delete(:weight), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardRateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :weight => weight
            }
          end

        end

        class RatecardRateVersion

          attr_reader :id, :timestamp, :type, :ratecard_rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :ratecard_rate], 'RatecardRateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @ratecard_rate = (x = opts.delete(:ratecard_rate); x.is_a?(::Io::Flow::V0::Models::RatecardRate) ? x : ::Io::Flow::V0::Models::RatecardRate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardRateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :ratecard_rate => ratecard_rate.to_hash
            }
          end

        end

        class RatecardServiceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'RatecardServiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardServiceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class RatecardVersion

          attr_reader :id, :timestamp, :type, :ratecard

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :ratecard], 'RatecardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @ratecard = (x = opts.delete(:ratecard); x.is_a?(::Io::Flow::V0::Models::Ratecard) ? x : ::Io::Flow::V0::Models::Ratecard.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RatecardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :ratecard => ratecard.to_hash
            }
          end

        end

        # Refunds are used to issue refunds against a prior capture.
        class Refund

          attr_reader :id, :reference, :capture, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :capture, :amount, :currency], 'Refund')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Refund.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :capture => capture.to_hash,
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Refund actually transfers funds. You can refund as many times as you'd like up
        # until the total amount of the capture has been refunded.
        class RefundForm

          attr_reader :capture_id, :reference, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:capture_id], 'RefundForm')
            @capture_id = HttpClient::Preconditions.assert_class('capture_id', opts.delete(:capture_id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :capture_id => capture_id,
              :reference => reference,
              :amount => amount,
              :currency => currency
            }
          end

        end

        class RefundVersion

          attr_reader :id, :timestamp, :type, :refund

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :refund], 'RefundVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :refund => refund.to_hash
            }
          end

        end

        # A region represents a geographic area of the world. Regions can be countries,
        # continents or other political areas (like the Eurozone).
        class Region

          attr_reader :id, :name, :countries, :currencies, :languages, :measurement_systems

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :countries, :currencies, :languages, :measurement_systems], 'Region')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
            @currencies = HttpClient::Preconditions.assert_class('currencies', opts.delete(:currencies), Array).map { |v| HttpClient::Preconditions.assert_class('currencies', v, String) }
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_systems = HttpClient::Preconditions.assert_class('measurement_systems', opts.delete(:measurement_systems), Array).map { |v| HttpClient::Preconditions.assert_class('measurement_systems', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Region.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :countries => countries,
              :currencies => currencies,
              :languages => languages,
              :measurement_systems => measurement_systems
            }
          end

        end

        class RegionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'RegionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RegionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class Rounding

          attr_reader :type, :method, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :method, :value], 'Rounding')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::RoundingType) ? x : ::Io::Flow::V0::Models::RoundingType.apply(x))
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::RoundingMethod) ? x : ::Io::Flow::V0::Models::RoundingMethod.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rounding.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :method => method.value,
              :value => value
            }
          end

        end

        # Represents operating calendar and holidays of a center
        class Schedule

          attr_reader :calendar, :holiday, :exception, :cutoff

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:holiday, :exception], 'Schedule')
            @calendar = (x = opts.delete(:calendar); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Calendar) ? x : ::Io::Flow::V0::Models::Calendar.apply(x)))
            @holiday = (x = opts.delete(:holiday); x.is_a?(::Io::Flow::V0::Models::HolidayCalendar) ? x : ::Io::Flow::V0::Models::HolidayCalendar.apply(x))
            @exception = HttpClient::Preconditions.assert_class('exception', opts.delete(:exception), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Exception) ? x : ::Io::Flow::V0::Models::Exception.new(x)) }
            @cutoff = (x = opts.delete(:cutoff); x.nil? ? nil : HttpClient::Preconditions.assert_class('cutoff', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Schedule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :calendar => calendar.nil? ? nil : calendar.value,
              :holiday => holiday.value,
              :exception => exception.map { |o| o.to_hash },
              :cutoff => cutoff
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class Service

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'Service')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Service.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class ServiceForm

          attr_reader :name, :carrier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :carrier], 'ServiceForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :carrier => carrier
            }
          end

        end

        class ServiceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ServiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ServiceSummary

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'ServiceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::CarrierReference) ? x : ::Io::Flow::V0::Models::CarrierReference.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class ServiceVersion

          attr_reader :id, :timestamp, :type, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :service], 'ServiceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :service => service.to_hash
            }
          end

        end

        # Represents a subset of items from an order grouped into a single physical
        # shipment. Flow provides a generated tracking number to track this shipment
        # across multiple possible hops and carriers.
        class Shipment

          attr_reader :id, :commercial_invoice, :destination, :items, :shipment_labels, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :commercial_invoice, :destination, :items, :shipment_labels, :tracking_number], 'Shipment')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @commercial_invoice = HttpClient::Preconditions.assert_class('commercial_invoice', opts.delete(:commercial_invoice), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @shipment_labels = HttpClient::Preconditions.assert_class('shipment_labels', opts.delete(:shipment_labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentLabel) ? x : ::Io::Flow::V0::Models::ShipmentLabel.new(x)) }
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Shipment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :commercial_invoice => commercial_invoice,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :shipment_labels => shipment_labels.map { |o| o.to_hash },
              :tracking_number => tracking_number
            }
          end

        end

        # Represents a subset of items from an order grouped into a single physical
        # shipment.
        class ShipmentForm

          attr_reader :destination, :items, :shipment_labels

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :items], 'ShipmentForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @shipment_labels = (x = opts.delete(:shipment_labels); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipment_labels', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentLabelForm) ? x : ::Io::Flow::V0::Models::ShipmentLabelForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :shipment_labels => shipment_labels.nil? ? nil : shipment_labels.map { |o| o.to_hash }
            }
          end

        end

        # Top-level information on shipment tracking shipment_label and number
        class ShipmentLabel

          attr_reader :id, :service, :tracking_number, :window, :pdf, :zpl

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :tracking_number], 'ShipmentLabel')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabel.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :pdf => pdf,
              :zpl => zpl
            }
          end

        end

        # Top-level information on shipment tracking shipment_label and number
        class ShipmentLabelForm

          attr_reader :service, :tracking_number, :window, :data, :shipment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :tracking_number], 'ShipmentLabelForm')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @data = (x = opts.delete(:data); x.nil? ? nil : HttpClient::Preconditions.assert_class('data', x, String))
            @shipment = (x = opts.delete(:shipment); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipment', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :data => data,
              :shipment => shipment
            }
          end

        end

        class ShipmentLabelReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ShipmentLabelReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ShipmentLabelSummary

          attr_reader :id, :service, :tracking_number, :window, :pdf, :zpl

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :tracking_number], 'ShipmentLabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :pdf => pdf,
              :zpl => zpl
            }
          end

        end

        class ShipmentLabelVersion

          attr_reader :id, :timestamp, :type, :shipment_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipment_label], 'ShipmentLabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipment_label = (x = opts.delete(:shipment_label); x.is_a?(::Io::Flow::V0::Models::ShipmentLabelSummary) ? x : ::Io::Flow::V0::Models::ShipmentLabelSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipment_label => shipment_label.to_hash
            }
          end

        end

        class ShipmentReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ShipmentReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ShipmentSummary

          attr_reader :id, :commercial_invoice, :destination, :items, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :commercial_invoice, :destination, :items, :tracking_number], 'ShipmentSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @commercial_invoice = HttpClient::Preconditions.assert_class('commercial_invoice', opts.delete(:commercial_invoice), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :commercial_invoice => commercial_invoice,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :tracking_number => tracking_number
            }
          end

        end

        class ShipmentVersion

          attr_reader :id, :timestamp, :type, :shipment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipment], 'ShipmentVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipment = (x = opts.delete(:shipment); x.is_a?(::Io::Flow::V0::Models::ShipmentSummary) ? x : ::Io::Flow::V0::Models::ShipmentSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipment => shipment.to_hash
            }
          end

        end

        class ShipmentWindow

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'ShipmentWindow')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class ShippingAddress

          attr_reader :contact, :location

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contact, :location], 'ShippingAddress')
            @contact = (x = opts.delete(:contact); x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x))
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingAddress.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contact => contact.to_hash,
              :location => location.to_hash
            }
          end

        end

        class SpotRate

          attr_reader :id, :effective_at, :base, :target, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :effective_at, :base, :target, :value], 'SpotRate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SpotRate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :effective_at => effective_at,
              :base => base,
              :target => target,
              :value => value
            }
          end

        end

        class SpotRateForm

          attr_reader :effective_at, :base, :target, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:effective_at, :base, :target, :value], 'SpotRateForm')
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SpotRateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :effective_at => effective_at,
              :base => base,
              :target => target,
              :value => value
            }
          end

        end

        class SpotRateVersion

          attr_reader :id, :timestamp, :type, :spot_rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :spot_rate], 'SpotRateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @spot_rate = (x = opts.delete(:spot_rate); x.is_a?(::Io::Flow::V0::Models::SpotRate) ? x : ::Io::Flow::V0::Models::SpotRate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SpotRateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :spot_rate => spot_rate.to_hash
            }
          end

        end

        # A configuration with custom query to select a subset of master catalog items
        # for a localized experience
        class Subcatalog < ExpandableSubcatalog

          attr_reader :id, :catalog, :settings

          def initialize(incoming={})
            super(:name => ExpandableSubcatalog::Types::SUBCATALOG)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :catalog, :settings], 'Subcatalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
            @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::V0::Models::SubcatalogSettings) ? x : ::Io::Flow::V0::Models::SubcatalogSettings.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Subcatalog.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :catalog => catalog.to_hash,
              :settings => settings.to_hash
            }
          end

        end

        class SubcatalogForm

          attr_reader :settings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @settings = (x = opts.delete(:settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogSettingsForm) ? x : ::Io::Flow::V0::Models::SubcatalogSettingsForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :settings => settings.nil? ? nil : settings.to_hash
            }
          end

        end

        class SubcatalogFunction

          attr_reader :id, :item_function, :q, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item_function, :q, :position], 'SubcatalogFunction')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item_function = (x = opts.delete(:item_function); x.is_a?(::Io::Flow::V0::Models::ItemFunction) ? x : ::Io::Flow::V0::Models::ItemFunction.new(x))
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogFunction.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item_function => item_function.to_hash,
              :q => q,
              :position => position
            }
          end

        end

        class SubcatalogFunctionForm

          attr_reader :item_function_id, :q, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_function_id], 'SubcatalogFunctionForm')
            @item_function_id = HttpClient::Preconditions.assert_class('item_function_id', opts.delete(:item_function_id), String)
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogFunctionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_function_id => item_function_id,
              :q => q,
              :position => position
            }
          end

        end

        class SubcatalogFunctionVersion

          attr_reader :id, :timestamp, :type, :subcatalog_function

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog_function], 'SubcatalogFunctionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog_function = (x = opts.delete(:subcatalog_function); x.is_a?(::Io::Flow::V0::Models::SubcatalogFunction) ? x : ::Io::Flow::V0::Models::SubcatalogFunction.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogFunctionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog_function => subcatalog_function.to_hash
            }
          end

        end

        # Represents information specific to an item in a given subcatalog
        class SubcatalogItem

          attr_reader :id, :item, :item_function, :item_status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :item_status], 'SubcatalogItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
            @item_function = (x = opts.delete(:item_function); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExpandableItemFunction) ? x : ::Io::Flow::V0::Models::ExpandableItemFunction.from_json(x)))
            @item_status = (x = opts.delete(:item_status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :item_function => item_function.nil? ? nil : item_function.to_hash,
              :item_status => item_status.value
            }
          end

        end

        class SubcatalogReference < ExpandableSubcatalog

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableSubcatalog::Types::SUBCATALOG_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SubcatalogReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class SubcatalogSettings

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = (x = opts.delete(:update_policy); x.nil? ? "auto" : x); x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.value
            }
          end

        end

        class SubcatalogSettingsForm

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = opts.delete(:update_policy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.nil? ? nil : update_policy.value
            }
          end

        end

        # Statistics related to the items in this subcatalog, including item count,
        # number of distinct categories, etc.
        class SubcatalogStatistics

          attr_reader :excluded, :included, :restricted, :queue, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:excluded, :included, :restricted, :queue, :catalog], 'SubcatalogStatistics')
            @excluded = (x = opts.delete(:excluded); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @included = (x = opts.delete(:included); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @restricted = (x = opts.delete(:restricted); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @queue = (x = opts.delete(:queue); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogStatistics) ? x : ::Io::Flow::V0::Models::CatalogStatistics.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :excluded => excluded.to_hash,
              :included => included.to_hash,
              :restricted => restricted.to_hash,
              :queue => queue.to_hash,
              :catalog => catalog.to_hash
            }
          end

        end

        class SubcatalogVersion

          attr_reader :id, :timestamp, :type, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog], 'SubcatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::Subcatalog) ? x : ::Io::Flow::V0::Models::Subcatalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog => subcatalog.to_hash
            }
          end

        end

        class Suggestion

          attr_reader :label, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label, :count], 'Suggestion')
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Suggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label => label,
              :count => count
            }
          end

        end

        # Represents a simple model of taxes that apply to a given item / destination.
        class Tax

          attr_reader :name, :rate, :components, :deminimus

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :rate, :components], 'Tax')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimus = (x = opts.delete(:deminimus); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimus) ? x : ::Io::Flow::V0::Models::Deminimus.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tax.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimus => deminimus.nil? ? nil : deminimus.to_hash
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class Tier

          attr_reader :id, :experience, :integration, :name, :rules, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'Tier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x)) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services.map { |o| o.to_hash },
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        # Grouping of shipping tiers by experience to provide logical default
        # functionality.
        class TierDefault

          attr_reader :id, :default_tier, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :default_tier, :experience], 'TierDefault')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @default_tier = (x = opts.delete(:default_tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDefault.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :default_tier => default_tier.to_hash,
              :experience => experience.to_hash
            }
          end

        end

        # Form to set the defualt tier for a given experience
        class TierDefaultForm

          attr_reader :default_tier, :currency, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:default_tier, :currency, :experience], 'TierDefaultForm')
            @default_tier = HttpClient::Preconditions.assert_class('default_tier', opts.delete(:default_tier), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDefaultForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :default_tier => default_tier,
              :currency => currency,
              :experience => experience
            }
          end

        end

        class TierDefaultVersion

          attr_reader :id, :timestamp, :type, :tier_default

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier_default], 'TierDefaultVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier_default = (x = opts.delete(:tier_default); x.is_a?(::Io::Flow::V0::Models::TierDefault) ? x : ::Io::Flow::V0::Models::TierDefault.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDefaultVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier_default => tier_default.to_hash
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class TierForm

          attr_reader :currency, :experience, :integration, :name, :rules, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'TierForm')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRuleForm) ? x : ::Io::Flow::V0::Models::TierRuleForm.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', v, String) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :experience => experience,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services,
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        class TierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'TierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # System to filter incoming quote for a shipment request based on a query and
        # output corresponding outcomes.
        class TierRule

          attr_reader :id, :position, :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :position, :query, :outcome], 'TierRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::TierRuleOutcome) ? x : ::Io::Flow::V0::Models::TierRuleOutcome.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :position => position,
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        class TierRuleForm

          attr_reader :position, :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:query, :outcome], 'TierRuleForm')
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::TierRuleOutcome) ? x : ::Io::Flow::V0::Models::TierRuleOutcome.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :position => position,
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        class TierRuleVersion

          attr_reader :id, :timestamp, :type, :tier_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier_rule], 'TierRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier_rule = (x = opts.delete(:tier_rule); x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier_rule => tier_rule.to_hash
            }
          end

        end

        class TierSummary

          attr_reader :id, :experience, :integration, :name, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :integration, :name, :services, :strategy, :visibility], 'TierSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x)) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :integration => integration.value,
              :name => name,
              :services => services.map { |o| o.to_hash },
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        class TierVersion

          attr_reader :id, :timestamp, :type, :tier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier], 'TierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierSummary) ? x : ::Io::Flow::V0::Models::TierSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier => tier.to_hash
            }
          end

        end

        # Time zone data is provided by the public IANA time zone database. See
        # http://www.iana.org/time-zones
        class Timezone

          attr_reader :name, :description, :offset

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :description, :offset], 'Timezone')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @offset = HttpClient::Preconditions.assert_class('offset', opts.delete(:offset), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Timezone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :description => description,
              :offset => offset
            }
          end

        end

        # All of the metadata associated with a given token.
        class Token

          attr_reader :id, :user, :partial, :created_at, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user, :partial, :created_at], 'Token')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @partial = HttpClient::Preconditions.assert_class('partial', opts.delete(:partial), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Token.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash,
              :partial => partial,
              :created_at => created_at,
              :description => description
            }
          end

        end

        # Used to authenticate a given token.
        class TokenAuthenticationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'TokenAuthenticationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenAuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        # Used to create a new token for the user authorized by the request. You can
        # only create an API token for your own account.
        class TokenForm

          attr_reader :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :description => description
            }
          end

        end

        # Summary data for a given token
        class TokenReference

          attr_reader :id, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user], 'TokenReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash
            }
          end

        end

        class TokenVersion

          attr_reader :id, :timestamp, :type, :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :token], 'TokenVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @token = (x = opts.delete(:token); x.is_a?(::Io::Flow::V0::Models::Token) ? x : ::Io::Flow::V0::Models::Token.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :token => token.to_hash
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class Tracking

          attr_reader :id, :status, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :metadata], 'Tracking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @metadata = HttpClient::Preconditions.assert_class('metadata', HttpClient::Helper.to_object(opts.delete(:metadata)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tracking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :metadata => metadata
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class TrackingForm

          attr_reader :status, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x)))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.nil? ? nil : status.value,
              :metadata => metadata
            }
          end

        end

        class TrackingSummary

          attr_reader :id, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status], 'TrackingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value
            }
          end

        end

        class TrackingVersion

          attr_reader :id, :timestamp, :type, :tracking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking], 'TrackingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking => tracking.to_hash
            }
          end

        end

        # Represents a single user in the system
        class User < ExpandableUser

          attr_reader :id, :email, :name

          def initialize(incoming={})
            super(:name => ExpandableUser::Types::USER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'User')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            User.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :email => email,
              :name => name.to_hash
            }
          end

        end

        class UserForm

          attr_reader :email, :password, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @password = (x = opts.delete(:password); x.nil? ? nil : HttpClient::Preconditions.assert_class('password', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserPutForm

          attr_reader :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserReference < ExpandableUser

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableUser::Types::USER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'UserReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class UserSummary

          attr_reader :id, :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'UserSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :email => email,
              :name => name
            }
          end

        end

        class UserVersion

          attr_reader :id, :timestamp, :type, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :user], 'UserVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::User) ? x : ::Io::Flow::V0::Models::User.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :user => user.to_hash
            }
          end

        end

        # Model used to report whether or not a given token is valid
        class Validation

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Validation')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Validation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # Defines the payload of a request to validate a token, with primary goal of
        # preventing the token from being included in an HTTP GET.
        class ValidationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'ValidationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ValidationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        class Zone

          attr_reader :province, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country], 'Zone')
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Zone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :province => province,
              :country => country
            }
          end

        end

      end

      # ===== END OF SERVICE DEFINITION =====
      module HttpClient

        class Request

          def initialize(uri)
            @uri = Preconditions.assert_class('uri', uri, URI)
            @params = nil
            @body = nil
            @auth = nil
            @headers = {}
            @header_keys_lower_case = []
          end

          def with_header(name, value)
            Preconditions.check_not_blank('name', name, "Header name is required")
            Preconditions.check_not_blank('value', value, "Header value is required")
            Preconditions.check_state(!@headers.has_key?(name),
                                      "Duplicate header named[%s]" % name)
            @headers[name] = value
            @header_keys_lower_case << name.downcase
            self
          end

          def with_auth(auth)
            Preconditions.assert_class('auth', auth, HttpClient::Authorization)
            Preconditions.check_state(@auth.nil?, "auth previously set")

            if auth.scheme.name == AuthScheme::BASIC.name
              @auth = auth
            else
              raise "Auth Scheme[#{auth.scheme.name}] not supported"
            end
            self
          end

          def with_query(params)
            Preconditions.assert_class('params', params, Hash)
            Preconditions.check_state(@params.nil?, "Already have query parameters")
            @params = params
            self
          end

          # Wrapper to set Content-Type header to application/json and set
          # the provided json document as the body
          def with_json(json)
            @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
            with_body(json)
          end

          def with_body(body)
            Preconditions.check_not_blank('body', body)
            @body = body
            self
          end

          # Creates a new Net:HTTP client. The client returned should be
          # fully configured to make a request.
          def new_http_client
            client = Net::HTTP.new(@uri.host, @uri.port)
            if @uri.scheme == "https"
              configure_ssl(client)
            end
            client
          end

          # If HTTPS is required, this method accepts an HTTP Client and configures SSL
          def configure_ssl(http)
            Preconditions.assert_class('http', http, Net::HTTP)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_PEER
            http.cert_store = OpenSSL::X509::Store.new
            http.cert_store.set_default_paths
          end

          def get(&block)
            do_request(Net::HTTP::Get, &block)
          end

          def delete(&block)
            do_request(Net::HTTP::Delete, &block)
          end

          def options(&block)
            do_request(Net::HTTP::Options, &block)
          end

          def post(&block)
            do_request(Net::HTTP::Post, &block)
          end

          def put(&block)
            do_request(Net::HTTP::Put, &block)
          end

          class PATCH < Net::HTTP::Put
            METHOD = "PATCH"
          end

          def patch(&block)
            do_request(PATCH, &block)
          end

          def do_request(klass)
            Preconditions.assert_class('klass', klass, Class)

            uri = @uri.to_s
            if q = to_query(@params)
              uri += "?%s" % q
            end

            request = klass.send(:new, uri)

            curl = ['curl']
            if klass != Net::HTTP::Get
              curl << "-X%s" % klass.name.split("::").last.upcase
            end

            if @body
              # DEBUG path = "/tmp/rest_client.tmp"
              # DEBUG File.open(path, "w") { |os| os << @body.to_s }
              # DEBUG curl << "-d@%s" % path
              request.body = @body
            end

            if @auth
              curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
              Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                        "Cannot specify both an Authorization header and an auth instance")
              user_pass = "%s:%s" % [@auth.username, @auth.password]
              encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
              request.add_field("Authorization", "Basic %s" % encoded)
            end

            @headers.each { |key, value|
              curl <<  "-H \"%s: %s\"" % [key, value]
              request.add_field(key, value)
            }

            curl << "'%s'" % uri
            # DEBUG puts curl.join(" ")

            raw_response = http_request(request)
            response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

            if block_given?
              yield response
            else
              response
            end
          end

          private
          def to_query(params={})
            parts = (params || {}).map { |k,v|
              if v.respond_to?(:each)
                v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
              else
                "%s=%s" % [k, CGI.escape(v.to_s)]
              end
            }
            parts.empty? ? nil : parts.join("&")
          end

          def http_request(request)
            response = begin
                         new_http_client.request(request)
                       rescue SocketError => e
                         raise Exception.new("Error accessing uri[#{@uri}]: #{e}")
                       end

            case response
            when Net::HTTPSuccess
              response.body
            else
              body = response.body rescue nil
              raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => @uri.to_s)
            end
          end
        end

        class ServerError < StandardError

          attr_reader :code, :details, :body, :uri

          def initialize(code, details, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @code = HttpClient::Preconditions.assert_class('code', code, Integer)
            @details = HttpClient::Preconditions.assert_class('details', details, String)
            @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
            @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
            super(self.message)
          end

          def message
            m = "%s %s" % [@code, @details]
            if @body
              m << ": %s" % @body
            end
            m
          end

          def body_json
            JSON.parse(@body)
          end

        end

        class PreconditionException < Exception

          attr_reader :message

          def initialize(message)
            super(message)
            @message = message
          end

        end

        module Preconditions

          def Preconditions.check_argument(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_argument failed")
            end
            nil
          end

          def Preconditions.check_state(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_state failed")
            end
            nil
          end

          def Preconditions.check_not_nil(field_name, reference, error_message=nil)
            if reference.nil?
              raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
            end
            reference
          end

          def Preconditions.check_not_blank(field_name, reference, error_message=nil)
            if reference.to_s.strip == ""
              raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
            end
            reference
          end

          # Throws an error if opts is not empty. Useful when parsing
          # arguments to a function
          def Preconditions.assert_empty_opts(opts)
            if !opts.empty?
              raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
            end
          end

          # Requires that the provided hash has the specified keys.
          # @param fields A list of symbols
          def Preconditions.require_keys(hash, fields, error_prefix=nil)
            missing = fields.select { |f| !hash.has_key?(f) }
            if !missing.empty?
              msg = "Missing required fields: " + missing.join(", ")
              raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
            end
          end

          # Asserts that value is not nill and is_?(klass). Returns
          # value. Common use is
          #
          # amount = Preconditions.assert_class('amount', amount, BigDecimal)
          def Preconditions.assert_class(field_name, value, klass)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('klass', klass)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
            Preconditions.check_state(value.is_a?(klass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_class_or_nil(field_name, value, klass)
            if !value.nil?
              Preconditions.assert_class(field_name, value, klass)
            end
          end

          def Preconditions.assert_boolean(field_name, value)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
            Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_boolean_or_nil(field_name, value)
            if !value.nil?
              Preconditions.assert_boolean(field_name, value)
            end
          end

          def Preconditions.assert_collection_of_class(field_name, values, klass)
            Preconditions.assert_class(field_name, values, Array)
            values.each { |v| Preconditions.assert_class(field_name, v, klass) }
          end

          def Preconditions.assert_hash_of_class(field_name, hash, klass)
            Preconditions.assert_class(field_name, hash, Hash)
            values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
          end

        end

        class AuthScheme

          attr_reader :name

          def initialize(name)
            @name = HttpClient::Preconditions.check_not_blank('name', name)
          end

          BASIC = AuthScheme.new("basic") unless defined?(BASIC)

        end

        class Authorization

          attr_reader :scheme, :username, :password

          def initialize(scheme, username, opts={})
            @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
            @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
            @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
          end

          def Authorization.basic(username, password=nil)
            Authorization.new(AuthScheme::BASIC, username, :password => password)
          end

        end

        module Helper

          def Helper.symbolize_keys(hash)
            Preconditions.assert_class('hash', hash, Hash)
            new_hash = {}
            hash.each { |k, v|
              new_hash[k.to_sym] = v
            }
            new_hash
          end

          def Helper.to_big_decimal(value)
            value ? BigDecimal.new(value.to_s) : nil
          end

          def Helper.to_object(value)
            value ? JSON.parse(value) : nil
          end

          def Helper.to_uuid(value)
            Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                      "Invalid guid[%s]" % value)
            value
          end

          def Helper.to_date_iso8601(value)
            if value.is_a?(Date)
              value
            elsif value
              Date.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.to_date_time_iso8601(value)
            if value.is_a?(DateTime)
              value
            elsif value
              DateTime.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.date_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%d')
          end

          def Helper.date_time_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
          end

          TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
          FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

          def Helper.to_boolean(field_name, value)
            string = value.to_s.strip.downcase
            if TRUE_STRINGS.include?(string)
              true
            elsif FALSE_STRINGS.include?(string)
              false
            elsif string != ""
              raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
            else
              nil
            end
          end

        end

      end
    end
  end
end